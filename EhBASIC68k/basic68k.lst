 AS V1.42 Beta [Bld 269] - Source File BASIC68K.ASM - Page 1 - 6/12/2024 11:45:36


    1/       0 :                        	page	0
    2/       0 :                        	CPU	68000
    3/       0 :                        	SUPMODE	ON
    4/       0 :                        ;********************************************************************************
    5/       0 :                        ;										*
    6/       0 :                        ;	Enhanced BASIC for the Motorola MC680xx					*
    7/       0 :                        ;										*
    8/       0 :                        ;	This version is for the TS2 single board computer.			*
    9/       0 :                        ;	Jeff Tranter (tranter@pobox.com)					*
   10/       0 :                        ;										*
   11/       0 :                        ;********************************************************************************
   12/       0 :                        ;    										*
   13/       0 :                        ; Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed 	*
   14/       0 :                        ;	for personal use only. All commercial rights are reserved.		*
   15/       0 :                        ;										*
   16/       0 :                        ;	More 68000 and other projects can be found on my website at ..		*
   17/       0 :                        ;										*
   18/       0 :                        ;	 http://mycorner.no-ip.org/index.html					*
   19/       0 :                        ;										*
   20/       0 :                        ;	mail : leeedavison@googlemail.com					*
   21/       0 :                        ;										*
   22/       0 :                        ;*********************************************************************************
   23/       0 :                        
   24/       0 :                        ; Ver 3.54
   25/       0 :                        
   26/       0 :                        ; Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
   27/       0 :                        ; USB Flash Drive Host Board
   28/       0 :                        ; Ver 3.53 fixes math error that affected exponentiation ("^") and
   29/       0 :                        ;  EXP() function. Thanks to joelang for fix.
   30/       0 :                        ; Ver 3.52 stops USING$() from reading beyond the end of the format string
   31/       0 :                        ; Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
   32/       0 :                        ; Ver 3.50 unary minus in concatenate generates a type mismatch error
   33/       0 :                        ; Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
   34/       0 :                        ; Ver 3.48 allows scientific notation underflow in the USING$() function
   35/       0 :                        ; Ver 3.47 traps the use of array elements as the FOR loop variable
   36/       0 :                        ; Ver 3.46 updates function and function variable handling
   37/       0 :                        
   38/       0 :                        ;************************************************************************************
   39/       0 :                        ;
   40/       0 :                        ; Ver 3.45 makes the handling of non existant variables consistent and gives the
   41/       0 :                        ; option of not returning an error for a non existant variable. If this is the
   42/       0 :                        ; behaviour you want just change novar to some non zero value
   43/       0 :                        
   44/       0 : =$0                    novar		EQU	0					; non existant variables cause errors
   45/       0 :                        
   46/       0 :                        ; Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
   47/       0 :                        ; support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
   48/       0 :                        ; Board.
   49/       0 :                        
   50/       0 : =$0                    FLASH_SUPPORT   EQU     0
   51/       0 :                        
   52/       0 :                        ;************************************************************************************
   53/       0 :                        
   54/       0 :                        ; Ver 3.44 adds overflow indication to the USING$() function
   55/       0 :                        ; Ver 3.43 removes an undocumented feature of concatenating null strings
   56/       0 :                        ; Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
   57/       0 :                        ; Ver 3.41 removes undocumented features of the USING$() function
   58/       0 :                        ; Ver 3.40 adds the USING$() function
   59/       0 :                        ; Ver 3.33 adds the file requester to LOAD and SAVE
   60/       0 :                        ; Ver 3.32 adds the optional ELSE clause to IF .. THEN
   61/       0 :                        
   62/       0 :                        ;************************************************************************************
   63/       0 :                        ;
   64/       0 :                        ; Version 3.25 adds the option to change the behaviour of INPUT so that a null
   65/       0 :                        ; response does not cause a program break. If this is the behaviour you want just
   66/       0 :                        ; change nobrk to some non zero value.
   67/       0 :                        
   68/       0 : =$0                    nobrk		EQU	0					; null response to INPUT causes a break
   69/       0 :                        
   70/       0 :                        
   71/       0 :                        ;************************************************************************************
   72/       0 :                        ;
   73/       0 :                        ; Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
   74/       0 :                        ; pointer in a3. this means that this could now be run as a task on a multitasking
   75/       0 :                        ; system where memory resources may change.
   76/       0 :                        
   77/       0 :                        
   78/       0 :                        ;************************************************************************************
   79/       0 :                        
   80/       0 :                        
   81/       0 : =$0                    value_off	equ	0
   82/       0 :                        
   83/       0 :                        	org	value_off
   84/       0 :                        
   85/       0 :                        	ds.l	$100		; allow 1K for the stack, this should be plenty
   86/     400 :                        								; for any BASIC program that doesn't do something
   87/     400 :                        								; silly, it could even be much less.
   88/     400 :                        ram_base
   89/     400 :                        LAB_WARM	ds.w	1			; BASIC warm start entry point
   90/     402 :                        Wrmjpv		ds.l	1			; BASIC warm start jump vector
   91/     406 :                        
   92/     406 :                        Usrjmp		ds.w	1			; USR function JMP address
   93/     408 :                        Usrjpv		ds.l	1			; USR function JMP vector
   94/     40C :                        
   95/     40C :                        ; system dependant i/o vectors
   96/     40C :                        ; these are in RAM and are set at start-up
   97/     40C :                        
   98/     40C :                        V_INPT		ds.w	1			; non halting scan input device entry point
   99/     40E :                        V_INPTv		ds.l	1			; non halting scan input device jump vector
  100/     412 :                        
  101/     412 :                        V_OUTP		ds.w	1			; send byte to output device entry point
  102/     414 :                        V_OUTPv		ds.l	1			; send byte to output device jump vector
  103/     418 :                        
  104/     418 :                        V_LOAD		ds.w	1			; load BASIC program entry point
  105/     41A :                        V_LOADv		ds.l	1			; load BASIC program jump vector
  106/     41E :                        
  107/     41E :                        V_SAVE		ds.w	1			; save BASIC program entry point
  108/     420 :                        V_SAVEv		ds.l	1			; save BASIC program jump vector
  109/     424 :                        
  110/     424 :                        V_CTLC		ds.w	1			; save CTRL-C check entry point
  111/     426 :                        V_CTLCv		ds.l	1			; save CTRL-C check jump vector
  112/     42A :                        
  113/     42A :                        Itemp		ds.l	1			; temporary integer	(for GOTO etc)
  114/     42E :                        
  115/     42E :                        Smeml		ds.l	1			; start of memory		(start of program)
  116/     432 :                        
  117/     432 :                        ; the program is stored as a series of lines each line having the following format
  118/     432 :                        ;
  119/     432 :                        ;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
  120/     432 :                        ;		ds.l	1			; line number
  121/     432 :                        ;		ds.b	n			; program bytes
  122/     432 :                        ;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
  123/     432 :                        ;						; needed, to pad the line to an even number of bytes
  124/     432 :                        
  125/     432 :                        Sfncl		ds.l	1			; start of functions	(end of Program)
  126/     436 :                        
  127/     436 :                        ; the functions are stored as function name, function execute pointer and function
  128/     436 :                        ; variable name
  129/     436 :                        ;
  130/     436 :                        ;		ds.l	1			; name
  131/     436 :                        ;		ds.l	1			; execute pointer
  132/     436 :                        ;		ds.l	1			; function variable
  133/     436 :                        
  134/     436 :                        Svarl		ds.l	1			; start of variables	(end of functions)
  135/     43A :                        
  136/     43A :                        ; the variables are stored as variable name, variable value
  137/     43A :                        ;
  138/     43A :                        ;		ds.l	1			; name
  139/     43A :                        ;		ds.l	1			; packed float or integer value
  140/     43A :                        
  141/     43A :                        Sstrl		ds.l	1			; start of strings	(end of variables)
  142/     43E :                        
  143/     43E :                        ; the strings are stored as string name, string pointer and string length
  144/     43E :                        ;
  145/     43E :                        ;		ds.l	1			; name
  146/     43E :                        ;		ds.l	1			; string pointer
  147/     43E :                        ;		ds.w	1			; string length
  148/     43E :                        
  149/     43E :                        Sarryl		ds.l	1			; start of arrays		(end of strings)
  150/     442 :                        
  151/     442 :                        ; the arrays are stored as array name, array size, array dimensions count, array
  152/     442 :                        ; dimensions upper bounds and array elements
  153/     442 :                        ;
  154/     442 :                        ;		ds.l	1			; name
  155/     442 :                        ;		ds.l	1			; size including this header
  156/     442 :                        ;		ds.w	1			; dimensions count
  157/     442 :                        ;		ds.w	1			; 1st dimension upper bound
  158/     442 :                        ;		ds.w	1			; 2nd dimension upper bound
  159/     442 :                        ;		...				; ...
  160/     442 :                        ;		ds.w	1			; nth dimension upper bound
  161/     442 :                        ;
  162/     442 :                        ; then (i1+1)*(i2+1)...*(in+1) of either ..
  163/     442 :                        ;
  164/     442 :                        ;		ds.l	1			; packed float or integer value
  165/     442 :                        ;
  166/     442 :                        ; .. if float or integer, or ..
  167/     442 :                        ;
  168/     442 :                        ;		ds.l	1			; string pointer
  169/     442 :                        ;		ds.w	1			; string length
  170/     442 :                        ;
  171/     442 :                        ; .. if string
  172/     442 :                        
  173/     442 :                        Earryl		ds.l	1			; end of arrays		(start of free mem)
  174/     446 :                        Sstorl		ds.l	1			; string storage		(moving down)
  175/     44A :                        Ememl		ds.l	1			; end of memory		(upper bound of RAM)
  176/     44E :                        Sutill		ds.l	1			; string utility ptr
  177/     452 :                        Clinel		ds.l	1			; current line		(Basic line number)
  178/     456 :                        Blinel		ds.l	1			; break line		(Basic line number)
  179/     45A :                        
  180/     45A :                        Cpntrl		ds.l	1			; continue pointer
  181/     45E :                        Dlinel		ds.l	1			; current DATA line
  182/     462 :                        Dptrl		ds.l	1			; DATA pointer
  183/     466 :                        Rdptrl		ds.l	1			; read pointer
  184/     46A :                        Varname		ds.l	1			; current var name
  185/     46E :                        Cvaral		ds.l	1			; current var address
  186/     472 :                        Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
  187/     476 :                        
  188/     476 :                        des_sk_e	ds.l	6			; descriptor stack end address
  189/     48E :                        des_sk							; descriptor stack start address
  190/     48E :                        								; use a4 for the descriptor pointer
  191/     48E :                        			ds.w	1			
  192/     490 :                        Ibuffs		ds.l	$40			; start of input buffer
  193/     590 :                        Ibuffe
  194/     590 :                        								; end of input buffer
  195/     590 :                        
  196/     590 :                        FAC1_m		ds.l	1			; FAC1 mantissa1
  197/     594 :                        FAC1_e		ds.w	1			; FAC1 exponent
  198/     596 : =$595                  FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
  199/     596 :                        			ds.w	1			
  200/     598 :                        
  201/     598 :                        FAC2_m		ds.l	1			; FAC2 mantissa1
  202/     59C :                        FAC2_e		ds.l	1			; FAC2 exponent
  203/     5A0 : =$59D                  FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
  204/     5A0 : =$59E                  FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
  205/     5A0 : =$59F                  flag		EQU	FAC2_e+3		; flag byte for divide routine
  206/     5A0 :                        
  207/     5A0 :                        PRNlword	ds.l	1			; PRNG seed long word
  208/     5A4 :                        
  209/     5A4 :                        ut1_pl		ds.l	1			; utility pointer 1
  210/     5A8 :                        
  211/     5A8 :                        Asptl		ds.l	1			; array size/pointer
  212/     5AC :                        Astrtl		ds.l	1			; array start pointer
  213/     5B0 :                        
  214/     5B0 : =$5AC                  numexp		EQU	Astrtl			; string to float number exponent count
  215/     5B0 : =$5AD                  expcnt		EQU	Astrtl+1		; string to float exponent count
  216/     5B0 :                        
  217/     5B0 : =$5AF                  expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
  218/     5B0 :                        
  219/     5B0 :                        func_l		ds.l	1			; function pointer
  220/     5B4 :                        
  221/     5B4 :                        
  222/     5B4 :                        								; these two need to be a word aligned pair !
  223/     5B4 :                        Defdim		ds.w	1			; default DIM flag
  224/     5B6 : =$5B4                  cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
  225/     5B6 : =$5B5                  Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
  226/     5B6 :                        
  227/     5B6 :                        
  228/     5B6 :                        Binss		ds.l	4			; number to bin string start (32 chrs)
  229/     5C6 :                        
  230/     5C6 :                        Decss		ds.l	1			; number to decimal string start (16 chrs)
  231/     5CA :                        			ds.w	1
  232/     5CC :                        Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
  233/     5CE :                        
  234/     5CE :                        Hexss		ds.l	2			; number to hex string start (8 chrs)
  235/     5D6 :                        
  236/     5D6 :                        BHsend		ds.w	1			; bin/decimal/hex string end
  237/     5D8 :                        
  238/     5D8 :                        
  239/     5D8 :                        prstk		ds.b	1			; stacked function index
  240/     5D9 :                        
  241/     5D9 :                        tpower		ds.b	1			; remember CORDIC power
  242/     5DA :                        
  243/     5DA :                        Asrch		ds.b	1			; scan-between-quotes flag, alt search character
  244/     5DB :                        
  245/     5DB :                        Dimcnt		ds.b	1			; # of dimensions
  246/     5DC :                        
  247/     5DC :                        Breakf		ds.b	1			; break flag, $00=END else=break
  248/     5DD :                        Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
  249/     5DE :                        Gclctd		ds.b	1			; garbage collected flag
  250/     5DF :                        Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
  251/     5E0 :                        Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
  252/     5E1 :                        
  253/     5E1 :                        Cflag		ds.b	1			; comparison evaluation flag
  254/     5E2 :                        
  255/     5E2 :                        TabSiz		ds.b	1			; TAB step size
  256/     5E3 :                        
  257/     5E3 :                        comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
  258/     5E4 :                        								; bit 2 set if >
  259/     5E4 :                        								; bit 1 set if =
  260/     5E4 :                        								; bit 0 set if <
  261/     5E4 :                        
  262/     5E4 :                        Nullct		ds.b	1			; nulls output after each line
  263/     5E5 :                        TPos		ds.b	1			; BASIC terminal position byte
  264/     5E6 :                        TWidth		ds.b	1			; BASIC terminal width byte
  265/     5E7 :                        Iclim		ds.b	1			; input column limit
  266/     5E8 :                        ccflag		ds.b	1			; CTRL-C check flag
  267/     5E9 :                        ccbyte		ds.b	1			; CTRL-C last received byte
  268/     5EA :                        ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
  269/     5EB :                        
  270/     5EB :                        WORK_E:
  271/     5EB : =$600                  work_end:	EQU	(WORK_E+$100) & $ffffff00
  272/     5EB :                        
  273/     5EB : =$600                  prg_strt:	equ	work_end
  274/     5EB :                        
  275/     5EB :                        ;;;
  276/     5EB :                        ;;; Memory
  277/     5EB :                        ;;;
  278/     5EB :                        
  279/     5EB : =$0                    VECT_T:	EQU	$00000000
  280/     5EB : =$400                  PROG_B:	EQU	$00000400
  281/     5EB : =$100                  SHAD_M: EQU	$00000100	;PIC <-> 68008 Shared Memory
  282/     5EB :                        
  283/     5EB :                        
  284/     5EB :                        
  285/       0 :                        	ORG	VECT_T
  286/       0 :                        
  287/       0 :                        INIVEC:
  288/       0 :                        	;; 0-7
  289/       0 : 0000 3E00              	DC.L	ram_strt+ram_base	; Reset: Initial SSP
  290/       4 : 0000 044A              	DC.L	code_start			; Reset: Initial PC
  291/       8 :                        
  292/       8 : 0000 0400              	DC.L	DUMMY_H		; Bus Error
  293/       C : 0000 0400              	DC.L	DUMMY_H		; Address Error
  294/      10 :                        
  295/      10 : 0000 0400              	DC.L	DUMMY_H		; Illegal Instruction
  296/      14 : 0000 0400              	DC.L	DUMMY_H		; Zero Divide
  297/      18 : 0000 0400              	DC.L	DUMMY_H		; CHK Instruction
  298/      1C : 0000 0400              	DC.L	DUMMY_H		; TRAPV Instruction
  299/      20 :                        
  300/      20 :                        	;; 8-15
  301/      20 : 0000 0400              	DC.L	DUMMY_H		; Privilege Violation
  302/      24 : 0000 0400              	DC.L	DUMMY_H		; Trace
  303/      28 : 0000 0400              	DC.L	DUMMY_H		; Line 1010 Emulator
  304/      2C : 0000 0400              	DC.L	DUMMY_H		; Line 1111 Emulator
  305/      30 :                        
  306/      30 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  307/      34 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  308/      38 : 0000 0400              	DC.L	DUMMY_H		; Format Error (MC68010)
  309/      3C : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  310/      40 :                        
  311/      40 :                        	;; 16-23
  312/      40 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  313/      44 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  314/      48 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  315/      4C : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  316/      50 :                        
  317/      50 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  318/      54 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  319/      58 : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  320/      5C : 0000 0400              	DC.L	DUMMY_H		; (Unassigned, reserved)
  321/      60 :                        
  322/      60 :                        	;; 24-31
  323/      60 : 0000 0400              	DC.L	DUMMY_H		; Spurious Interrupt
  324/      64 : 0000 0400              	DC.L	DUMMY_H		; Level 1 Interrupt Autovector
  325/      68 : 0000 0400              	DC.L	DUMMY_H		; Level 2 Interrupt Autovector
  326/      6C : 0000 0400              	DC.L	DUMMY_H		; Level 3 Interrupt Autovector
  327/      70 :                        
  328/      70 : 0000 0400              	DC.L	DUMMY_H		; Level 4 Interrupt Autovector
  329/      74 : 0000 0400              	DC.L	DUMMY_H		; Level 5 Interrupt Autovector
  330/      78 : 0000 0400              	DC.L	DUMMY_H		; Level 6 Interrupt Autovector
  331/      7C : 0000 0400              	DC.L	DUMMY_H		; Level 7 Interrupt Autovector
  332/      80 :                        
  333/      80 :                        	;; 32-39
  334/      80 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #0
  335/      84 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #1
  336/      88 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #2
  337/      8C : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #3
  338/      90 :                        
  339/      90 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #4
  340/      94 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #5
  341/      98 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #6
  342/      9C : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #7
  343/      A0 :                        
  344/      A0 :                        	;; 40-47
  345/      A0 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #8
  346/      A4 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #9
  347/      A8 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #10
  348/      AC : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #11
  349/      B0 :                        
  350/      B0 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #12
  351/      B4 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #13
  352/      B8 : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #14
  353/      BC : 0000 0400              	DC.L	DUMMY_H		; TRAP Instruction Vector #15
  354/      C0 :                        
  355/      C0 :                        INIVECE:
  356/      C0 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  357/      C0 :                        ;
  358/      C0 :                        ; define shared memory area
  359/      C0 :                        ;
  360/      C0 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  361/     100 :                        	ORG	SHAD_M
  362/     100 :                        
  363/     100 :                        ;			   ; offset:
  364/     100 :                        UREQ_COM:	DS.B	1	; 0: monitor CONIN/CONOUT request command
  365/     101 :                        UNI_CHR:	DS.B	1	; 1: charcter (CONIN/CONOUT) or number of strings
  366/     102 :                        STR_addr	DS.L	1	; 2: string address
  367/     106 :                        ;--------------------------------------------------------------------------------
  368/     106 :                        CREQ_COM:	DS.B	1	; 6: PIC function CONIN/CONOUT request command
  369/     107 :                        CBI_CHR:	DS.B	1	; 7: charcter (CONIN/CONOUT) or number of strings
  370/     108 :                        disk_drive:	DS.B	1	; 8
  371/     109 :                        		DS.B	1	; 9
  372/     10A :                        disk_track:	DS.W	1	; A, B
  373/     10C :                        disk_sector:	DS.W	1	; C, D
  374/     10E :                        data_dma:	DS.L	1	; E, F, 10, 11
  375/     112 :                        req_e:
  376/     112 :                        
  377/     112 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  378/     112 :                        ;
  379/     112 :                        ; basic program
  380/     112 :                        ;
  381/     112 :                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  382/     400 :                        	ORG	PROG_B
  383/     400 :                        
  384/     400 :                        ;;;
  385/     400 :                        ;;; Exception Handler
  386/     400 :                        ;;;
  387/     400 :                        
  388/     400 :                        	;; Dummy
  389/     400 :                        DUMMY_H:
  390/     400 : 4E73                   	RTE
  391/     402 :                        
  392/     402 :                        ;----------------------------------------------------------------------------------
  393/     402 :                        ;  ---- request command to PIC
  394/     402 :                        ; UREQ_COM = 1 ; CONIN  : return char in UNI_CHR
  395/     402 :                        ;          = 2 ; CONOUT : UNI_CHR = output char
  396/     402 :                        ;          = 3 ; CONST  : return status in UNI_CHR
  397/     402 :                        ;                       : ( 0: no key, 1 : key exist )
  398/     402 :                        ;          = 4 ; STROUT : string address
  399/     402 :                        
  400/     402 :                        ;----------------------------------------------------------------------------------
  401/     402 : =$1                    REQ_CONIN:	equ	1
  402/     402 : =$3                    REQ_CONST:	equ	3
  403/     402 : =$2                    REQ_CONOUT	equ	2
  404/     402 : =$4                    REQ_STROUT	equ	4
  405/     402 : =$80000                PIC_REQ:	equ	$80000		;A19 = 1
  406/     402 :                        
  407/     402 :                        ;************************************************************************************
  408/     402 :                        ;
  409/     402 :                        ; input a character from the console into register d0
  410/     402 :                        ; else return Cb=0 if there's no character available
  411/     402 :                        
  412/     402 :                        VEC_IN:	; CONIN
  413/     402 : 6120                   	bsr	CONST
  414/     404 : 671C                   	beq	no_keyin
  415/     406 :                        
  416/     406 : 11FC 0001 0106         	move.b	#REQ_CONIN, CREQ_COM	; set CONIB request
  417/     40C :                        
  418/     40C :                        cin0:
  419/     40C : 1039 0008 0000         	move.b	PIC_REQ, d0		; request conin to PIC. Memory $80000 read
  420/     412 :                        cin1:
  421/     412 : 1038 0106              	move.b	CREQ_COM, d0
  422/     416 : 8000                   	or.b	d0, d0
  423/     418 : 66F8                   	bne	cin1
  424/     41A :                        	
  425/     41A :                        	; get character
  426/     41A : 1038 0107              	move.b	CBI_CHR, d0
  427/     41E : 003C 0001              	ORI.b	#1,CCR		; set carry, flag we got a byte
  428/     422 :                        no_keyin:
  429/     422 : 4E75                   	RTS
  430/     424 :                        
  431/     424 :                        CONST:
  432/     424 : 11FC 0003 0106         	move.b	#REQ_CONST, CREQ_COM	; set CONST request
  433/     42A : 61E0                   	bsr	cin0
  434/     42C :                        
  435/     42C :                        	; check status
  436/     42C : C03C 0001              	AND.B	#$01,D0
  437/     430 : 4E75                   	RTS
  438/     432 :                        
  439/     432 :                        ;	MOVE.B	ACIAC,D0
  440/     432 :                        ;	AND.B	#$01,D0
  441/     432 :                        ;	BEQ     NOCHR
  442/     432 :                        ;	MOVE.B	ACIAD,D0
  443/     432 :                        ;	ORI.b	#$00,d0		; set z flag on received byte
  444/     432 :                        ;	ORI.b	#1,CCR		; set carry, flag we got a byte
  445/     432 :                        ;	RTS
  446/     432 :                        ;NOCHR
  447/     432 :                        ;	ORI.b   #$00,d0
  448/     432 :                        ;	RTS
  449/     432 :                        
  450/     432 :                        ;************************************************************************************
  451/     432 :                        ;
  452/     432 :                        ; the following code is simulator specific, change to suit your system
  453/     432 :                        ; Output character to the console from register d0.b
  454/     432 :                        
  455/     432 :                        VEC_OUT:	; CONOUT
  456/     432 : 11FC 0002 0106         	move.b	#REQ_CONOUT, CREQ_COM	; set CONOUT request
  457/     438 : 11C0 0107              	move.b	d0, CBI_CHR		; set output character
  458/     43C : 60CE                   	bra	cin0
  459/     43E :                        
  460/     43E :                        ;	SWAP	D0
  461/     43E :                        ;CO0:
  462/     43E :                        ;	MOVE.B	ACIAC,D0
  463/     43E :                        ;	AND.B	#$02,D0
  464/     43E :                        ;	BEQ	CO0
  465/     43E :                        ;	SWAP	D0
  466/     43E :                        ;	MOVE.B	D0,ACIAD
  467/     43E :                        ;	RTS
  468/     43E :                        
  469/     43E :                        
  470/     43E :                        ;************************************************************************************
  471/     43E :                        ;
  472/     43E :                        ; LOAD routine for the TS2 computer (not implemented)
  473/     43E :                        
  474/     43E :                        VEC_LD
  475/     43E : 7E2E                          MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
  476/     440 : 6000 0130                     BRA             LAB_XERR                       ; do error #d7, then warm start
  477/     444 :                        
  478/     444 :                        ;************************************************************************************
  479/     444 :                        ;
  480/     444 :                        ; SAVE routine for the TS2 computer (not implemented)
  481/     444 :                        
  482/     444 :                        VEC_SV
  483/     444 : 7E2E                          MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
  484/     446 : 6000 012A                     BRA             LAB_XERR                       ; do error #d7, then warm start
  485/     44A :                        
  486/     44A :                        
  487/     44A :                        ;************************************************************************************
  488/     44A :                        
  489/     44A :                        code_start
  490/     44A :                        
  491/     44A :                        ;; Initialize PIC command request table
  492/     44A : 41F8 0100              	LEA	SHAD_M,A0
  493/     44E : 303C 0011              	MOVE	#(req_e-SHAD_M)-1,D0
  494/     452 :                        shad_0:
  495/     452 : 4218                   	CLR.B	(A0)+
  496/     454 : 51C8 FFFC              	DBF	D0,shad_0
  497/     458 :                        ;                               ; Set up ACIA parameters
  498/     458 :                        ;        LEA.L   ACIA_1,A0      ; A0 points to console ACIA
  499/     458 :                        ;        MOVE.B  #$15,(A0)      ; Set up ACIA1 constants (no IRQ,
  500/     458 :                        ;                               ; RTS* low, 8 bit, no parity, 1 stop)
  501/     458 :                        ;        LEA.L   ACIA_2,A0      ; A0 points to aux. ACIA
  502/     458 :                        ;        MOVE.B  #$15,(A0)      ; Set up ACIA2 constants (no IRQ,
  503/     458 :                        ;                               ; RTS* low, 8 bit, no parity, 1 stop)
  504/     458 :                        
  505/     458 :                        ; to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
  506/     458 :                        ; in d0. these values are at the end of the .inc file
  507/     458 :                        
  508/     458 : 207C 0000 3A00         	MOVEA.l	#ram_strt,a0		; tell BASIC where RAM starts
  509/     45E : 203C 0007 C600         	MOVE.l	#ram_size,d0			; tell BASIC how big RAM is
  510/     464 :                        
  511/     464 :                        ; end of simulator specific code
  512/     464 :                        
  513/     464 :                        
  514/     464 :                        ;************************************************************************************
  515/     464 :                        ;************************************************************************************
  516/     464 :                        ;************************************************************************************
  517/     464 :                        ;************************************************************************************
  518/     464 :                        ;
  519/     464 :                        ; Register use :- (must improve this !!)
  520/     464 :                        ;
  521/     464 :                        ;	a6 -	temp Bpntr					; temporary BASIC execute pointer
  522/     464 :                        ;	a5 -	Bpntr						; BASIC execute (get byte) pointer
  523/     464 :                        ;	a4 -	des_sk				       ; descriptor stack pointer
  524/     464 :                        ;	a3 -	ram_strt					; start of RAM. all RAM references are offsets
  525/     464 :                        ;								; from this value
  526/     464 :                        ;
  527/     464 :                        
  528/     464 :                        ;************************************************************************************
  529/     464 :                        ;
  530/     464 :                        ; BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
  531/     464 :                        ; in d0
  532/     464 :                        
  533/     464 :                        LAB_COLD
  534/     464 :                        ;	CMP.l		#$4000,d0			; compare size with 16k
  535/     464 :                        ;	BGE.s		LAB_sizok			; branch if >= 16k
  536/     464 :                        ;
  537/     464 :                        ;	MOVEQ	#5,d0					; error 5 - not enough RAM
  538/     464 :                        ;	move.b	#228,D7					; Go to TUTOR function
  539/     464 :                        ;	trap	#14						; Call TRAP14 handler
  540/     464 :                        ;
  541/     464 :                        ;LAB_sizok
  542/     464 : 2648                   	MOVEA.l	a0,a3					; copy RAM base to a3
  543/     466 : D1C0                   	ADDA.l	d0,a0					; a0 is top of RAM
  544/     468 : 2748 044A              	MOVE.l	a0,Ememl(a3)				; set end of mem
  545/     46C : 2E7C 0000 3E00         	MOVE.l	#ram_strt+ram_base,sp				; set stack to RAM start + 1k
  546/     472 :                        
  547/     472 : 303C 4EF9              	MOVE.w	#$4EF9,d0				; JMP opcode
  548/     476 : 204F                   	MOVEA.l	sp,a0					; point to start of vector table
  549/     478 :                        
  550/     478 : 30C0                   	MOVE.w	d0,(a0)+				; LAB_WARM
  551/     47A : 43FA FFE8              	LEA		LAB_COLD(pc),a1			; initial warm start vector
  552/     47E : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  553/     480 :                        
  554/     480 : 30C0                   	MOVE.w	d0,(a0)+				; Usrjmp
  555/     482 : 43FA 00DC              	LEA		LAB_FCER(pc),a1			; initial user function vector
  556/     486 :                        									; "Function call" error
  557/     486 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  558/     488 :                        
  559/     488 : 30C0                   	MOVE.w	d0,(a0)+				; V_INPT JMP opcode
  560/     48A : 43FA FF76              	LEA		VEC_IN(pc),a1			; get byte from input device vector
  561/     48E : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  562/     490 :                        
  563/     490 : 30C0                   	MOVE.w	d0,(a0)+				; V_OUTP JMP opcode
  564/     492 : 43FA FF9E              	LEA		VEC_OUT(pc),a1			; send byte to output device vector
  565/     496 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  566/     498 :                        
  567/     498 : 30C0                   	MOVE.w	d0,(a0)+				; V_LOAD JMP opcode
  568/     49A : 43FA FFA2              	LEA		VEC_LD(pc),a1			; load BASIC program vector
  569/     49E : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  570/     4A0 :                        
  571/     4A0 : 30C0                   	MOVE.w	d0,(a0)+				; V_SAVE JMP opcode
  572/     4A2 : 43FA FFA0              	LEA		VEC_SV(pc),a1			; save BASIC program vector
  573/     4A6 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  574/     4A8 :                        
  575/     4A8 : 30C0                   	MOVE.w	d0,(a0)+				; V_CTLC JMP opcode
  576/     4AA : 43FA 2634              	LEA		VEC_CC(pc),a1			; save CTRL-C check vector
  577/     4AE : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  578/     4B0 :                        
  579/     4B0 :                        ; set-up start values
  580/     4B0 :                        
  581/     4B0 :                        ;##LAB_GMEM
  582/     4B0 : 7000                   	MOVEQ	#$00,d0					; clear d0
  583/     4B2 : 1740 05E4              	MOVE.b	d0,Nullct(a3)			; default NULL count
  584/     4B6 : 1740 05E5              	MOVE.b	d0,TPos(a3)				; clear terminal position
  585/     4BA : 1740 05E8              	MOVE.b	d0,ccflag(a3)			; allow CTRL-C check
  586/     4BE : 3740 05FE              	MOVE.w	d0,prg_strt-2(a3)			; clear start word
  587/     4C2 : 3740 05D6              	MOVE.w	d0,BHsend(a3)			; clear value to string end word
  588/     4C6 :                        
  589/     4C6 : 177C 0050 05E6         	MOVE.b	#$50,TWidth(a3)			; default terminal width byte for simulator
  590/     4CC : 177C 000E 05E2         	MOVE.b	#$0E,TabSiz(a3)			; save default tab size = 14
  591/     4D2 :                        
  592/     4D2 : 177C 0038 05E7         	MOVE.b	#$38,Iclim(a3)			; default limit for TAB = 14 for simulator
  593/     4D8 :                        
  594/     4D8 : 49EB 048E              	LEA		des_sk(a3),a4			; set descriptor stack start
  595/     4DC :                        
  596/     4DC : 41EB 0600              	LEA		prg_strt(a3),a0			; get start of mem
  597/     4E0 : 2748 042E              	MOVE.l	a0,Smeml(a3)			; save start of mem
  598/     4E4 :                        
  599/     4E4 : 6100 0322              	BSR		LAB_1463				; do "NEW" and "CLEAR"
  600/     4E8 : 6100 08A0              	BSR		LAB_CRLF				; print CR/LF
  601/     4EC : 202B 044A              	MOVE.l	Ememl(a3),d0			; get end of mem
  602/     4F0 : 90AB 042E              	SUB.l		Smeml(a3),d0			; subtract start of mem
  603/     4F4 :                        
  604/     4F4 : 6100 1BDC              	BSR		LAB_295E				; print d0 as unsigned integer (bytes free)
  605/     4F8 : 41FA 3404              	LEA		LAB_SMSG(pc),a0			; point to start message
  606/     4FC : 6100 08EA              	BSR		LAB_18C3				; print null terminated string from memory
  607/     500 :                        
  608/     500 : 41FA 29E8              	LEA		LAB_RSED(pc),a0			; get pointer to value
  609/     504 : 6100 1A74              	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
  610/     508 :                        
  611/     508 : 41FA 0092              	LEA		LAB_1274(pc),a0			; get warm start vector
  612/     50C : 2748 0402              	MOVE.l	a0,Wrmjpv(a3)			; set warm start vector
  613/     510 : 6100 1FE6              	BSR		LAB_RND					; initialise
  614/     514 : 4EEB 0400              	JMP		LAB_WARM(a3)			; go do warm start
  615/     518 :                        
  616/     518 :                        
  617/     518 :                        ;************************************************************************************
  618/     518 :                        ;
  619/     518 :                        ; do format error
  620/     518 :                        
  621/     518 :                        LAB_FOER
  622/     518 : 7E2C                   	MOVEQ		#$2C,d7				; error code $2C "Format" error
  623/     51A : 6056                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  624/     51C :                        
  625/     51C :                        
  626/     51C :                        ;************************************************************************************
  627/     51C :                        ;
  628/     51C :                        ; do address error
  629/     51C :                        
  630/     51C :                        LAB_ADER
  631/     51C : 7E2A                   	MOVEQ		#$2A,d7				; error code $2A "Address" error
  632/     51E : 6052                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  633/     520 :                        
  634/     520 :                        
  635/     520 :                        ;************************************************************************************
  636/     520 :                        ;
  637/     520 :                        ; do wrong dimensions error
  638/     520 :                        
  639/     520 :                        LAB_WDER
  640/     520 : 7E28                   	MOVEQ		#$28,d7				; error code $28 "Wrong dimensions" error
  641/     522 : 604E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  642/     524 :                        
  643/     524 :                        
  644/     524 :                        ;************************************************************************************
  645/     524 :                        ;
  646/     524 :                        ; do undimensioned array error
  647/     524 :                        
  648/     524 :                        LAB_UDER
  649/     524 : 7E26                   	MOVEQ		#$26,d7				; error code $26 "undimensioned array" error
  650/     526 : 604A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  651/     528 :                        
  652/     528 :                        
  653/     528 :                        ;************************************************************************************
  654/     528 :                        ;
  655/     528 :                        ; do undefined variable error
  656/     528 :                        
  657/     528 :                        LAB_UVER
  658/     528 :                        
  659/     528 : 7E24                   	MOVEQ		#$24,d7				; error code $24 "undefined variable" error
  660/     52A : 6046                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  661/     52C :                        
  662/     52C :                        
  663/     52C :                        ;************************************************************************************
  664/     52C :                        ;
  665/     52C :                        ; do loop without do error
  666/     52C :                        
  667/     52C :                        LAB_LDER
  668/     52C : 7E22                   	MOVEQ		#$22,d7				; error code $22 "LOOP without DO" error
  669/     52E : 6042                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  670/     530 :                        
  671/     530 :                        
  672/     530 :                        ;************************************************************************************
  673/     530 :                        ;
  674/     530 :                        ; do undefined function error
  675/     530 :                        
  676/     530 :                        LAB_UFER
  677/     530 : 7E20                   	MOVEQ		#$20,d7				; error code $20 "Undefined function" error
  678/     532 : 603E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  679/     534 :                        
  680/     534 :                        
  681/     534 :                        ;************************************************************************************
  682/     534 :                        ;
  683/     534 :                        ; do can't continue error
  684/     534 :                        
  685/     534 :                        LAB_CCER
  686/     534 : 7E1E                   	MOVEQ		#$1E,d7				; error code $1E "Can't continue" error
  687/     536 : 603A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  688/     538 :                        
  689/     538 :                        
  690/     538 :                        ;************************************************************************************
  691/     538 :                        ;
  692/     538 :                        ; do string too complex error
  693/     538 :                        
  694/     538 :                        LAB_SCER
  695/     538 : 7E1C                   	MOVEQ		#$1C,d7				; error code $1C "String too complex" error
  696/     53A : 6036                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  697/     53C :                        
  698/     53C :                        
  699/     53C :                        ;************************************************************************************
  700/     53C :                        ;
  701/     53C :                        ; do string too long error
  702/     53C :                        
  703/     53C :                        LAB_SLER
  704/     53C : 7E1A                   	MOVEQ		#$1A,d7				; error code $1A "String too long" error
  705/     53E : 6032                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  706/     540 :                        
  707/     540 :                        
  708/     540 :                        ;************************************************************************************
  709/     540 :                        ;
  710/     540 :                        ; do type missmatch error
  711/     540 :                        
  712/     540 :                        LAB_TMER
  713/     540 : 7E18                   	MOVEQ		#$18,d7				; error code $18 "Type mismatch" error
  714/     542 : 602E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  715/     544 :                        
  716/     544 :                        
  717/     544 :                        ;************************************************************************************
  718/     544 :                        ;
  719/     544 :                        ; do illegal direct error
  720/     544 :                        
  721/     544 :                        LAB_IDER
  722/     544 : 7E16                   	MOVEQ		#$16,d7				; error code $16 "Illegal direct" error
  723/     546 : 602A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  724/     548 :                        
  725/     548 :                        
  726/     548 :                        ;************************************************************************************
  727/     548 :                        ;
  728/     548 :                        ; do divide by zero error
  729/     548 :                        
  730/     548 :                        LAB_DZER
  731/     548 : 7E14                   	MOVEQ		#$14,d7				; error code $14 "Divide by zero" error
  732/     54A : 6026                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  733/     54C :                        
  734/     54C :                        
  735/     54C :                        ;************************************************************************************
  736/     54C :                        ;
  737/     54C :                        ; do double dimension error
  738/     54C :                        
  739/     54C :                        LAB_DDER
  740/     54C : 7E12                   	MOVEQ		#$12,d7				; error code $12 "Double dimension" error
  741/     54E : 6022                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  742/     550 :                        
  743/     550 :                        
  744/     550 :                        ;************************************************************************************
  745/     550 :                        ;
  746/     550 :                        ; do array bounds error
  747/     550 :                        
  748/     550 :                        LAB_ABER
  749/     550 : 7E10                   	MOVEQ		#$10,d7				; error code $10 "Array bounds" error
  750/     552 : 601E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  751/     554 :                        
  752/     554 :                        
  753/     554 :                        ;************************************************************************************
  754/     554 :                        ;
  755/     554 :                        ; do undefined satement error
  756/     554 :                        
  757/     554 :                        LAB_USER
  758/     554 : 7E0E                   	MOVEQ		#$0E,d7				; error code $0E "Undefined statement" error
  759/     556 : 601A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  760/     558 :                        
  761/     558 :                        
  762/     558 :                        ;************************************************************************************
  763/     558 :                        ;
  764/     558 :                        ; do out of memory error
  765/     558 :                        
  766/     558 :                        LAB_OMER
  767/     558 : 7E0C                   	MOVEQ		#$0C,d7				; error code $0C "Out of memory" error
  768/     55A : 6016                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  769/     55C :                        
  770/     55C :                        
  771/     55C :                        ;************************************************************************************
  772/     55C :                        ;
  773/     55C :                        ; do overflow error
  774/     55C :                        
  775/     55C :                        LAB_OFER
  776/     55C : 7E0A                   	MOVEQ		#$0A,d7				; error code $0A "Overflow" error
  777/     55E : 6012                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  778/     560 :                        
  779/     560 :                        
  780/     560 :                        ;************************************************************************************
  781/     560 :                        ;
  782/     560 :                        ; do function call error
  783/     560 :                        
  784/     560 :                        LAB_FCER
  785/     560 : 7E08                   	MOVEQ		#$08,d7				; error code $08 "Function call" error
  786/     562 : 600E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  787/     564 :                        
  788/     564 :                        
  789/     564 :                        ;************************************************************************************
  790/     564 :                        ;
  791/     564 :                        ; do out of data error
  792/     564 :                        
  793/     564 :                        LAB_ODER
  794/     564 : 7E06                   	MOVEQ		#$06,d7				; error code $06 "Out of DATA" error
  795/     566 : 600A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  796/     568 :                        
  797/     568 :                        
  798/     568 :                        ;************************************************************************************
  799/     568 :                        ;
  800/     568 :                        ; do return without gosub error
  801/     568 :                        
  802/     568 :                        LAB_RGER
  803/     568 : 7E04                   	MOVEQ		#$04,d7				; error code $04 "RETURN without GOSUB" error
  804/     56A : 6006                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  805/     56C :                        
  806/     56C :                        
  807/     56C :                        ;************************************************************************************
  808/     56C :                        ;
  809/     56C :                        ; do syntax error
  810/     56C :                        
  811/     56C :                        LAB_SNER
  812/     56C : 7E02                   	MOVEQ		#$02,d7				; error code $02 "Syntax" error
  813/     56E : 6002                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  814/     570 :                        
  815/     570 :                        
  816/     570 :                        ;************************************************************************************
  817/     570 :                        ;
  818/     570 :                        ; do next without for error
  819/     570 :                        
  820/     570 :                        LAB_NFER
  821/     570 : 7E00                   	MOVEQ		#$00,d7				; error code $00 "NEXT without FOR" error
  822/     572 :                        
  823/     572 :                        
  824/     572 :                        ;************************************************************************************
  825/     572 :                        ;
  826/     572 :                        ; do error #d7, then warm start
  827/     572 :                        
  828/     572 :                        LAB_XERR
  829/     572 : 6100 02CA              	BSR		LAB_1491				; flush stack & clear continue flag
  830/     576 : 6100 0812              	BSR		LAB_CRLF				; print CR/LF
  831/     57A : 43FA 2FFA              	LEA		LAB_BAER(pc),a1			; start of error message pointer table
  832/     57E : 3E31 7000              	MOVE.w	(a1,d7.w),d7			; get error message offset
  833/     582 : 41F1 7000              	LEA		(a1,d7.w),a0			; get error message address
  834/     586 : 6100 0860              	BSR		LAB_18C3				; print null terminated string from memory
  835/     58A : 41FA 3335              	LEA		LAB_EMSG(pc),a0			; point to " Error" message
  836/     58E :                        LAB_1269
  837/     58E : 6100 0858              	BSR		LAB_18C3				; print null terminated string from memory
  838/     592 : 202B 0452              	MOVE.l	Clinel(a3),d0			; get current line
  839/     596 : 6B04                   	BMI.s	LAB_1274				; go do warm start if -ve # (was immediate mode)
  840/     598 :                        
  841/     598 :                        									; else print line number
  842/     598 : 6100 1B2C              	BSR		LAB_2953				; print " in line [LINE #]"
  843/     59C :                        
  844/     59C :                        ; BASIC warm start entry point, wait for Basic command
  845/     59C :                        
  846/     59C :                        LAB_1274
  847/     59C : 41FA 3356              	LEA		LAB_RMSG(pc),a0			; point to "Ready" message
  848/     5A0 : 6100 0846              	BSR		LAB_18C3				; go do print string
  849/     5A4 :                        
  850/     5A4 :                        ; wait for Basic command - no "Ready"
  851/     5A4 :                        
  852/     5A4 :                        LAB_127D
  853/     5A4 : 72FF                   	MOVEQ	#-1,d1					; set to -1
  854/     5A6 : 2741 0452              	MOVE.l	d1,Clinel(a3)			; set current line #
  855/     5AA : 1741 05DC              	MOVE.b	d1,Breakf(a3)			; set break flag
  856/     5AE : 4BEB 0490              	LEA		Ibuffs(a3),a5			; set basic execute pointer ready for new line
  857/     5B2 :                        LAB_127E
  858/     5B2 : 6100 00EC              	BSR		LAB_1357				; call for BASIC input
  859/     5B6 : 6100 0BFC              	BSR		LAB_GBYT				; scan memory
  860/     5BA : 67F6                   	BEQ.s	LAB_127E				; loop while null
  861/     5BC :                        
  862/     5BC :                        ; got to interpret input line now ....
  863/     5BC :                        
  864/     5BC : 6508                   	BCS.s	LAB_1295				; branch if numeric character, handle new
  865/     5BE :                        								; BASIC line
  866/     5BE :                        
  867/     5BE :                        								; no line number so do immediate mode, a5
  868/     5BE :                        								; points to the buffer start
  869/     5BE : 6100 0156              	BSR		LAB_13A6				; crunch keywords into Basic tokens
  870/     5C2 :                        								; crunch from (a5), output to (a0)
  871/     5C2 :                        								; returns ..
  872/     5C2 :                        								; d2 is length, d1 trashed, d0 trashed,
  873/     5C2 :                        								; a1 trashed
  874/     5C2 : 6000 03C6              	BRA		LAB_15F6				; go scan & interpret code
  875/     5C6 :                        
  876/     5C6 :                        
  877/     5C6 :                        ;************************************************************************************
  878/     5C6 :                        ;
  879/     5C6 :                        ; handle a new BASIC line
  880/     5C6 :                        
  881/     5C6 :                        LAB_1295
  882/     5C6 : 6100 0640              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
  883/     5CA : 6100 014A              	BSR		LAB_13A6				; crunch keywords into Basic tokens
  884/     5CE :                        								; crunch from (a5), output to (a0)
  885/     5CE :                        								; returns .. d2 is length,
  886/     5CE :                        								; d1 trashed, d0 trashed, a1 trashed
  887/     5CE : 222B 042A              	MOVE.l	Itemp(a3),d1			; get required line #
  888/     5D2 : 6100 0218              	BSR		LAB_SSLN				; search BASIC for d1 line number
  889/     5D6 :                        								; returns pointer in a0
  890/     5D6 : 6532                   	BCS.s		LAB_12E6				; branch if not found
  891/     5D8 :                        
  892/     5D8 :                        								; aroooogah! line # already exists! delete it
  893/     5D8 : 2250                   	MOVEA.l	(a0),a1				; get start of block (next line pointer)
  894/     5DA : 202B 0432              	MOVE.l	Sfncl(a3),d0			; get end of block (start of functions)
  895/     5DE : 9089                   	SUB.l		a1,d0					; subtract start of block ( = bytes to move)
  896/     5E0 : E288                   	LSR.l		#1,d0					; /2 (word move)
  897/     5E2 : 5380                   	SUBQ.l	#1,d0					; adjust for DBF loop
  898/     5E4 : 4840                   	SWAP		d0					; swap high word to low word
  899/     5E6 : 2448                   	MOVEA.l	a0,a2					; copy destination
  900/     5E8 :                        LAB_12AE
  901/     5E8 : 4840                   	SWAP		d0					; swap high word to low word
  902/     5EA :                        LAB_12B0
  903/     5EA : 34D9                   	MOVE.w	(a1)+,(a2)+				; copy word
  904/     5EC : 51C8 FFFC              	DBF		d0,LAB_12B0				; decrement low count and loop until done
  905/     5F0 :                        
  906/     5F0 : 4840                   	SWAP		d0					; swap high word to low word
  907/     5F2 : 51C8 FFF4              	DBF		d0,LAB_12AE				; decrement high count and loop until done
  908/     5F6 :                        
  909/     5F6 : 274A 0432              	MOVE.l	a2,Sfncl(a3)			; start of functions
  910/     5FA : 274A 0436              	MOVE.l	a2,Svarl(a3)			; save start of variables
  911/     5FE : 274A 043A              	MOVE.l	a2,Sstrl(a3)			; start of strings
  912/     602 : 274A 043E              	MOVE.l	a2,Sarryl(a3)			; save start of arrays
  913/     606 : 274A 0442              	MOVE.l	a2,Earryl(a3)			; save end of arrays
  914/     60A :                        
  915/     60A :                        								; got new line in buffer and no existing same #
  916/     60A :                        LAB_12E6
  917/     60A : 102B 0490              	MOVE.b	Ibuffs(a3),d0			; get byte from start of input buffer
  918/     60E : 6764                   	BEQ.s		LAB_1325				; if null line go do line chaining
  919/     610 :                        
  920/     610 :                        								; got new line and it isn't empty line
  921/     610 : 226B 0432              	MOVEA.l	Sfncl(a3),a1			; get start of functions (end of block to move)
  922/     614 : 45F1 2008              	LEA		8(a1,d2),a2				; copy it, add line length and add room for
  923/     618 :                        								; pointer and line number
  924/     618 :                        
  925/     618 : 274A 0432              	MOVE.l	a2,Sfncl(a3)			; start of functions
  926/     61C : 274A 0436              	MOVE.l	a2,Svarl(a3)			; save start of variables
  927/     620 : 274A 043A              	MOVE.l	a2,Sstrl(a3)			; start of strings
  928/     624 : 274A 043E              	MOVE.l	a2,Sarryl(a3)			; save start of arrays
  929/     628 : 274A 0442              	MOVE.l	a2,Earryl(a3)			; save end of arrays
  930/     62C : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; copy end of mem to start of strings, clear
  931/     632 :                        								; strings
  932/     632 :                        
  933/     632 : 2209                   	MOVE.l	a1,d1					; copy end of block to move
  934/     634 : 9288                   	SUB.l		a0,d1					; subtract start of block to move
  935/     636 : E289                   	LSR.l		#1,d1					; /2 (word copy)
  936/     638 : 5381                   	SUBQ.l	#1,d1					; correct for loop end on -1
  937/     63A : 4841                   	SWAP		d1					; swap high word to low word
  938/     63C :                        LAB_12FF
  939/     63C : 4841                   	SWAP		d1					; swap high word to low word
  940/     63E :                        LAB_1301
  941/     63E : 3521                   	MOVE.w	-(a1),-(a2)				; decrement pointers and copy word
  942/     640 : 51C9 FFFC              	DBF		d1,LAB_1301				; decrement & loop
  943/     644 :                        
  944/     644 : 4841                   	SWAP		d1					; swap high word to low word
  945/     646 : 51C9 FFF4              	DBF		d1,LAB_12FF				; decrement high count and loop until done
  946/     64A :                        
  947/     64A :                        ; space is opened up, now copy the crunched line from the input buffer into the space
  948/     64A :                        
  949/     64A : 43EB 0490              	LEA		Ibuffs(a3),a1			; source is input buffer
  950/     64E : 2448                   	MOVEA.l	a0,a2					; copy destination
  951/     650 : 72FF                   	MOVEQ		#-1,d1				; set to allow re-chaining
  952/     652 : 24C1                   	MOVE.l	d1,(a2)+				; set next line pointer (allow re-chaining)
  953/     654 : 24EB 042A              	MOVE.l	Itemp(a3),(a2)+			; save line number
  954/     658 : E24A                   	LSR.w		#1,d2					; /2 (word copy)
  955/     65A : 5342                   	SUBQ.w	#1,d2					; correct for loop end on -1
  956/     65C :                        LAB_1303
  957/     65C : 34D9                   	MOVE.w	(a1)+,(a2)+				; copy word
  958/     65E : 51CA FFFC              	DBF		d2,LAB_1303				; decrement & loop
  959/     662 :                        
  960/     662 : 6010                   	BRA.s		LAB_1325				; go test for end of prog
  961/     664 :                        
  962/     664 :                        ; rebuild chaining of BASIC lines
  963/     664 :                        
  964/     664 :                        LAB_132E
  965/     664 : 5048                   	ADDQ.w	#8,a0					; point to first code byte of line, there is
  966/     666 :                        								; always 1 byte + [EOL] as null entries are
  967/     666 :                        								; deleted
  968/     666 :                        LAB_1330
  969/     666 : 4A18                   	TST.b		(a0)+					; test byte	
  970/     668 : 66FC                   	BNE.s		LAB_1330				; loop if not [EOL]
  971/     66A :                        
  972/     66A :                        								; was [EOL] so get next line start
  973/     66A : 3208                   	MOVE.w	a0,d1					; past pad byte(s)
  974/     66C : 0241 0001              	ANDI.w	#1,d1					; mask odd bit
  975/     670 : D0C1                   	ADD.w		d1,a0					; add back to ensure even
  976/     672 : 2288                   	MOVE.l	a0,(a1)				; save next line pointer to current line
  977/     674 :                        LAB_1325
  978/     674 : 2248                   	MOVEA.l	a0,a1					; copy pointer for this line
  979/     676 : 4A90                   	TST.l		(a0)					; test pointer to next line
  980/     678 : 66EA                   	BNE.s		LAB_132E				; not end of program yet so we must
  981/     67A :                        								; go and fix the pointers
  982/     67A :                        
  983/     67A : 6100 0198              	BSR		LAB_1477				; reset execution to start, clear variables
  984/     67E :                        								; and flush stack
  985/     67E : 6000 FF24              	BRA		LAB_127D				; now we just wait for Basic command, no "Ready"
  986/     682 :                        
  987/     682 :                        
  988/     682 :                        ;************************************************************************************
  989/     682 :                        ;
  990/     682 :                        ; receive a line from the keyboard
  991/     682 :                        								; character $08 as delete key, BACKSPACE on
  992/     682 :                        								; standard keyboard
  993/     682 :                        LAB_134B
  994/     682 : 6100 077E              	BSR		LAB_PRNA				; go print the character
  995/     686 : 7020                   	MOVEQ		#' ',d0				; load [SPACE]
  996/     688 : 6100 0778              	BSR		LAB_PRNA				; go print
  997/     68C : 7008                   	MOVEQ		#$08,d0				; load [BACKSPACE]
  998/     68E : 6100 0772              	BSR		LAB_PRNA				; go print
  999/     692 : 5341                   	SUBQ.w	#$01,d1				; decrement the buffer index (delete)
 1000/     694 : 6010                   	BRA.s		LAB_1359				; re-enter loop
 1001/     696 :                        
 1002/     696 :                        ; print "? " and get BASIC input
 1003/     696 :                        ; return a0 pointing to the buffer start
 1004/     696 :                        
 1005/     696 :                        LAB_INLN
 1006/     696 : 6100 0768              	BSR		LAB_18E3				; print "?" character
 1007/     69A : 7020                   	MOVEQ		#' ',d0				; load " "
 1008/     69C : 6100 0764              	BSR		LAB_PRNA				; go print
 1009/     6A0 :                        
 1010/     6A0 :                        ; call for BASIC input (main entry point)
 1011/     6A0 :                        ; return a0 pointing to the buffer start
 1012/     6A0 :                        
 1013/     6A0 :                        LAB_1357
 1014/     6A0 : 7200                   	MOVEQ		#$00,d1				; clear buffer index
 1015/     6A2 : 41EB 0490              	LEA		Ibuffs(a3),a0			; set buffer base pointer
 1016/     6A6 :                        LAB_1359
 1017/     6A6 : 4EAB 040C              	JSR		V_INPT(a3)				; call scan input device
 1018/     6AA : 64FA                   	BCC.s		LAB_1359				; loop if no byte
 1019/     6AC :                        
 1020/     6AC : 67F8                   	BEQ.s		LAB_1359				; loop if null byte
 1021/     6AE :                        
 1022/     6AE : B03C 0007              	CMP.b		#$07,d0				; compare with [BELL]
 1023/     6B2 : 6718                   	BEQ.s		LAB_1378				; branch if [BELL]
 1024/     6B4 :                        
 1025/     6B4 : B03C 000D              	CMP.b		#$0D,d0				; compare with [CR]
 1026/     6B8 : 6700 06CA              	BEQ		LAB_1866				; do CR/LF exit if [CR]
 1027/     6BC :                        
 1028/     6BC : 4A41                   	TST.w		d1					; set flags on buffer index
 1029/     6BE : 6606                   	BNE.s		LAB_1374				; branch if not empty
 1030/     6C0 :                        
 1031/     6C0 :                        ; the next two lines ignore any non printing character and [SPACE] if the input buffer
 1032/     6C0 :                        ; is empty
 1033/     6C0 :                        
 1034/     6C0 : B03C 0020              	CMP.b		#' ',d0				; compare with [SP]+1
 1035/     6C4 : 63E0                   	BLS.s		LAB_1359				; if < ignore character
 1036/     6C6 :                        
 1037/     6C6 :                        ;##	CMP.b		#' '+1,d0				; compare with [SP]+1
 1038/     6C6 :                        ;##	BCS.s		LAB_1359				; if < ignore character
 1039/     6C6 :                        
 1040/     6C6 :                        LAB_1374
 1041/     6C6 : B03C 0008              	CMP.b		#$08,d0				; compare with [BACKSPACE]
 1042/     6CA : 67B6                   	BEQ.s		LAB_134B				; go delete last character
 1043/     6CC :                        
 1044/     6CC :                        LAB_1378
 1045/     6CC : B27C 00FF              	CMP.w		#(Ibuffe-Ibuffs-1),d1		; compare character count with max-1
 1046/     6D0 : 640C                   	BCC.s		LAB_138E				; skip store & do [BELL] if buffer full
 1047/     6D2 :                        
 1048/     6D2 : 1180 1000              	MOVE.b	d0,(a0,d1.w)			; else store in buffer
 1049/     6D6 : 5241                   	ADDQ.w	#$01,d1				; increment index
 1050/     6D8 :                        LAB_137F
 1051/     6D8 : 6100 0728              	BSR		LAB_PRNA				; go print the character
 1052/     6DC : 60C8                   	BRA.s		LAB_1359				; always loop for next character
 1053/     6DE :                        
 1054/     6DE :                        ; announce buffer full
 1055/     6DE :                        
 1056/     6DE :                        LAB_138E
 1057/     6DE : 7007                   	MOVEQ		#$07,d0				; [BELL] character into d0
 1058/     6E0 : 60F6                   	BRA.s		LAB_137F				; go print the [BELL] but ignore input character
 1059/     6E2 :                        
 1060/     6E2 :                        
 1061/     6E2 :                        ;************************************************************************************
 1062/     6E2 :                        ;
 1063/     6E2 :                        ; copy a hex value without crunching
 1064/     6E2 :                        
 1065/     6E2 :                        LAB_1392
 1066/     6E2 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save the byte to the output
 1067/     6E6 : 5242                   	ADDQ.w	#1,d2					; increment the buffer save index
 1068/     6E8 :                        
 1069/     6E8 : 5241                   	ADDQ.w	#1,d1					; increment the buffer read index
 1070/     6EA : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get a byte from the input buffer
 1071/     6EE : 6700 0094              	BEQ		LAB_13EC				; if [EOL] go save it without crunching
 1072/     6F2 :                        
 1073/     6F2 : B03C 0020              	CMP.b		#' ',d0				; compare the character with " "
 1074/     6F6 : 67EA                   	BEQ.s		LAB_1392				; if [SPACE] just go save it and get another
 1075/     6F8 :                        
 1076/     6F8 : B03C 0030              	CMP.b		#'0',d0				; compare the character with "0"
 1077/     6FC : 654A                   	BCS.s		LAB_13C6				; if < "0" quit the hex save loop
 1078/     6FE :                        
 1079/     6FE : B03C 0039              	CMP.b		#'9',d0				; compare with "9"
 1080/     702 : 63DE                   	BLS.s		LAB_1392				; if it is "0" to "9" save it and get another
 1081/     704 :                        
 1082/     704 : 7ADF                   	MOVEQ		#-33,d5				; mask xx0x xxxx, ASCII upper case
 1083/     706 : CA00                   	AND.b		d0,d5					; mask the character
 1084/     708 :                        
 1085/     708 : BA3C 0041              	CMP.b		#'A',d5				; compare with "A"
 1086/     70C : 6540                   	BCS.s		LAB_13CC				; if < "A" quit the hex save loop
 1087/     70E :                        
 1088/     70E : BA3C 0046              	CMP.b		#'F',d5				; compare with "F"
 1089/     712 : 63CE                   	BLS.s		LAB_1392				; if it is "A" to "F" save it and get another
 1090/     714 :                        
 1091/     714 : 6038                   	BRA.s		LAB_13CC				; else continue crunching
 1092/     716 :                        
 1093/     716 :                        ; crunch keywords into Basic tokens
 1094/     716 :                        ; crunch from (a5), output to (a0)
 1095/     716 :                        ; returns ..
 1096/     716 :                        ; d4 trashed
 1097/     716 :                        ; d3 trashed
 1098/     716 :                        ; d2 is length
 1099/     716 :                        ; d1 trashed
 1100/     716 :                        ; d0 trashed
 1101/     716 :                        ; a1 trashed
 1102/     716 :                        
 1103/     716 :                        ; this is the improved BASIC crunch routine and is 10 to 100 times faster than the
 1104/     716 :                        ; old list search
 1105/     716 :                        
 1106/     716 :                        LAB_13A6
 1107/     716 : 7200                   	MOVEQ		#0,d1					; clear the read index
 1108/     718 : 2401                   	MOVE.l	d1,d2					; clear the save index
 1109/     71A : 1741 05DD              	MOVE.b	d1,Oquote(a3)			; clear the open quote/DATA flag
 1110/     71E :                        LAB_13AC
 1111/     71E : 7000                   	MOVEQ		#0,d0					; clear word
 1112/     720 : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
 1113/     724 : 675E                   	BEQ.s		LAB_13EC				; if null save byte then continue crunching
 1114/     726 :                        
 1115/     726 : B03C 005F              	CMP.b		#'_',d0				; compare with "_"
 1116/     72A : 6458                   	BCC.s		LAB_13EC				; if >= "_" save byte then continue crunching
 1117/     72C :                        
 1118/     72C : B03C 003C              	CMP.b		#'<',d0				; compare with "<"
 1119/     730 : 641C                   	BCC.s		LAB_13CC				; if >= "<" go crunch
 1120/     732 :                        
 1121/     732 : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 1122/     736 : 644C                   	BCC.s		LAB_13EC				; if >= "0" save byte then continue crunching
 1123/     738 :                        
 1124/     738 : 1740 05DA              	MOVE.b	d0,Asrch(a3)			; save buffer byte as search character
 1125/     73C : B03C 0022              	CMP.b		#$22,d0				; is it quote character?
 1126/     740 : 6776                   	BEQ.s		LAB_1410				; branch if so (copy quoted string)
 1127/     742 :                        
 1128/     742 : B03C 0024              	CMP.b		#'$',d0				; is it the hex value character?
 1129/     746 : 679A                   	BEQ.s		LAB_1392				; if so go copy a hex value
 1130/     748 :                        
 1131/     748 :                        LAB_13C6
 1132/     748 : B03C 002A              	CMP.b		#'*',d0				; compare with "*"
 1133/     74C : 6536                   	BCS.s		LAB_13EC				; if <= "*" save byte then continue crunching
 1134/     74E :                        
 1135/     74E :                        								; crunch rest
 1136/     74E :                        LAB_13CC
 1137/     74E : 082B 0006 05DD         	BTST.b	#6,Oquote(a3)			; test open quote/DATA token flag
 1138/     754 : 662E                   	BNE.s		LAB_13EC				; branch if b6 of Oquote set (was DATA)
 1139/     756 :                        								; go save byte then continue crunching
 1140/     756 :                        
 1141/     756 : 903C 002A              	SUB.b		#$2A,d0				; normalise byte
 1142/     75A : D040                   	ADD.w		d0,d0					; *2 makes word offset (high byte=$00)
 1143/     75C : 43FA 2C1A              	LEA		TAB_CHRT(pc),a1			; get keyword offset table address
 1144/     760 : 3031 0000              	MOVE.w	(a1,d0.w),d0			; get offset into keyword table
 1145/     764 : 6B6E                   	BMI.s		LAB_141F				; branch if no keywords for character
 1146/     766 :                        
 1147/     766 : 43FA 2FA6              	LEA		TAB_STAR(pc),a1			; get keyword table address
 1148/     76A : D2C0                   	ADDA.w	d0,a1					; add keyword offset
 1149/     76C : 76FF                   	MOVEQ		#-1,d3				; clear index
 1150/     76E : 3801                   	MOVE.w	d1,d4					; copy read index
 1151/     770 :                        LAB_13D6
 1152/     770 : 5243                   	ADDQ.w	#1,d3					; increment table index
 1153/     772 : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get byte from table
 1154/     776 :                        LAB_13D8
 1155/     776 : 6B0A                   	BMI.s		LAB_13EA				; branch if token, save token and continue
 1156/     778 :                        								; crunching
 1157/     778 :                        
 1158/     778 : 5244                   	ADDQ.w	#1,d4					; increment read index
 1159/     77A : B035 4000              	CMP.b		(a5,d4.w),d0			; compare byte from input buffer
 1160/     77E : 67F0                   	BEQ.s		LAB_13D6				; loop if character match
 1161/     780 :                        
 1162/     780 : 6040                   	BRA.s		LAB_1417				; branch if no match
 1163/     782 :                        
 1164/     782 :                        LAB_13EA
 1165/     782 : 3204                   	MOVE.w	d4,d1					; update read index
 1166/     784 :                        LAB_13EC
 1167/     784 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save byte to output
 1168/     788 : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
 1169/     78A : 5241                   	ADDQ.w	#1,d1					; increment buffer read index
 1170/     78C : 4A00                   	TST.b		d0					; set flags
 1171/     78E : 674A                   	BEQ.s		LAB_142A				; branch if was null [EOL]
 1172/     790 :                        
 1173/     790 :                        								; d0 holds token or byte here
 1174/     790 : 903C 003A              	SUB.b		#$3A,d0				; subtract ":"
 1175/     794 : 6706                   	BEQ.s		LAB_13FF				; branch if it was ":" (is now $00)
 1176/     796 :                        
 1177/     796 :                        								; d0 now holds token-$3A
 1178/     796 : B03C 0049              	CMP.b		#(TK_DATA-$3A),d0			; compare with DATA token - $3A
 1179/     79A : 6604                   	BNE.s		LAB_1401				; branch if not DATA
 1180/     79C :                        
 1181/     79C :                        								; token was : or DATA
 1182/     79C :                        LAB_13FF
 1183/     79C : 1740 05DD              	MOVE.b	d0,Oquote(a3)			; save token-$3A ($00 for ":", TK_DATA-$3A for
 1184/     7A0 :                        								; DATA)
 1185/     7A0 :                        LAB_1401
 1186/     7A0 : 903C 0055              	SUB.b		#(TK_REM-$3A),d0			; subtract REM token offset
 1187/     7A4 : 6600 FF78              	BNE		LAB_13AC				; If wasn't REM then go crunch rest of line
 1188/     7A8 :                        
 1189/     7A8 : 1740 05DA              	MOVE.b	d0,Asrch(a3)			; else was REM so set search for [EOL]
 1190/     7AC :                        
 1191/     7AC :                        								; loop for REM, "..." etc.
 1192/     7AC :                        LAB_1408
 1193/     7AC : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
 1194/     7B0 : 67D2                   	BEQ.s		LAB_13EC				; branch if null [EOL]
 1195/     7B2 :                        
 1196/     7B2 : B02B 05DA              	CMP.b		Asrch(a3),d0			; compare with stored character
 1197/     7B6 : 67CC                   	BEQ.s		LAB_13EC				; branch if match (end quote, REM, :, or DATA)
 1198/     7B8 :                        
 1199/     7B8 :                        								; entry for copy string in quotes, don't crunch
 1200/     7B8 :                        LAB_1410
 1201/     7B8 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save byte to output
 1202/     7BC : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
 1203/     7BE : 5241                   	ADDQ.w	#1,d1					; increment buffer read index
 1204/     7C0 : 60EA                   	BRA.s		LAB_1408				; loop
 1205/     7C2 :                        
 1206/     7C2 :                        ; not found keyword this go so find the end of this word in the table
 1207/     7C2 :                        
 1208/     7C2 :                        LAB_1417
 1209/     7C2 : 3801                   	MOVE.w	d1,d4					; reset read pointer
 1210/     7C4 :                        LAB_141B
 1211/     7C4 : 5243                   	ADDQ.w	#1,d3					; increment keyword table pointer, flag
 1212/     7C6 :                        								; unchanged
 1213/     7C6 : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get keyword table byte
 1214/     7CA : 6AF8                   	BPL.s		LAB_141B				; if not end of keyword go do next byte
 1215/     7CC :                        
 1216/     7CC : 5243                   	ADDQ.w	#1,d3					; increment keyword table pointer flag
 1217/     7CE :                        								; unchanged
 1218/     7CE : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get keyword table byte
 1219/     7D2 : 66A2                   	BNE.s		LAB_13D8				; go test next word if not zero byte (table end)
 1220/     7D4 :                        
 1221/     7D4 :                        								; reached end of table with no match
 1222/     7D4 :                        LAB_141F
 1223/     7D4 : 1035 1000              	MOVE.b	(a5,d1.w),d0			; restore byte from input buffer
 1224/     7D8 : 60AA                   	BRA.s		LAB_13EC				; go save byte in output and continue crunching
 1225/     7DA :                        
 1226/     7DA :                        								; reached [EOL]
 1227/     7DA :                        LAB_142A
 1228/     7DA : 7000                   	MOVEQ		#0,d0					; ensure longword clear
 1229/     7DC : 0102                   	BTST		d0,d2					; test odd bit (fastest)
 1230/     7DE : 6706                   	BEQ.s		LAB_142C				; branch if no bytes to fill
 1231/     7E0 :                        
 1232/     7E0 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; clear next byte
 1233/     7E4 : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
 1234/     7E6 :                        LAB_142C
 1235/     7E6 : 2180 2000              	MOVE.l	d0,(a0,d2.w)			; clear next line pointer, EOT in immediate mode
 1236/     7EA : 4E75                   	RTS
 1237/     7EC :                        
 1238/     7EC :                        
 1239/     7EC :                        ;************************************************************************************
 1240/     7EC :                        ;
 1241/     7EC :                        ; search Basic for d1 line number from start of mem
 1242/     7EC :                        
 1243/     7EC :                        LAB_SSLN
 1244/     7EC : 206B 042E              	MOVEA.l	Smeml(a3),a0			; get start of program mem
 1245/     7F0 : 6002                   	BRA.s		LAB_SCLN				; go search for required line from a0
 1246/     7F2 :                        
 1247/     7F2 :                        LAB_145F
 1248/     7F2 : 2040                   	MOVEA.l	d0,a0					; copy next line pointer
 1249/     7F4 :                        
 1250/     7F4 :                        ; search Basic for d1 line number from a0
 1251/     7F4 :                        ; returns Cb=0 if found
 1252/     7F4 :                        ; returns a0 pointer to found or next higher (not found) line
 1253/     7F4 :                        
 1254/     7F4 :                        LAB_SCLN
 1255/     7F4 : 2018                   	MOVE.l	(a0)+,d0				; get next line pointer and point to line #
 1256/     7F6 : 6708                   	BEQ.s		LAB_145E				; is end marker so we're done, do 'no line' exit
 1257/     7F8 :                        
 1258/     7F8 : B290                   	CMP.l		(a0),d1				; compare this line # with required line #
 1259/     7FA : 6EF6                   	BGT.s		LAB_145F				; loop if required # > this #
 1260/     7FC :                        
 1261/     7FC : 5948                   	SUBQ.w	#4,a0					; adjust pointer, flags not changed
 1262/     7FE : 4E75                   	RTS
 1263/     800 :                        
 1264/     800 :                        LAB_145E
 1265/     800 : 5948                   	SUBQ.w	#4,a0					; adjust pointer, flags not changed
 1266/     802 : 5380                   	SUBQ.l	#1,d0					; make end program found = -1, set carry
 1267/     804 : 4E75                   	RTS
 1268/     806 :                        
 1269/     806 :                        
 1270/     806 :                        ;************************************************************************************
 1271/     806 :                        ;
 1272/     806 :                        ; perform NEW
 1273/     806 :                        
 1274/     806 :                        LAB_NEW
 1275/     806 : 664E                   	BNE.s		RTS_005				; exit if not end of statement (do syntax error)
 1276/     808 :                        
 1277/     808 :                        LAB_1463
 1278/     808 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; point to start of program memory
 1279/     80C : 7000                   	MOVEQ		#0,d0					; clear longword
 1280/     80E : 20C0                   	MOVE.l	d0,(a0)+				; clear first line, next line pointer
 1281/     810 : 2748 0432              	MOVE.l	a0,Sfncl(a3)			; set start of functions
 1282/     814 :                        
 1283/     814 :                        ; reset execution to start, clear variables and flush stack
 1284/     814 :                        
 1285/     814 :                        LAB_1477
 1286/     814 : 2A6B 042E              	MOVEA.l	Smeml(a3),a5			; reset BASIC execute pointer
 1287/     818 : 534D                   	SUBQ.w	#1,a5					; -1 (as end of previous line)
 1288/     81A :                        
 1289/     81A :                        ; "CLEAR" command gets here
 1290/     81A :                        
 1291/     81A :                        LAB_147A
 1292/     81A : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; save end of mem as bottom of string space
 1293/     820 : 202B 0432              	MOVE.l	Sfncl(a3),d0			; get start of functions
 1294/     824 : 2740 0436              	MOVE.l	d0,Svarl(a3)			; start of variables
 1295/     828 : 2740 043A              	MOVE.l	d0,Sstrl(a3)			; start of strings
 1296/     82C : 2740 043E              	MOVE.l	d0,Sarryl(a3)			; set start of arrays
 1297/     830 : 2740 0442              	MOVE.l	d0,Earryl(a3)			; set end of arrays
 1298/     834 :                        LAB_1480
 1299/     834 : 7000                   	MOVEQ		#0,d0					; set Zb
 1300/     836 : 1740 05EA              	MOVE.b	d0,ccnull(a3)			; clear get byte countdown
 1301/     83A : 6100 01D0              	BSR		LAB_RESTORE				; perform RESTORE command
 1302/     83E :                        
 1303/     83E :                        ; flush stack & clear continue flag
 1304/     83E :                        
 1305/     83E :                        LAB_1491
 1306/     83E : 49EB 048E              	LEA		des_sk(a3),a4			; reset descriptor stack pointer
 1307/     842 :                        
 1308/     842 : 201F                   	MOVE.l	(sp)+,d0				; pull return address
 1309/     844 : 2E7C 0000 3E00         	MOVE.l	#ram_strt+ram_base,sp			; set stack to RAM start + 1k, flush stack
 1310/     84A : 2F00                   	MOVE.l	d0,-(sp)				; restore return address
 1311/     84C :                        
 1312/     84C : 7000                   	MOVEQ		#0,d0					; clear longword
 1313/     84E : 2740 045A              	MOVE.l	d0,Cpntrl(a3)			; clear continue pointer
 1314/     852 : 1740 05DF              	MOVE.b	d0,Sufnxf(a3)			; clear subscript/FNX flag
 1315/     856 :                        RTS_005
 1316/     856 : 4E75                   	RTS
 1317/     858 :                        
 1318/     858 :                        
 1319/     858 :                        ;************************************************************************************
 1320/     858 :                        ;
 1321/     858 :                        ; perform CLEAR
 1322/     858 :                        
 1323/     858 :                        LAB_CLEAR
 1324/     858 : 67C0                   	BEQ.s		LAB_147A				; if no following byte go do "CLEAR"
 1325/     85A :                        
 1326/     85A : 4E75                   	RTS							; was following byte (go do syntax error)
 1327/     85C :                        
 1328/     85C :                        
 1329/     85C :                        ;************************************************************************************
 1330/     85C :                        ;
 1331/     85C :                        ; perform LIST [n][-m]
 1332/     85C :                        
 1333/     85C :                        LAB_LIST
 1334/     85C : 6512                   	BCS.s		LAB_14BD				; branch if next character numeric (LIST n...)
 1335/     85E :                        
 1336/     85E : 72FF                   	MOVEQ		#-1,d1				; set end to $FFFFFFFF
 1337/     860 : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save to Itemp
 1338/     864 :                        
 1339/     864 : 7200                   	MOVEQ		#0,d1					; set start to $00000000
 1340/     866 : 4A00                   	TST.b		d0					; test next byte
 1341/     868 : 670A                   	BEQ.s		LAB_14C0				; branch if next character [NULL] (LIST)
 1342/     86A :                        
 1343/     86A : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 1344/     86E : 66E6                   	BNE.s		RTS_005				; exit if not - (LIST -m)
 1345/     870 :                        
 1346/     870 :                        								; LIST [[n]-[m]] this sets the n, if present,
 1347/     870 :                        								; as the start and end
 1348/     870 :                        LAB_14BD
 1349/     870 : 6100 0396              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1350/     874 :                        LAB_14C0
 1351/     874 : 6100 FF76              	BSR		LAB_SSLN				; search BASIC for d1 line number
 1352/     878 :                        								; (pointer in a0)
 1353/     878 : 6100 093A              	BSR		LAB_GBYT				; scan memory
 1354/     87C : 6716                   	BEQ.s		LAB_14D4				; branch if no more characters
 1355/     87E :                        
 1356/     87E :                        								; this bit checks the - is present
 1357/     87E : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 1358/     882 : 66D2                   	BNE.s		RTS_005				; return if not "-" (will be Syntax error)
 1359/     884 :                        
 1360/     884 : 72FF                   	MOVEQ		#-1,d1				; set end to $FFFFFFFF
 1361/     886 : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save Itemp
 1362/     88A :                        
 1363/     88A :                        								; LIST [n]-[m] the - was there so see if
 1364/     88A :                        								; there is an m to set as the end value
 1365/     88A : 6100 0926              	BSR		LAB_IGBY				; increment & scan memory
 1366/     88E : 6704                   	BEQ.s		LAB_14D4				; branch if was [NULL] (LIST n-)
 1367/     890 :                        
 1368/     890 : 6100 0376              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1369/     894 :                        LAB_14D4
 1370/     894 : 177C 0000 05DD         	MOVE.b	#$00,Oquote(a3)			; clear open quote flag
 1371/     89A : 6100 04EE              	BSR		LAB_CRLF				; print CR/LF
 1372/     89E : 2018                   	MOVE.l	(a0)+,d0				; get next line pointer
 1373/     8A0 : 67B4                   	BEQ.s		RTS_005				; if null all done so exit
 1374/     8A2 :                        
 1375/     8A2 : 2240                   	MOVEA.l	d0,a1					; copy next line pointer
 1376/     8A4 : 6100 012C              	BSR		LAB_1629				; do CRTL-C check vector
 1377/     8A8 :                        
 1378/     8A8 : 2018                   	MOVE.l	(a0)+,d0				; get this line #
 1379/     8AA : B0AB 042A              	CMP.l		Itemp(a3),d0			; compare end line # with this line #
 1380/     8AE : 62A6                   	BHI.s		RTS_005				; if this line greater all done so exit
 1381/     8B0 :                        
 1382/     8B0 :                        LAB_14E2
 1383/     8B0 : 48E7 00C0              	MOVEM.l	a0-a1,-(sp)				; save registers
 1384/     8B4 : 6100 181C              	BSR		LAB_295E				; print d0 as unsigned integer
 1385/     8B8 : 4CDF 0300              	MOVEM.l	(sp)+,a0-a1				; restore registers
 1386/     8BC : 7020                   	MOVEQ		#$20,d0				; space is the next character
 1387/     8BE :                        LAB_150C
 1388/     8BE : 6100 0542              	BSR		LAB_PRNA				; go print the character
 1389/     8C2 : B03C 0022              	CMP.b		#$22,d0				; was it " character
 1390/     8C6 : 6606                   	BNE.s		LAB_1519				; branch if not
 1391/     8C8 :                        
 1392/     8C8 :                        								; we're either entering or leaving quotes
 1393/     8C8 : 0A2B 00FF 05DD         	EOR.b		#$FF,Oquote(a3)			; toggle open quote flag
 1394/     8CE :                        LAB_1519
 1395/     8CE : 1018                   	MOVE.b	(a0)+,d0				; get byte and increment pointer
 1396/     8D0 : 6608                   	BNE.s		LAB_152E				; branch if not [EOL] (go print)
 1397/     8D2 :                        
 1398/     8D2 :                        								; was [EOL]
 1399/     8D2 : 2049                   	MOVEA.l	a1,a0					; copy next line pointer
 1400/     8D4 : 2008                   	MOVE.l	a0,d0					; copy to set flags
 1401/     8D6 : 66BC                   	BNE.s		LAB_14D4				; go do next line if not [EOT]
 1402/     8D8 :                        
 1403/     8D8 : 4E75                   	RTS
 1404/     8DA :                        
 1405/     8DA :                        LAB_152E
 1406/     8DA : 6AE2                   	BPL.s		LAB_150C				; just go print it if not token byte
 1407/     8DC :                        
 1408/     8DC :                        								; else it was a token byte so maybe uncrunch it
 1409/     8DC : 4A2B 05DD              	TST.b		Oquote(a3)				; test the open quote flag
 1410/     8E0 : 6BDC                   	BMI.s		LAB_150C				; just go print character if open quote set
 1411/     8E2 :                        
 1412/     8E2 :                        								; else uncrunch BASIC token
 1413/     8E2 : 45FA 2AFE              	LEA		LAB_KEYT(pc),a2			; get keyword table address
 1414/     8E6 : 727F                   	MOVEQ		#$7F,d1				; mask into d1
 1415/     8E8 : C200                   	AND.b		d0,d1					; copy and mask token
 1416/     8EA : E549                   	LSL.w		#2,d1					; *4
 1417/     8EC : 45F2 1000              	LEA		(a2,d1.w),a2			; get keyword entry address
 1418/     8F0 : 101A                   	MOVE.b	(a2)+,d0				; get byte from keyword table
 1419/     8F2 : 6100 050E              	BSR		LAB_PRNA				; go print the first character
 1420/     8F6 : 7200                   	MOVEQ		#0,d1					; clear d1
 1421/     8F8 : 121A                   	MOVE.b	(a2)+,d1				; get remaining length byte from keyword table
 1422/     8FA : 6BD2                   	BMI.s		LAB_1519				; if -ve done so go get next byte
 1423/     8FC :                        
 1424/     8FC : 3012                   	MOVE.w	(a2),d0				; get offset to rest
 1425/     8FE : 45FA 2E0E              	LEA		TAB_STAR(pc),a2			; get keyword table address
 1426/     902 : 45F2 0000              	LEA		(a2,d0.w),a2			; get address of rest
 1427/     906 :                        LAB_1540
 1428/     906 : 101A                   	MOVE.b	(a2)+,d0				; get byte from keyword table
 1429/     908 : 6100 04F8              	BSR		LAB_PRNA				; go print the character
 1430/     90C : 51C9 FFF8              	DBF		d1,LAB_1540				; decrement and loop if more to do
 1431/     910 :                        
 1432/     910 : 60BC                   	BRA.s		LAB_1519				; go get next byte
 1433/     912 :                        
 1434/     912 :                        
 1435/     912 :                        ;************************************************************************************
 1436/     912 :                        ;
 1437/     912 :                        ; perform FOR
 1438/     912 :                        
 1439/     912 :                        LAB_FOR
 1440/     912 : 6100 0396              	BSR		LAB_LET				; go do LET
 1441/     916 :                        
 1442/     916 : 202B 0472              	MOVE.l	Lvarpl(a3),d0			; get the loop variable pointer
 1443/     91A : B0AB 043A              	CMP.l		Sstrl(a3),d0			; compare it with the end of vars memory
 1444/     91E : 6C00 FC20              	BGE		LAB_TMER				; if greater go do type mismatch error
 1445/     922 :                        
 1446/     922 :                        ; test for not less than the start of variables memory if needed
 1447/     922 :                        ;
 1448/     922 :                        ;	CMP.l		Svarl(a3),d0			; compare it with the start of variables memory
 1449/     922 :                        ;	BLT		LAB_TMER				; if not variables memory do type mismatch error
 1450/     922 :                        
 1451/     922 :                        ;	MOVEQ		#28,d0				; we need 28 bytes !
 1452/     922 :                        ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
 1453/     922 :                        
 1454/     922 : 6100 0214              	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 1455/     926 :                        								; returns a0 as pointer to [:] or [EOL]
 1456/     926 : 2E88                   	MOVE.l	a0,(sp)				; push onto stack (and dump the return address)
 1457/     928 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line onto stack
 1458/     92C :                        
 1459/     92C : 70AA                   	MOVEQ		#TK_TO-$100,d0			; set "TO" token
 1460/     92E : 6100 087A              	BSR		LAB_SCCA				; scan for CHR$(d0) else syntax error/warm start
 1461/     932 : 6100 0708              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 1462/     936 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push the FOR variable data type onto stack
 1463/     93A : 6100 06FE              	BSR		LAB_EVNM				; evaluate expression and check is numeric else
 1464/     93E :                        								; do type mismatch
 1465/     93E :                        
 1466/     93E : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push TO value mantissa
 1467/     942 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push TO value exponent and sign
 1468/     946 :                        
 1469/     946 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; set default STEP size mantissa
 1470/     94E : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; set default STEP size exponent and sign
 1471/     954 :                        
 1472/     954 : 6100 085E              	BSR		LAB_GBYT				; scan memory
 1473/     958 : B03C 00AF              	CMP.b		#TK_STEP,d0				; compare with STEP token
 1474/     95C : 6608                   	BNE.s		LAB_15B3				; jump if not "STEP"
 1475/     95E :                        
 1476/     95E :                        								; was STEP token so ....
 1477/     95E : 6100 0852              	BSR		LAB_IGBY				; increment & scan memory
 1478/     962 : 6100 06D6              	BSR		LAB_EVNM				; evaluate expression & check is numeric
 1479/     966 :                        								; else do type mismatch
 1480/     966 :                        LAB_15B3
 1481/     966 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push STEP value mantissa
 1482/     96A : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push STEP value exponent and sign
 1483/     96E :                        
 1484/     96E : 2F2B 0472              	MOVE.l	Lvarpl(a3),-(sp)			; push variable pointer for FOR/NEXT
 1485/     972 : 3F3C 0081              	MOVE.w	#TK_FOR,-(sp)			; push FOR token on stack
 1486/     976 :                        
 1487/     976 : 6018                   	BRA.s		LAB_15C2				; go do interpreter inner loop
 1488/     978 :                        
 1489/     978 :                        LAB_15DC							; have reached [EOL]+1
 1490/     978 : 300D                   	MOVE.w	a5,d0					; copy BASIC execute pointer
 1491/     97A : C07C 0001              	AND.w		#1,d0					; and make line start address even
 1492/     97E : DAC0                   	ADD.w		d0,a5					; add to BASIC execute pointer
 1493/     980 : 201D                   	MOVE.l	(a5)+,d0				; get next line pointer
 1494/     982 : 6700 FC18              	BEQ		LAB_1274				; if null go to immediate mode, no "BREAK"
 1495/     986 :                        								; message (was immediate or [EOT] marker)
 1496/     986 :                        
 1497/     986 : 275D 0452              	MOVE.l	(a5)+,Clinel(a3)			; save (new) current line #
 1498/     98A :                        LAB_15F6
 1499/     98A : 6100 0828              	BSR		LAB_GBYT				; get BASIC byte
 1500/     98E : 611A                   	BSR.s		LAB_15FF				; go interpret BASIC code from (a5)
 1501/     990 :                        
 1502/     990 :                        ; interpreter inner loop (re)entry point
 1503/     990 :                        
 1504/     990 :                        LAB_15C2
 1505/     990 : 6140                   	BSR.s		LAB_1629				; do CRTL-C check vector
 1506/     992 : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
 1507/     996 : 6B04                   	BMI.s		LAB_15D1				; branch if immediate mode
 1508/     998 :                        
 1509/     998 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
 1510/     99C :                        LAB_15D1
 1511/     99C : 101D                   	MOVE.b	(a5)+,d0				; get this byte & increment pointer
 1512/     99E : 67D8                   	BEQ.s		LAB_15DC				; loop if [EOL]
 1513/     9A0 :                        
 1514/     9A0 : B03C 003A              	CMP.b		#$3A,d0				; compare with ":"
 1515/     9A4 : 67E4                   	BEQ.s		LAB_15F6				; loop if was statement separator
 1516/     9A6 :                        
 1517/     9A6 : 6000 FBC4              	BRA		LAB_SNER				; else syntax error, then warm start
 1518/     9AA :                        
 1519/     9AA :                        
 1520/     9AA :                        ;************************************************************************************
 1521/     9AA :                        ;
 1522/     9AA :                        ; interpret BASIC code from (a5)
 1523/     9AA :                        
 1524/     9AA :                        LAB_15FF
 1525/     9AA : 6700 008C              	BEQ		RTS_006				; exit if zero [EOL]
 1526/     9AE :                        
 1527/     9AE :                        LAB_1602
 1528/     9AE : 0A00 0080              	EORI.b	#$80,d0				; normalise token
 1529/     9B2 : 6B00 02F6              	BMI		LAB_LET				; if not token, go do implied LET
 1530/     9B6 :                        
 1531/     9B6 : B03C 0028              	CMP.b		#(TK_TAB-$80),d0			; compare normalised token with TAB
 1532/     9BA : 6400 FBB0              	BCC		LAB_SNER				; branch if d0>=TAB, syntax error/warm start
 1533/     9BE :                        								; only tokens before TAB can start a statement
 1534/     9BE :                        
 1535/     9BE : 4880                   	EXT.w		d0					; byte to word (clear high byte)
 1536/     9C0 : D040                   	ADD.w		d0,d0					; *2
 1537/     9C2 : 41FA 287C              	LEA		LAB_CTBL(pc),a0			; get vector table base address
 1538/     9C6 : 3030 0000              	MOVE.w	(a0,d0.w),d0			; get offset to vector
 1539/     9CA : 4870 0000              	PEA		(a0,d0.w)				; push vector
 1540/     9CE : 6000 07E2              	BRA		LAB_IGBY				; get following byte & execute vector
 1541/     9D2 :                        
 1542/     9D2 :                        
 1543/     9D2 :                        ;************************************************************************************
 1544/     9D2 :                        ;
 1545/     9D2 :                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
 1546/     9D2 :                        ; key press is detected.
 1547/     9D2 :                        
 1548/     9D2 :                        LAB_1629
 1549/     9D2 : 4EEB 0424              	JMP		V_CTLC(a3)				; ctrl c check vector
 1550/     9D6 :                        
 1551/     9D6 :                        ; if there was a key press it gets back here .....
 1552/     9D6 :                        
 1553/     9D6 :                        LAB_1636
 1554/     9D6 : B03C 0003              	CMP.b		#$03,d0				; compare with CTRL-C
 1555/     9DA : 670C                   	BEQ.s		LAB_163B				; STOP if was CTRL-C
 1556/     9DC :                        
 1557/     9DC :                        LAB_1639
 1558/     9DC : 4E75                   	RTS
 1559/     9DE :                        
 1560/     9DE :                        
 1561/     9DE :                        ;************************************************************************************
 1562/     9DE :                        ;
 1563/     9DE :                        ; perform END
 1564/     9DE :                        
 1565/     9DE :                        LAB_END
 1566/     9DE : 66FC                   	BNE.s		LAB_1639				; exit if something follows STOP
 1567/     9E0 : 177C 0000 05DC         	MOVE.b	#0,Breakf(a3)			; clear break flag, indicate program end
 1568/     9E6 :                        
 1569/     9E6 :                        
 1570/     9E6 :                        ;************************************************************************************
 1571/     9E6 :                        ;
 1572/     9E6 :                        ; perform STOP
 1573/     9E6 :                        
 1574/     9E6 :                        LAB_STOP
 1575/     9E6 : 66F4                   	BNE.s		LAB_1639				; exit if something follows STOP
 1576/     9E8 :                        
 1577/     9E8 :                        LAB_163B
 1578/     9E8 : 43EB 0590              	LEA		Ibuffe(a3),a1			; get buffer end
 1579/     9EC : BBC9                   	CMPA.l	a1,a5					; compare execute address with buffer end
 1580/     9EE : 650A                   	BCS.s		LAB_164F				; branch if BASIC pointer is in buffer
 1581/     9F0 :                        								; can't continue in immediate mode
 1582/     9F0 :                        
 1583/     9F0 :                        								; else...
 1584/     9F0 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
 1585/     9F4 :                        LAB_1647
 1586/     9F4 : 276B 0452 0456         	MOVE.l	Clinel(a3),Blinel(a3)		; save break line
 1587/     9FA :                        LAB_164F
 1588/     9FA : 584F                   	ADDQ.w	#4,sp					; dump return address, don't return to execute
 1589/     9FC :                        								; loop
 1590/     9FC : 102B 05DC              	MOVE.b	Breakf(a3),d0			; get break flag
 1591/     A00 : 6700 FB9A              	BEQ		LAB_1274				; go do warm start if was program end
 1592/     A04 :                        
 1593/     A04 : 41FA 2EB3              	LEA		LAB_BMSG(pc),a0			; point to "Break"
 1594/     A08 : 6000 FB84              	BRA		LAB_1269				; print "Break" and do warm start
 1595/     A0C :                        
 1596/     A0C :                        
 1597/     A0C :                        ;************************************************************************************
 1598/     A0C :                        ;
 1599/     A0C :                        ; perform RESTORE
 1600/     A0C :                        
 1601/     A0C :                        LAB_RESTORE
 1602/     A0C : 206B 042E              	MOVEA.l	Smeml(a3),a0			; copy start of memory
 1603/     A10 : 6720                   	BEQ.s		LAB_1624				; branch if next character null (RESTORE)
 1604/     A12 :                        
 1605/     A12 : 6100 01F4              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1606/     A16 : B2AB 0452              	CMP.l		Clinel(a3),d1			; compare current line # with required line #
 1607/     A1A : 630E                   	BLS.s		LAB_GSCH				; branch if >= (start search from beginning)
 1608/     A1C :                        
 1609/     A1C : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1610/     A1E :                        LAB_RESs
 1611/     A1E : 4A18                   	TST.b		(a0)+					; test next byte & increment pointer
 1612/     A20 : 66FC                   	BNE.s		LAB_RESs				; loop if not EOL
 1613/     A22 :                        
 1614/     A22 : 3008                   	MOVE.w	a0,d0					; copy pointer
 1615/     A24 : C07C 0001              	AND.w		#1,d0					; mask odd bit
 1616/     A28 : D0C0                   	ADD.w		d0,a0					; add pointer
 1617/     A2A :                        								; search for line in Itemp from (a0)
 1618/     A2A :                        LAB_GSCH
 1619/     A2A : 6100 FDC8              	BSR		LAB_SCLN				; search for d1 line number from a0
 1620/     A2E :                        								; returns Cb=0 if found
 1621/     A2E : 6500 FB24              	BCS		LAB_USER				; go do "Undefined statement" error if not found
 1622/     A32 :                        
 1623/     A32 :                        LAB_1624
 1624/     A32 : 4A20                   	TST.b		-(a0)					; decrement pointer (faster)
 1625/     A34 : 2748 0462              	MOVE.l	a0,Dptrl(a3)			; save DATA pointer
 1626/     A38 :                        RTS_006
 1627/     A38 : 4E75                   	RTS
 1628/     A3A :                        
 1629/     A3A :                        
 1630/     A3A :                        ;************************************************************************************
 1631/     A3A :                        ;
 1632/     A3A :                        ; perform NULL
 1633/     A3A :                        
 1634/     A3A :                        LAB_NULL
 1635/     A3A : 6100 10E2              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 1636/     A3E : 1740 05E4              	MOVE.b	d0,Nullct(a3)			; save new NULL count
 1637/     A42 : 4E75                   	RTS
 1638/     A44 :                        
 1639/     A44 :                        
 1640/     A44 :                        ;************************************************************************************
 1641/     A44 :                        ;
 1642/     A44 :                        ; perform CONT
 1643/     A44 :                        
 1644/     A44 :                        LAB_CONT
 1645/     A44 : 6600 FB26              	BNE		LAB_SNER				; if following byte exit to do syntax error
 1646/     A48 :                        
 1647/     A48 : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
 1648/     A4C : 6A00 FAE6              	BPL		LAB_CCER				; if running go do can't continue error
 1649/     A50 :                        
 1650/     A50 : 202B 045A              	MOVE.l	Cpntrl(a3),d0			; get continue pointer
 1651/     A54 : 6700 FADE              	BEQ		LAB_CCER				; go do can't continue error if we can't
 1652/     A58 :                        
 1653/     A58 :                        								; we can continue so ...
 1654/     A58 : 2A40                   	MOVEA.l	d0,a5					; save continue pointer as BASIC execute pointer
 1655/     A5A : 276B 0456 0452         	MOVE.l	Blinel(a3),Clinel(a3)		; set break line as current line
 1656/     A60 : 4E75                   	RTS
 1657/     A62 :                        
 1658/     A62 :                        
 1659/     A62 :                        ;************************************************************************************
 1660/     A62 :                        ;
 1661/     A62 :                        ; perform RUN
 1662/     A62 :                        
 1663/     A62 :                        LAB_RUN
 1664/     A62 : 660C                   	BNE.s		LAB_RUNn				; if following byte do RUN n
 1665/     A64 :                        
 1666/     A64 : 6100 FDAE              	BSR		LAB_1477				; execution to start, clear vars & flush stack
 1667/     A68 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
 1668/     A6C : 6000 FF22              	BRA		LAB_15C2				; go do interpreter inner loop
 1669/     A70 :                        								; (can't RTS, we flushed the stack!)
 1670/     A70 :                        
 1671/     A70 :                        LAB_RUNn
 1672/     A70 : 6100 FDA8              	BSR		LAB_147A				; go do "CLEAR"
 1673/     A74 : 601C                   	BRA.s		LAB_16B0				; get n and do GOTO n
 1674/     A76 :                        
 1675/     A76 :                        
 1676/     A76 :                        ;************************************************************************************
 1677/     A76 :                        ;
 1678/     A76 :                        ; perform DO
 1679/     A76 :                        
 1680/     A76 :                        LAB_DO
 1681/     A76 :                        ;	MOVE.l	#$05,d0				; need 5 bytes for DO
 1682/     A76 :                        ;	BSR.s		LAB_1212				; check room on stack for A bytes
 1683/     A76 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer on stack
 1684/     A78 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line on stack
 1685/     A7C : 3F3C 009C              	MOVE.w	#TK_DO,-(sp)			; push token for DO on stack
 1686/     A80 : 487A FF0E              	PEA		LAB_15C2(pc)			; set return address
 1687/     A84 : 6000 072E              	BRA		LAB_GBYT				; scan memory & return to interpreter inner loop
 1688/     A88 :                        
 1689/     A88 :                        
 1690/     A88 :                        ;************************************************************************************
 1691/     A88 :                        ;
 1692/     A88 :                        ; perform GOSUB
 1693/     A88 :                        
 1694/     A88 :                        LAB_GOSUB
 1695/     A88 :                        ;	MOVE.l	#10,d0				; need 10 bytes for GOSUB
 1696/     A88 :                        ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
 1697/     A88 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 1698/     A8A : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line
 1699/     A8E : 3F3C 008D              	MOVE.w	#TK_GOSUB,-(sp)			; push token for GOSUB
 1700/     A92 :                        LAB_16B0
 1701/     A92 : 6100 0720              	BSR		LAB_GBYT				; scan memory
 1702/     A96 : 487A FEF8              	PEA		LAB_15C2(pc)			; return to interpreter inner loop after GOTO n
 1703/     A9A :                        
 1704/     A9A :                        ; this PEA is needed because either we just cleared the stack and have nowhere to return
 1705/     A9A :                        ; to or, in the case of GOSUB, we have just dropped a load on the stack and the address
 1706/     A9A :                        ; we whould have returned to is buried. This burried return address will be unstacked by
 1707/     A9A :                        ; the corresponding RETURN command
 1708/     A9A :                        
 1709/     A9A :                        
 1710/     A9A :                        ;************************************************************************************
 1711/     A9A :                        ;
 1712/     A9A :                        ; perform GOTO
 1713/     A9A :                        
 1714/     A9A :                        LAB_GOTO
 1715/     A9A : 6100 016C              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1716/     A9E : 206B 042E              	MOVEA.l	Smeml(a3),a0			; get start of memory
 1717/     AA2 : B2AB 0452              	CMP.l		Clinel(a3),d1			; compare current line with wanted #
 1718/     AA6 : 630E                   	BLS.s		LAB_16D0				; branch if current # => wanted #
 1719/     AA8 :                        
 1720/     AA8 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1721/     AAA :                        LAB_GOTs
 1722/     AAA : 4A18                   	TST.b		(a0)+					; test next byte & increment pointer
 1723/     AAC : 66FC                   	BNE.s		LAB_GOTs				; loop if not EOL
 1724/     AAE :                        
 1725/     AAE : 3008                   	MOVE.w	a0,d0					; past pad byte(s)
 1726/     AB0 : C07C 0001              	AND.w		#1,d0					; mask odd bit
 1727/     AB4 : D0C0                   	ADD.w		d0,a0					; add to pointer
 1728/     AB6 :                        
 1729/     AB6 :                        LAB_16D0
 1730/     AB6 : 6100 FD3C              	BSR		LAB_SCLN				; search for d1 line number from a0
 1731/     ABA :                        								; returns Cb=0 if found
 1732/     ABA : 6500 FA98              	BCS		LAB_USER				; if carry set go do "Undefined statement" error
 1733/     ABE :                        
 1734/     ABE : 2A48                   	MOVEA.l	a0,a5					; copy to basic execute pointer
 1735/     AC0 : 534D                   	SUBQ.w	#1,a5					; decrement pointer
 1736/     AC2 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
 1737/     AC6 : 4E75                   	RTS
 1738/     AC8 :                        
 1739/     AC8 :                        
 1740/     AC8 :                        ;************************************************************************************
 1741/     AC8 :                        ;
 1742/     AC8 :                        ; perform LOOP
 1743/     AC8 :                        
 1744/     AC8 :                        LAB_LOOP
 1745/     AC8 : 0C6F 009C 0004         	CMP.w		#TK_DO,4(sp)			; compare token on stack with DO token
 1746/     ACE : 6600 FA5C              	BNE		LAB_LDER				; branch if no matching DO
 1747/     AD2 :                        
 1748/     AD2 : 1E00                   	MOVE.b	d0,d7					; copy following token (byte)
 1749/     AD4 : 672E                   	BEQ.s		LoopAlways				; if no following token loop forever
 1750/     AD6 :                        
 1751/     AD6 : BE3C 003A              	CMP.b		#':',d7				; compare with ":"
 1752/     ADA : 6728                   	BEQ.s		LoopAlways				; if no following token loop forever
 1753/     ADC :                        
 1754/     ADC : 9E3C 00B0              	SUB.b		#TK_UNTIL,d7			; subtract token for UNTIL
 1755/     AE0 : 6708                   	BEQ.s		DoRest				; branch if was UNTIL
 1756/     AE2 :                        
 1757/     AE2 : 5307                   	SUBQ.b	#1,d7					; decrement result
 1758/     AE4 : 6600 FA86              	BNE		LAB_SNER				; if not WHILE go do syntax error & warm start
 1759/     AE8 :                        								; only if the token was WHILE will this fail
 1760/     AE8 :                        
 1761/     AE8 : 7EFF                   	MOVEQ		#-1,d7				; set invert result longword
 1762/     AEA :                        DoRest
 1763/     AEA : 6100 06C6              	BSR		LAB_IGBY				; increment & scan memory
 1764/     AEE : 6100 0562              	BSR		LAB_EVEX				; evaluate expression
 1765/     AF2 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 1766/     AF6 : 6706                   	BEQ.s		DoCmp					; if = 0 go do straight compare
 1767/     AF8 :                        
 1768/     AF8 : 177C 00FF 0594         	MOVE.b	#$FF,FAC1_e(a3)			; else set all bits
 1769/     AFE :                        DoCmp
 1770/     AFE : BF2B 0594              	EOR.b		d7,FAC1_e(a3)			; EOR with invert byte
 1771/     B02 : 6614                   	BNE.s		LoopDone				; if <> 0 clear stack & back to interpreter loop
 1772/     B04 :                        
 1773/     B04 :                        								; loop condition wasn't met so do it again
 1774/     B04 :                        LoopAlways
 1775/     B04 : 276F 0006 0452         	MOVE.l	6(sp),Clinel(a3)			; copy DO current line
 1776/     B0A : 2A6F 000A              	MOVE.l	10(sp),a5				; save BASIC execute pointer
 1777/     B0E :                        
 1778/     B0E : 41FA FE80              	LEA		LAB_15C2(pc),a0			; get return address
 1779/     B12 : 2E88                   	MOVE.l	a0,(sp)				; dump the call to this routine and set the
 1780/     B14 :                        								; return address
 1781/     B14 : 6000 069E              	BRA		LAB_GBYT				; scan memory and return to interpreter inner
 1782/     B18 :                        								; loop
 1783/     B18 :                        
 1784/     B18 :                        								; clear stack & back to interpreter loop
 1785/     B18 :                        LoopDone
 1786/     B18 : 4FEF 000E              	LEA		14(sp),sp				; dump structure and call from stack
 1787/     B1C : 6014                   	BRA.s		LAB_DATA				; go perform DATA (find : or [EOL])
 1788/     B1E :                        
 1789/     B1E :                        
 1790/     B1E :                        ;************************************************************************************
 1791/     B1E :                        ;
 1792/     B1E :                        ; perform RETURN
 1793/     B1E :                        
 1794/     B1E :                        LAB_RETURN
 1795/     B1E : 6616                   	BNE.s		RTS_007				; exit if following token to allow syntax error
 1796/     B20 :                        
 1797/     B20 : 0C6F 008D 0004         	CMP.w		#TK_GOSUB,4(sp)			; compare token from stack with GOSUB
 1798/     B26 : 6600 FA40              	BNE		LAB_RGER				; do RETURN without GOSUB error if no matching
 1799/     B2A :                        								; GOSUB
 1800/     B2A :                        
 1801/     B2A : 5C4F                   	ADDQ.w	#6,sp					; dump calling address & token
 1802/     B2C : 275F 0452              	MOVE.l	(sp)+,Clinel(a3)			; pull current line
 1803/     B30 : 2A5F                   	MOVE.l	(sp)+,a5				; pull BASIC execute pointer
 1804/     B32 :                        								; now do perform "DATA" statement as we could be
 1805/     B32 :                        								; returning into the middle of an ON <var> GOSUB
 1806/     B32 :                        								; n,m,p,q line (the return address used by the
 1807/     B32 :                        								; DATA statement is the one pushed before the
 1808/     B32 :                        								; GOSUB was executed!)
 1809/     B32 :                        
 1810/     B32 :                        
 1811/     B32 :                        ;************************************************************************************
 1812/     B32 :                        ;
 1813/     B32 :                        ; perform DATA
 1814/     B32 :                        
 1815/     B32 :                        LAB_DATA
 1816/     B32 : 6104                   	BSR.s		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 1817/     B34 :                        								; returns a0 as pointer to [:] or [EOL]
 1818/     B34 : 2A48                   	MOVEA.l	a0,a5					; skip rest of statement
 1819/     B36 :                        RTS_007
 1820/     B36 : 4E75                   	RTS
 1821/     B38 :                        
 1822/     B38 :                        
 1823/     B38 :                        ;************************************************************************************
 1824/     B38 :                        ;
 1825/     B38 :                        ; scan for next BASIC statement ([:] or [EOL])
 1826/     B38 :                        ; returns a0 as pointer to [:] or [EOL]
 1827/     B38 :                        
 1828/     B38 :                        LAB_SNBS
 1829/     B38 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1830/     B3A : 7222                   	MOVEQ		#$22,d1				; set string quote character
 1831/     B3C : 743A                   	MOVEQ		#$3A,d2				; set look for character = ":"
 1832/     B3E : 6008                   	BRA.s		LAB_172D				; go do search
 1833/     B40 :                        
 1834/     B40 :                        LAB_172C
 1835/     B40 : B400                   	CMP.b		d0,d2					; compare with ":"
 1836/     B42 : 6708                   	BEQ.s		RTS_007a				; exit if found
 1837/     B44 :                        
 1838/     B44 : B200                   	CMP.b		d0,d1					; compare with '"'
 1839/     B46 : 670C                   	BEQ.s		LAB_1725				; if found go search for [EOL]
 1840/     B48 :                        
 1841/     B48 :                        LAB_172D
 1842/     B48 : 1018                   	MOVE.b	(a0)+,d0				; get next byte
 1843/     B4A : 66F4                   	BNE.s		LAB_172C				; loop if not null [EOL]
 1844/     B4C :                        
 1845/     B4C :                        RTS_007a
 1846/     B4C : 5348                   	SUBQ.w	#1,a0					; correct pointer
 1847/     B4E : 4E75                   	RTS
 1848/     B50 :                        
 1849/     B50 :                        LAB_1723
 1850/     B50 : B200                   	CMP.b		d0,d1					; compare with '"'
 1851/     B52 : 67F4                   	BEQ.s		LAB_172D				; if found go search for ":" or [EOL]
 1852/     B54 :                        
 1853/     B54 :                        LAB_1725
 1854/     B54 : 1018                   	MOVE.b	(a0)+,d0				; get next byte
 1855/     B56 : 66F8                   	BNE.s		LAB_1723				; loop if not null [EOL]
 1856/     B58 :                        
 1857/     B58 : 60F2                   	BRA.s		RTS_007a				; correct pointer & return
 1858/     B5A :                        
 1859/     B5A :                        
 1860/     B5A :                        ;************************************************************************************
 1861/     B5A :                        ;
 1862/     B5A :                        ; perform IF
 1863/     B5A :                        
 1864/     B5A :                        LAB_IF
 1865/     B5A : 6100 04F6              	BSR		LAB_EVEX				; evaluate expression
 1866/     B5E : 6100 0654              	BSR		LAB_GBYT				; scan memory
 1867/     B62 : B03C 00AD              	CMP.b		#TK_THEN,d0				; compare with THEN token
 1868/     B66 : 6714                   	BEQ.s		LAB_174B				; if it was THEN then continue
 1869/     B68 :                        
 1870/     B68 :                        								; wasn't IF .. THEN so must be IF .. GOTO
 1871/     B68 : B03C 0089              	CMP.b		#TK_GOTO,d0				; compare with GOTO token
 1872/     B6C : 6600 F9FE              	BNE		LAB_SNER				; if not GOTO token do syntax error/warm start
 1873/     B70 :                        
 1874/     B70 :                        								; was GOTO so check for GOTO <n>
 1875/     B70 : 204D                   	MOVE.l	a5,a0					; save the execute pointer
 1876/     B72 : 6100 063E              	BSR		LAB_IGBY				; scan memory, test for a numeric character
 1877/     B76 : 2A48                   	MOVE.l	a0,a5					; restore the execute pointer
 1878/     B78 : 6400 F9F2              	BCC		LAB_SNER				; if not numeric do syntax error/warm start
 1879/     B7C :                        
 1880/     B7C :                        LAB_174B
 1881/     B7C : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 1882/     B80 : 671E                   	BEQ.s		LAB_174E				; if result was zero go look for an ELSE
 1883/     B82 :                        
 1884/     B82 : 6100 062E              	BSR		LAB_IGBY				; increment & scan memory
 1885/     B86 : 6500 FF12              	BCS		LAB_GOTO				; if numeric do GOTO n
 1886/     B8A :                        								; a GOTO <n> will never return to the IF
 1887/     B8A :                        								; statement so there is no need to return
 1888/     B8A :                        								; to this code
 1889/     B8A :                        
 1890/     B8A : B03C 008E              	CMP.b		#TK_RETURN,d0			; compare with RETURN token
 1891/     B8E : 6700 FE1E              	BEQ		LAB_1602				; if RETURN then interpret BASIC code from (a5)
 1892/     B92 :                        								; and don't return here
 1893/     B92 :                        
 1894/     B92 : 6100 FE16              	BSR		LAB_15FF				; else interpret BASIC code from (a5)
 1895/     B96 :                        
 1896/     B96 :                        ; the IF was executed and there may be a following ELSE so the code needs to return
 1897/     B96 :                        ; here to check and ignore the ELSE if present
 1898/     B96 :                        
 1899/     B96 : 1015                   	MOVE.b	(a5),d0				; get the next basic byte
 1900/     B98 : B03C 00A9              	CMP.b		#TK_ELSE,d0				; compare it with the token for ELSE
 1901/     B9C : 6794                   	BEQ		LAB_DATA				; if ELSE ignore the following statement
 1902/     B9E :                        
 1903/     B9E :                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
 1904/     B9E :                        ; following ELSE will, correctly, cause a syntax error
 1905/     B9E :                        
 1906/     B9E : 4E75                   	RTS							; else return to interpreter inner loop
 1907/     BA0 :                        
 1908/     BA0 :                        ; perform ELSE after IF
 1909/     BA0 :                        
 1910/     BA0 :                        LAB_174E
 1911/     BA0 : 101D                   	MOVE.b	(a5)+,d0				; faster increment past THEN
 1912/     BA2 : 163C 00A9              	MOVE.b		#TK_ELSE,d3				; set search for ELSE token
 1913/     BA6 : 183C 008B              	MOVE.b		#TK_IF,d4				; set search for IF token
 1914/     BAA : 7A00                   	MOVEQ		#0,d5					; clear the nesting depth
 1915/     BAC :                        LAB_1750
 1916/     BAC : 101D                   	MOVE.b	(a5)+,d0				; get next BASIC byte & increment ptr
 1917/     BAE : 6720                   	BEQ.s		LAB_1754				; if EOL correct the pointer and return
 1918/     BB0 :                        
 1919/     BB0 : B004                   	CMP.b		d4,d0					; compare with "IF" token
 1920/     BB2 : 6604                   	BNE.s		LAB_1752				; skip if not nested IF
 1921/     BB4 :                        
 1922/     BB4 : 5245                   	ADDQ.w	#1,d5					; else increment the nesting depth ..
 1923/     BB6 : 60F4                   	BRA.s		LAB_1750				; .. and continue looking
 1924/     BB8 :                        
 1925/     BB8 :                        LAB_1752
 1926/     BB8 : B003                   	CMP.b		d3,d0					; compare with ELSE token
 1927/     BBA : 66F0                   	BNE.s		LAB_1750				; if not ELSE continue looking
 1928/     BBC :                        
 1929/     BBC :                        LAB_1756
 1930/     BBC : 51CD FFEE              	DBF		d5,LAB_1750				; loop if still nested
 1931/     BC0 :                        
 1932/     BC0 :                        ; found the matching ELSE, now do <{n|statement}>
 1933/     BC0 :                        
 1934/     BC0 : 6100 05F2              	BSR		LAB_GBYT				; scan memory
 1935/     BC4 : 6500 FED4              	BCS		LAB_GOTO				; if numeric do GOTO n
 1936/     BC8 :                        								; code will return to the interpreter loop
 1937/     BC8 :                        								; at the tail end of the GOTO <n>
 1938/     BC8 :                        
 1939/     BC8 : 6000 FDE0              	BRA		LAB_15FF				; else interpret BASIC code from (a5)
 1940/     BCC :                        								; code will return to the interpreter loop
 1941/     BCC :                        								; at the tail end of the <statement>
 1942/     BCC :                        
 1943/     BCC :                        
 1944/     BCC :                        ;************************************************************************************
 1945/     BCC :                        ;
 1946/     BCC :                        ; perform REM, skip (rest of) line
 1947/     BCC :                        
 1948/     BCC :                        LAB_REM
 1949/     BCC : 4A1D                   	TST.b		(a5)+					; test byte & increment pointer
 1950/     BCE : 66FC                   	BNE.s		LAB_REM				; loop if not EOL
 1951/     BD0 :                        
 1952/     BD0 :                        LAB_1754
 1953/     BD0 : 534D                   	SUBQ.w	#1,a5					; correct the execute pointer
 1954/     BD2 : 4E75                   	RTS
 1955/     BD4 :                        
 1956/     BD4 :                        
 1957/     BD4 :                        ;************************************************************************************
 1958/     BD4 :                        ;
 1959/     BD4 :                        ; perform ON
 1960/     BD4 :                        
 1961/     BD4 :                        LAB_ON
 1962/     BD4 : 6100 0F48              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 1963/     BD8 : 1400                   	MOVE.b	d0,d2					; copy byte
 1964/     BDA : 6100 05D8              	BSR		LAB_GBYT				; restore BASIC byte
 1965/     BDE : 3F00                   	MOVE.w	d0,-(sp)				; push GOTO/GOSUB token
 1966/     BE0 : B03C 008D              	CMP.b		#TK_GOSUB,d0			; compare with GOSUB token
 1967/     BE4 : 6708                   	BEQ.s		LAB_176C				; branch if GOSUB
 1968/     BE6 :                        
 1969/     BE6 : B03C 0089              	CMP.b		#TK_GOTO,d0				; compare with GOTO token
 1970/     BEA : 6600 F980              	BNE		LAB_SNER				; if not GOTO do syntax error, then warm start
 1971/     BEE :                        
 1972/     BEE :                        ; next character was GOTO or GOSUB
 1973/     BEE :                        
 1974/     BEE :                        LAB_176C
 1975/     BEE : 5302                   	SUBQ.b	#1,d2					; decrement index (byte value)
 1976/     BF0 : 6606                   	BNE.s		LAB_1773				; branch if not zero
 1977/     BF2 :                        
 1978/     BF2 : 301F                   	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token
 1979/     BF4 : 6000 FDB8              	BRA		LAB_1602				; go execute it
 1980/     BF8 :                        
 1981/     BF8 :                        LAB_1773
 1982/     BF8 : 6100 05B8              	BSR		LAB_IGBY				; increment & scan memory
 1983/     BFC : 610A                   	BSR.s		LAB_GFPN				; get fixed-point number into temp integer & d1
 1984/     BFE :                        								; (skip this n)
 1985/     BFE : B03C 002C              	CMP.b		#$2C,d0				; compare next character with ","
 1986/     C02 : 67EA                   	BEQ.s		LAB_176C				; loop if ","
 1987/     C04 :                        
 1988/     C04 : 301F                   	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token (run out of options)
 1989/     C06 : 4E75                   	RTS							; and exit
 1990/     C08 :                        
 1991/     C08 :                        
 1992/     C08 :                        ;************************************************************************************
 1993/     C08 :                        ;
 1994/     C08 :                        ; get fixed-point number into temp integer & d1
 1995/     C08 :                        ; interpret number from (a5), leave (a5) pointing to byte after #
 1996/     C08 :                        
 1997/     C08 :                        LAB_GFPN
 1998/     C08 : 7200                   	MOVEQ		#$00,d1				; clear integer register
 1999/     C0A : 2001                   	MOVE.l	d1,d0					; clear d0
 2000/     C0C : 6100 05A6              	BSR		LAB_GBYT				; scan memory, Cb=1 if "0"-"9", & get byte
 2001/     C10 : 642E                   	BCC.s		LAB_1786				; return if carry clear, chr was not "0"-"9"
 2002/     C12 :                        
 2003/     C12 : 2F02                   	MOVE.l	d2,-(sp)				; save d2
 2004/     C14 :                        LAB_1785
 2005/     C14 : 2401                   	MOVE.l	d1,d2					; copy integer register
 2006/     C16 : D281                   	ADD.l		d1,d1					; *2
 2007/     C18 : 6500 F952              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2008/     C1C :                        
 2009/     C1C : D281                   	ADD.l		d1,d1					; *4
 2010/     C1E : 6500 F94C              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2011/     C22 :                        
 2012/     C22 : D282                   	ADD.l		d2,d1					; *1 + *4
 2013/     C24 : 6500 F946              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2014/     C28 :                        
 2015/     C28 : D281                   	ADD.l		d1,d1					; *10
 2016/     C2A : 6500 F940              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 2017/     C2E :                        
 2018/     C2E : 903C 0030              	SUB.b		#$30,d0				; subtract $30 from byte
 2019/     C32 : D280                   	ADD.l		d0,d1					; add to integer register, the top 24 bits are
 2020/     C34 :                        								; always clear
 2021/     C34 : 6900 F936              	BVS		LAB_SNER				; if overflow do syntax error, then warm start
 2022/     C38 :                        								; this makes the maximum line number 2147483647
 2023/     C38 : 6100 0578              	BSR		LAB_IGBY				; increment & scan memory
 2024/     C3C : 65D6                   	BCS.s		LAB_1785				; loop for next character if "0"-"9"
 2025/     C3E :                        
 2026/     C3E : 241F                   	MOVE.l	(sp)+,d2				; restore d2
 2027/     C40 :                        LAB_1786
 2028/     C40 : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save Itemp
 2029/     C44 : 4E75                   	RTS
 2030/     C46 :                        
 2031/     C46 :                        
 2032/     C46 :                        ;************************************************************************************
 2033/     C46 :                        ;
 2034/     C46 :                        ; perform DEC
 2035/     C46 :                        
 2036/     C46 :                        LAB_DEC
 2037/     C46 : 3F3C 8180              	MOVE.w	#$8180,-(sp)			; set -1 sign/exponent
 2038/     C4A : 600A                   	BRA.s		LAB_17B7				; go do DEC
 2039/     C4C :                        
 2040/     C4C :                        
 2041/     C4C :                        ;************************************************************************************
 2042/     C4C :                        ;
 2043/     C4C :                        ; perform INC
 2044/     C4C :                        
 2045/     C4C :                        LAB_INC
 2046/     C4C : 3F3C 8100              	MOVE.w	#$8100,-(sp)			; set 1 sign/exponent
 2047/     C50 : 6004                   	BRA.s		LAB_17B7				; go do INC
 2048/     C52 :                        
 2049/     C52 :                        								; was "," so another INCR variable to do
 2050/     C52 :                        LAB_17B8
 2051/     C52 : 6100 055E              	BSR		LAB_IGBY				; increment and scan memory
 2052/     C56 :                        LAB_17B7
 2053/     C56 : 6100 076C              	BSR		LAB_GVAR				; get variable address in a0
 2054/     C5A :                        
 2055/     C5A : 6732                   	BEQ.s		LAB_INCT				; if variable not found skip the inc/dec
 2056/     C5C : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2057/     C60 :                        								; $00=float
 2058/     C60 : 6B00 F8DE              	BMI		LAB_TMER				; if string do "Type mismatch" error/warm start
 2059/     C64 :                        
 2060/     C64 : 6636                   	BNE.s		LAB_INCI				; go do integer INC/DEC
 2061/     C66 :                        
 2062/     C66 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save var address
 2063/     C6A : 6100 130E              	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
 2064/     C6E : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set FAC2 mantissa for 1
 2065/     C76 : 3017                   	MOVE.w	(sp),d0				; move exponent & sign to d0
 2066/     C78 : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; move exponent & sign to FAC2
 2067/     C7C : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
 2068/     C82 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
 2069/     C86 : 6100 100E              	BSR		LAB_ADD				; add FAC2 to FAC1
 2070/     C8A : 6100 130A              	BSR		LAB_PFAC				; pack FAC1 into variable (Lvarpl)
 2071/     C8E :                        LAB_INCT
 2072/     C8E : 6100 0524              	BSR		LAB_GBYT				; scan memory
 2073/     C92 : 0C00 002C              	CMPI.b	#$2C,d0				; compare with ","
 2074/     C96 : 67BA                   	BEQ.s		LAB_17B8				; continue if "," (another variable to do)
 2075/     C98 :                        
 2076/     C98 : 544F                   	ADDQ.w	#2,sp					; else dump sign & exponent
 2077/     C9A : 4E75                   	RTS
 2078/     C9C :                        
 2079/     C9C :                        LAB_INCI
 2080/     C9C : 4A2F 0001              	TST.b		1(sp)					; test sign
 2081/     CA0 : 6604                   	BNE.s		LAB_DECI				; branch if DEC
 2082/     CA2 :                        
 2083/     CA2 : 5290                   	ADDQ.l	#1,(a0)				; increment variable
 2084/     CA4 : 60E8                   	BRA.s		LAB_INCT				; go scan for more
 2085/     CA6 :                        
 2086/     CA6 :                        LAB_DECI
 2087/     CA6 : 5390                   	SUBQ.l	#1,(a0)				; decrement variable
 2088/     CA8 : 60E4                   	BRA.s		LAB_INCT				; go scan for more
 2089/     CAA :                        
 2090/     CAA :                        
 2091/     CAA :                        ;************************************************************************************
 2092/     CAA :                        ;
 2093/     CAA :                        ; perform LET
 2094/     CAA :                        
 2095/     CAA :                        LAB_LET
 2096/     CAA : 6100 0714              	BSR		LAB_SVAR				; search for or create a variable
 2097/     CAE :                        								; return the variable address in a0
 2098/     CAE : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address
 2099/     CB2 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push var data type, $80=string, $40=integer,
 2100/     CB6 :                        								; $00=float
 2101/     CB6 : 70BD                   	MOVEQ		#TK_EQUAL-$100,d0			; get = token
 2102/     CB8 : 6100 04F0              	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
 2103/     CBC :                        								; start
 2104/     CBC : 6100 0394              	BSR		LAB_EVEX				; evaluate expression
 2105/     CC0 : 102B 05B5              	MOVE.b	Dtypef(a3),d0			; copy expression data type
 2106/     CC4 : 175F 05B5              	MOVE.b	(sp)+,Dtypef(a3)			; pop variable data type
 2107/     CC8 : E318                   	ROL.b		#1,d0					; set carry if expression type = string
 2108/     CCA : 6100 0372              	BSR		LAB_CKTM				; type match check, set C for string
 2109/     CCE : 6700 12C6              	BEQ		LAB_PFAC				; if number pack FAC1 into variable Lvarpl & RET
 2110/     CD2 :                        
 2111/     CD2 :                        ; string LET
 2112/     CD2 :                        
 2113/     CD2 :                        LAB_17D5
 2114/     CD2 : 246B 0472              	MOVEA.l	Lvarpl(a3),a2			; get pointer to variable
 2115/     CD6 :                        LAB_17D6
 2116/     CD6 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
 2117/     CDA : 2250                   	MOVEA.l	(a0),a1				; get string pointer
 2118/     CDC : B3EB 0446              	CMP.l		Sstorl(a3),a1			; compare string memory start with string
 2119/     CE0 :                        								; pointer
 2120/     CE0 : 6516                   	BCS.s		LAB_1811				; if it was in program memory assign the value
 2121/     CE2 :                        								; and exit
 2122/     CE2 :                        
 2123/     CE2 : B1EB 0432              	CMPA.l	Sfncl(a3),a0			; compare functions start with descriptor
 2124/     CE6 :                        								; pointer
 2125/     CE6 : 6510                   	BCS.s		LAB_1811				; branch if >= (string is on stack)
 2126/     CE8 :                        
 2127/     CE8 :                        								; string is variable$ make space and copy string
 2128/     CE8 :                        LAB_1810
 2129/     CE8 : 7200                   	MOVEQ		#0,d1					; clear length
 2130/     CEA : 3228 0004              	MOVE.w	4(a0),d1				; get string length
 2131/     CEE : 2050                   	MOVEA.l	(a0),a0				; get string pointer
 2132/     CF0 : 6100 0B06              	BSR		LAB_20C9				; copy string
 2133/     CF4 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer back
 2134/     CF8 :                        								; clean stack & assign value to string variable
 2135/     CF8 :                        LAB_1811
 2136/     CF8 : B9C8                   	CMPA.l	a0,a4					; is string on the descriptor stack
 2137/     CFA : 6602                   	BNE.s		LAB_1813				; skip pop if not
 2138/     CFC :                        
 2139/     CFC : 5C4C                   	ADDQ.w	#$06,a4				; else update stack pointer
 2140/     CFE :                        LAB_1813
 2141/     CFE : 24D8                   	MOVE.l	(a0)+,(a2)+				; save pointer to variable
 2142/     D00 : 3490                   	MOVE.w	(a0),(a2)				; save length to variable
 2143/     D02 :                        RTS_008
 2144/     D02 : 4E75                   	RTS
 2145/     D04 :                        
 2146/     D04 :                        
 2147/     D04 :                        ;************************************************************************************
 2148/     D04 :                        ;
 2149/     D04 :                        ; perform GET
 2150/     D04 :                        
 2151/     D04 :                        LAB_GET
 2152/     D04 : 6100 06BA              	BSR		LAB_SVAR				; search for or create a variable
 2153/     D08 :                        								; return the variable address in a0
 2154/     D08 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address as GET variable
 2155/     D0C : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2156/     D10 :                        								; $00=float
 2157/     D10 : 6B0C                   	BMI.s		LAB_GETS				; go get string character
 2158/     D12 :                        
 2159/     D12 :                        								; was numeric get
 2160/     D12 : 6100 1DF2              	BSR		INGET					; get input byte
 2161/     D16 : 6100 09BC              	BSR		LAB_1FD0				; convert d0 to unsigned byte in FAC1
 2162/     D1A : 6000 127A              	BRA		LAB_PFAC				; pack FAC1 into variable (Lvarpl) & return
 2163/     D1E :                        
 2164/     D1E :                        LAB_GETS
 2165/     D1E : 7200                   	MOVEQ		#$00,d1				; assume no byte
 2166/     D20 : 2041                   	MOVE.l	d1,a0					; assume null string
 2167/     D22 : 6100 1DE2              	BSR		INGET					; get input byte
 2168/     D26 : 6408                   	BCC.s		LAB_NoSt				; branch if no byte received
 2169/     D28 :                        
 2170/     D28 : 7201                   	MOVEQ		#$01,d1				; string is single byte
 2171/     D2A : 6100 0AFE              	BSR		LAB_2115				; make string space d1 bytes long
 2172/     D2E :                        								; return a0 = pointer, other registers unchanged
 2173/     D2E :                        
 2174/     D2E : 1080                   	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
 2175/     D30 :                        LAB_NoSt
 2176/     D30 : 6100 0ADE              	BSR		LAB_RTST				; push string on descriptor stack
 2177/     D34 :                        								; a0 = pointer, d1 = length
 2178/     D34 :                        
 2179/     D34 : 609C                   	BRA.s		LAB_17D5				; do string LET & return
 2180/     D36 :                        
 2181/     D36 :                        
 2182/     D36 :                        ;************************************************************************************
 2183/     D36 :                        ;
 2184/     D36 :                        ; PRINT
 2185/     D36 :                        
 2186/     D36 :                        LAB_1829
 2187/     D36 : 6100 00B4              	BSR		LAB_18C6				; print string from stack
 2188/     D3A :                        LAB_182C
 2189/     D3A : 6100 0478              	BSR		LAB_GBYT				; scan memory
 2190/     D3E :                        
 2191/     D3E :                        ; perform PRINT
 2192/     D3E :                        
 2193/     D3E :                        LAB_PRINT
 2194/     D3E : 674A                   	BEQ.s		LAB_CRLF				; if nothing following just print CR/LF
 2195/     D40 :                        
 2196/     D40 :                        LAB_1831
 2197/     D40 : B03C 00A8              	CMP.b		#TK_TAB,d0				; compare with TAB( token
 2198/     D44 : 6764                   	BEQ.s		LAB_18A2				; go do TAB/SPC
 2199/     D46 :                        
 2200/     D46 : B03C 00AC              	CMP.b		#TK_SPC,d0				; compare with SPC( token
 2201/     D4A : 675E                   	BEQ.s		LAB_18A2				; go do TAB/SPC
 2202/     D4C :                        
 2203/     D4C : B03C 002C              	CMP.b		#',',d0				; compare with ","
 2204/     D50 : 6740                   	BEQ.s		LAB_188B				; go do move to next TAB mark
 2205/     D52 :                        
 2206/     D52 : B03C 003B              	CMP.b		#';',d0				; compare with ";"
 2207/     D56 : 6700 0086              	BEQ		LAB_18BD				; if ";" continue with PRINT processing
 2208/     D5A :                        
 2209/     D5A : 6100 02F6              	BSR		LAB_EVEX				; evaluate expression
 2210/     D5E : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2211/     D62 :                        								; $00=float
 2212/     D62 : 6BD2                   	BMI.s		LAB_1829				; branch if string
 2213/     D64 :                        
 2214/     D64 :                        ; replace the two lines above with this code
 2215/     D64 :                        
 2216/     D64 :                        ;	MOVE.b	Dtypef(a3),d0			; get data type flag, $80=string, $00=numeric
 2217/     D64 :                        ;	BMI.s		LAB_1829				; branch if string
 2218/     D64 :                        
 2219/     D64 : 6100 13B2              	BSR		LAB_2970				; convert FAC1 to string
 2220/     D68 : 6100 0A60              	BSR		LAB_20AE				; print " terminated string to FAC1 stack
 2221/     D6C :                        
 2222/     D6C :                        ; don't check fit if terminal width byte is zero
 2223/     D6C :                        
 2224/     D6C : 7000                   	MOVEQ		#0,d0					; clear d0
 2225/     D6E : 102B 05E6              	MOVE.b	TWidth(a3),d0			; get terminal width byte
 2226/     D72 : 670C                   	BEQ.s		LAB_185E				; skip check if zero
 2227/     D74 :                        
 2228/     D74 : 902C 0007              	SUB.b		7(a4),d0				; subtract string length
 2229/     D78 : 902B 05E5              	SUB.b		TPos(a3),d0				; subtract terminal position
 2230/     D7C : 6402                   	BCC		LAB_185E				; branch if less than terminal width
 2231/     D7E :                        
 2232/     D7E : 610A                   	BSR.s		LAB_CRLF				; else print CR/LF
 2233/     D80 :                        LAB_185E
 2234/     D80 : 616A                   	BSR.s		LAB_18C6				; print string from stack
 2235/     D82 : 60B6                   	BRA.s		LAB_182C				; always go continue processing line
 2236/     D84 :                        
 2237/     D84 :                        
 2238/     D84 :                        ;************************************************************************************
 2239/     D84 :                        ;
 2240/     D84 :                        ; CR/LF return to BASIC from BASIC input handler
 2241/     D84 :                        ; leaves a0 pointing to the buffer start
 2242/     D84 :                        
 2243/     D84 :                        LAB_1866
 2244/     D84 : 11BC 0000 1000         	MOVE.b	#$00,(a0,d1.w)			; null terminate input
 2245/     D8A :                        
 2246/     D8A :                        ; print CR/LF
 2247/     D8A :                        
 2248/     D8A :                        LAB_CRLF
 2249/     D8A : 700D                   	MOVEQ		#$0D,d0				; load [CR]
 2250/     D8C : 6174                   	BSR.s		LAB_PRNA				; go print the character
 2251/     D8E : 700A                   	MOVEQ		#$0A,d0				; load [LF]
 2252/     D90 : 6070                   	BRA.s		LAB_PRNA				; go print the character & return
 2253/     D92 :                        
 2254/     D92 :                        LAB_188B
 2255/     D92 : 142B 05E5              	MOVE.b	TPos(a3),d2				; get terminal position
 2256/     D96 : B42B 05E7              	CMP.b		Iclim(a3),d2			; compare with input column limit
 2257/     D9A : 6504                   	BCS.s		LAB_1898				; branch if less than Iclim
 2258/     D9C :                        
 2259/     D9C : 61EC                   	BSR.s		LAB_CRLF				; else print CR/LF (next line)
 2260/     D9E : 603E                   	BRA.s		LAB_18BD				; continue with PRINT processing
 2261/     DA0 :                        
 2262/     DA0 :                        LAB_1898
 2263/     DA0 : 942B 05E2              	SUB.b		TabSiz(a3),d2			; subtract TAB size
 2264/     DA4 : 64FA                   	BCC.s		LAB_1898				; loop if result was >= 0
 2265/     DA6 :                        
 2266/     DA6 : 4402                   	NEG.b		d2					; twos complement it
 2267/     DA8 : 6022                   	BRA.s		LAB_18B7				; print d2 spaces
 2268/     DAA :                        
 2269/     DAA :                        								; do TAB/SPC
 2270/     DAA :                        LAB_18A2
 2271/     DAA : 3F00                   	MOVE.w	d0,-(sp)				; save token
 2272/     DAC : 6100 0D6C              	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
 2273/     DB0 : 3400                   	MOVE.w	d0,d2					; copy byte
 2274/     DB2 : 6100 0400              	BSR		LAB_GBYT				; get basic byte back
 2275/     DB6 : B03C 0029              	CMP.b		#$29,d0				; is next character ")"
 2276/     DBA : 6600 F7B0              	BNE		LAB_SNER				; if not do syntax error, then warm start
 2277/     DBE :                        
 2278/     DBE : 301F                   	MOVE.w	(sp)+,d0				; get token back
 2279/     DC0 : B03C 00A8              	CMP.b		#TK_TAB,d0				; was it TAB ?
 2280/     DC4 : 6606                   	BNE.s		LAB_18B7				; branch if not (was SPC)
 2281/     DC6 :                        
 2282/     DC6 :                        								; calculate TAB offset
 2283/     DC6 : 942B 05E5              	SUB.b		TPos(a3),d2				; subtract terminal position
 2284/     DCA : 6312                   	BLS.s		LAB_18BD				; branch if result was <= 0
 2285/     DCC :                        								; can't TAB backwards or already there
 2286/     DCC :                        
 2287/     DCC :                        								; print d2.b spaces
 2288/     DCC :                        LAB_18B7
 2289/     DCC : 7000                   	MOVEQ		#0,d0					; clear longword
 2290/     DCE : 5300                   	SUBQ.b	#1,d0					; make d0 = $FF
 2291/     DD0 : C480                   	AND.l		d0,d2					; mask for byte only
 2292/     DD2 : 670A                   	BEQ.s		LAB_18BD				; branch if zero
 2293/     DD4 :                        
 2294/     DD4 : 7020                   	MOVEQ		#$20,d0				; load " "
 2295/     DD6 : 5302                   	SUBQ.b	#1,d2					; adjust for DBF loop
 2296/     DD8 :                        LAB_18B8
 2297/     DD8 : 6128                   	BSR.s		LAB_PRNA				; go print
 2298/     DDA : 51CA FFFC              	DBF		d2,LAB_18B8				; decrement count and loop if not all done
 2299/     DDE :                        
 2300/     DDE :                        								; continue with PRINT processing
 2301/     DDE :                        LAB_18BD
 2302/     DDE : 6100 03D2              	BSR		LAB_IGBY				; increment & scan memory
 2303/     DE2 : 6600 FF5C              	BNE		LAB_1831				; if byte continue executing PRINT
 2304/     DE6 :                        
 2305/     DE6 : 4E75                   	RTS							; exit if nothing more to print
 2306/     DE8 :                        
 2307/     DE8 :                        
 2308/     DE8 :                        ;************************************************************************************
 2309/     DE8 :                        ;
 2310/     DE8 :                        ; print null terminated string from a0
 2311/     DE8 :                        
 2312/     DE8 :                        LAB_18C3
 2313/     DE8 : 6100 09E0              	BSR		LAB_20AE				; print terminated string to FAC1/stack
 2314/     DEC :                        
 2315/     DEC :                        ; print string from stack
 2316/     DEC :                        
 2317/     DEC :                        LAB_18C6
 2318/     DEC : 6100 0BD0              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 2319/     DF0 :                        								; returns with d0 = length, a0 = pointer
 2320/     DF0 : 670C                   	BEQ.s		RTS_009				; exit (RTS) if null string
 2321/     DF2 :                        
 2322/     DF2 : 3200                   	MOVE.w	d0,d1					; copy length & set Z flag
 2323/     DF4 : 5341                   	SUBQ.w	#1,d1					; -1 for BF loop
 2324/     DF6 :                        LAB_18CD
 2325/     DF6 : 1018                   	MOVE.b	(a0)+,d0				; get byte from string
 2326/     DF8 : 6108                   	BSR.s		LAB_PRNA				; go print the character
 2327/     DFA : 51C9 FFFA              	DBF		d1,LAB_18CD				; decrement count and loop if not done yet
 2328/     DFE :                        
 2329/     DFE :                        RTS_009
 2330/     DFE : 4E75                   	RTS
 2331/     E00 :                        
 2332/     E00 :                        
 2333/     E00 :                        ;************************************************************************************
 2334/     E00 :                        ;
 2335/     E00 :                        ; print "?" character
 2336/     E00 :                        
 2337/     E00 :                        LAB_18E3
 2338/     E00 : 703F                   	MOVEQ		#$3F,d0				; load "?" character
 2339/     E02 :                        
 2340/     E02 :                        
 2341/     E02 :                        ;************************************************************************************
 2342/     E02 :                        ;
 2343/     E02 :                        ; print character in d0, includes the null handler and infinite line length code
 2344/     E02 :                        ; changes no registers
 2345/     E02 :                        
 2346/     E02 :                        LAB_PRNA
 2347/     E02 : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 2348/     E04 : B03C 0020              	CMP.b		#$20,d0				; compare with " "
 2349/     E08 : 6528                   	BCS.s		LAB_18F9				; branch if less, non printing character
 2350/     E0A :                        
 2351/     E0A :                        								; don't check fit if terminal width byte is zero
 2352/     E0A : 122B 05E6              	MOVE.b	TWidth(a3),d1			; get terminal width
 2353/     E0E : 6610                   	BNE.s		LAB_18F0				; branch if not zero (not infinite length)
 2354/     E10 :                        
 2355/     E10 :                        								; is "infinite line" so check TAB position
 2356/     E10 : 122B 05E5              	MOVE.b	TPos(a3),d1				; get position
 2357/     E14 : 922B 05E2              	SUB.b		TabSiz(a3),d1			; subtract TAB size
 2358/     E18 : 6614                   	BNE.s		LAB_18F7				; skip reset if different
 2359/     E1A :                        
 2360/     E1A : 1741 05E5              	MOVE.b	d1,TPos(a3)				; else reset position
 2361/     E1E : 600E                   	BRA.s		LAB_18F7				; go print character
 2362/     E20 :                        
 2363/     E20 :                        LAB_18F0
 2364/     E20 : B22B 05E5              	CMP.b		TPos(a3),d1				; compare with terminal character position
 2365/     E24 : 6608                   	BNE.s		LAB_18F7				; branch if not at end of line
 2366/     E26 :                        
 2367/     E26 : 2F00                   	MOVE.l	d0,-(sp)				; save d0
 2368/     E28 : 6100 FF60              	BSR		LAB_CRLF				; else print CR/LF
 2369/     E2C : 201F                   	MOVE.l	(sp)+,d0				; restore d0
 2370/     E2E :                        LAB_18F7
 2371/     E2E : 522B 05E5              	ADDQ.b	#$01,TPos(a3)			; increment terminal position
 2372/     E32 :                        LAB_18F9
 2373/     E32 : 4EAB 0412              	JSR		V_OUTP(a3)				; output byte via output vector
 2374/     E36 : B03C 000D              	CMP.b		#$0D,d0				; compare with [CR]
 2375/     E3A : 6618                   	BNE.s		LAB_188A				; branch if not [CR]
 2376/     E3C :                        
 2377/     E3C :                        								; else print nullct nulls after the [CR]
 2378/     E3C : 7200                   	MOVEQ		#$00,d1				; clear d1
 2379/     E3E : 122B 05E4              	MOVE.b	Nullct(a3),d1			; get null count
 2380/     E42 : 670C                   	BEQ.s		LAB_1886				; branch if no nulls
 2381/     E44 :                        
 2382/     E44 : 7000                   	MOVEQ		#$00,d0				; load [NULL]
 2383/     E46 :                        LAB_1880
 2384/     E46 : 4EAB 0412              	JSR		V_OUTP(a3)				; go print the character
 2385/     E4A : 51C9 FFFA              	DBF		d1,LAB_1880				; decrement count and loop if not all done
 2386/     E4E :                        
 2387/     E4E : 700D                   	MOVEQ		#$0D,d0				; restore the character
 2388/     E50 :                        LAB_1886
 2389/     E50 : 1741 05E5              	MOVE.b	d1,TPos(a3)				; clear terminal position
 2390/     E54 :                        LAB_188A
 2391/     E54 : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 2392/     E56 : 4E75                   	RTS
 2393/     E58 :                        
 2394/     E58 :                        
 2395/     E58 :                        ;************************************************************************************
 2396/     E58 :                        ;
 2397/     E58 :                        ; handle bad input data
 2398/     E58 :                        
 2399/     E58 :                        LAB_1904
 2400/     E58 : 2A5F                   	MOVEA.l	(sp)+,a5				; restore execute pointer
 2401/     E5A : 4A2B 05E0              	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
 2402/     E5E : 6A0A                   	BPL.s		LAB_1913				; branch if INPUT (go do redo)
 2403/     E60 :                        
 2404/     E60 : 276B 045E 0452         	MOVE.l	Dlinel(a3),Clinel(a3)		; save DATA line as current line
 2405/     E66 : 6000 F6D8              	BRA		LAB_TMER				; do type mismatch error, then warm start
 2406/     E6A :                        
 2407/     E6A :                        								; mode was INPUT
 2408/     E6A :                        LAB_1913
 2409/     E6A : 41FA 2A76              	LEA		LAB_REDO(pc),a0			; point to redo message
 2410/     E6E : 6100 FF78              	BSR		LAB_18C3				; print null terminated string from memory
 2411/     E72 : 2A6B 045A              	MOVEA.l	Cpntrl(a3),a5			; save continue pointer as BASIC execute pointer
 2412/     E76 : 4E75                   	RTS
 2413/     E78 :                        
 2414/     E78 :                        
 2415/     E78 :                        ;************************************************************************************
 2416/     E78 :                        ;
 2417/     E78 :                        ; perform INPUT
 2418/     E78 :                        
 2419/     E78 :                        LAB_INPUT
 2420/     E78 : 6100 0862              	BSR		LAB_CKRN				; check not direct (back here if ok)
 2421/     E7C : B03C 0022              	CMP.b		#'"',d0				; compare the next byte with open quote
 2422/     E80 : 660E                   	BNE.s		LAB_1934				; if no prompt string just go get the input
 2423/     E82 :                        
 2424/     E82 : 6100 0306              	BSR		LAB_1BC1				; print "..." string
 2425/     E86 : 703B                   	MOVEQ		#';',d0				; set the search character to ";"
 2426/     E88 : 6100 0320              	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
 2427/     E8C :                        								; start
 2428/     E8C : 6100 FF5E              	BSR		LAB_18C6				; print string from Sutill/Sutilh
 2429/     E90 :                        								; finished the prompt, now read the data
 2430/     E90 :                        LAB_1934
 2431/     E90 : 6100 F804              	BSR		LAB_INLN				; print "? " and get BASIC input
 2432/     E94 :                        								; return a0 pointing to the buffer start
 2433/     E94 : 7000                   	MOVEQ		#0,d0					; flag INPUT
 2434/     E96 : 4A10                   	TST.b		(a0)					; test first byte from buffer
 2435/     E98 : 660A                   	BNE.s		LAB_1953				; branch if not null input
 2436/     E9A :                        
 2437/     E9A : 6000 FB58              	BRA		LAB_1647				; go do BREAK exit
 2438/     E9E :                        
 2439/     E9E :                        
 2440/     E9E :                        ;************************************************************************************
 2441/     E9E :                        ;
 2442/     E9E :                        ; perform READ
 2443/     E9E :                        
 2444/     E9E :                        LAB_READ
 2445/     E9E : 206B 0462              	MOVEA.l	Dptrl(a3),a0			; get the DATA pointer
 2446/     EA2 : 7098                   	MOVEQ		#$98-$100,d0			; flag READ
 2447/     EA4 :                        LAB_1953
 2448/     EA4 : 1740 05E0              	MOVE.b	d0,Imode(a3)			; set input mode flag, $00=INPUT, $98=READ
 2449/     EA8 : 2748 0466              	MOVE.l	a0,Rdptrl(a3)			; save READ pointer
 2450/     EAC :                        
 2451/     EAC :                        								; READ or INPUT the next variable from list
 2452/     EAC :                        LAB_195B
 2453/     EAC : 6100 0512              	BSR		LAB_SVAR				; search for or create a variable
 2454/     EB0 :                        								; return the variable address in a0
 2455/     EB0 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address as LET variable
 2456/     EB4 : 2F0D                   	MOVE.l	a5,-(sp)				; save BASIC execute pointer
 2457/     EB6 :                        LAB_1961
 2458/     EB6 : 2A6B 0466              	MOVEA.l	Rdptrl(a3),a5			; set READ pointer as BASIC execute pointer
 2459/     EBA : 6100 02F8              	BSR		LAB_GBYT				; scan memory
 2460/     EBE : 661E                   	BNE.s		LAB_1986				; if not null go get the value
 2461/     EC0 :                        
 2462/     EC0 :                        								; the pointer was to a null entry
 2463/     EC0 : 4A2B 05E0              	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
 2464/     EC4 : 6B72                   	BMI.s		LAB_19DD				; branch if READ (go find the next statement)
 2465/     EC6 :                        
 2466/     EC6 :                        								; else the mode was INPUT so get more
 2467/     EC6 : 6100 FF38              	BSR		LAB_18E3				; print a "?" character
 2468/     ECA : 6100 F7CA              	BSR		LAB_INLN				; print "? " and get BASIC input
 2469/     ECE :                        								; return a0 pointing to the buffer start
 2470/     ECE : 4A10                   	TST.b		(a0)					; test the first byte from the buffer
 2471/     ED0 : 6604                   	BNE.s		LAB_1984				; if not null input go handle it
 2472/     ED2 :                        
 2473/     ED2 : 6000 FB20              	BRA		LAB_1647				; else go do the BREAK exit
 2474/     ED6 :                        
 2475/     ED6 :                        LAB_1984
 2476/     ED6 : 2A48                   	MOVEA.l	a0,a5					; set the execute pointer to the buffer
 2477/     ED8 : 534D                   	SUBQ.w	#1,a5					; decrement the execute pointer
 2478/     EDA :                        
 2479/     EDA :                        LAB_1985
 2480/     EDA : 6100 02D6              	BSR		LAB_IGBY				; increment & scan memory
 2481/     EDE :                        LAB_1986
 2482/     EDE : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2483/     EE2 :                        								; $00=float
 2484/     EE2 : 6A20                   	BPL.s		LAB_19B0				; branch if numeric
 2485/     EE4 :                        
 2486/     EE4 :                        								; else get string
 2487/     EE4 : 1400                   	MOVE.b	d0,d2					; save search character
 2488/     EE6 : B03C 0022              	CMP.b		#$22,d0				; was it " ?
 2489/     EEA : 6706                   	BEQ.s		LAB_1999				; branch if so
 2490/     EEC :                        
 2491/     EEC : 743A                   	MOVEQ		#':',d2				; set new search character
 2492/     EEE : 702C                   	MOVEQ		#',',d0				; other search character is ","
 2493/     EF0 : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2494/     EF2 :                        LAB_1999
 2495/     EF2 : 524D                   	ADDQ.w	#1,a5					; increment BASIC execute pointer
 2496/     EF4 : 1600                   	MOVE.b	d0,d3					; set second search character
 2497/     EF6 : 204D                   	MOVEA.l	a5,a0					; BASIC execute pointer is source
 2498/     EF8 :                        
 2499/     EF8 : 6100 08D4              	BSR		LAB_20B4				; print d2/d3 terminated string to FAC1 stack
 2500/     EFC :                        								; d2 = Srchc, d3 = Asrch, a0 is source
 2501/     EFC : 2A4A                   	MOVEA.l	a2,a5					; copy end of string to BASIC execute pointer
 2502/     EFE : 6100 FDD2              	BSR		LAB_17D5				; go do string LET
 2503/     F02 : 6010                   	BRA.s		LAB_19B6				; go check string terminator
 2504/     F04 :                        
 2505/     F04 :                        								; get numeric INPUT
 2506/     F04 :                        LAB_19B0
 2507/     F04 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; save variable data type
 2508/     F08 : 6100 1DA6              	BSR		LAB_2887				; get FAC1 from string
 2509/     F0C : 175F 05B5              	MOVE.b	(sp)+,Dtypef(a3)			; restore variable data type
 2510/     F10 : 6100 1084              	BSR		LAB_PFAC				; pack FAC1 into (Lvarpl)
 2511/     F14 :                        LAB_19B6
 2512/     F14 : 6100 029E              	BSR		LAB_GBYT				; scan memory
 2513/     F18 : 670A                   	BEQ.s		LAB_19C2				; branch if null (last entry)
 2514/     F1A :                        
 2515/     F1A : B03C 002C              	CMP.b		#',',d0				; else compare with ","
 2516/     F1E : 6600 FF38              	BNE		LAB_1904				; if not "," go handle bad input data
 2517/     F22 :                        
 2518/     F22 : 524D                   	ADDQ.w	#1,a5					; else was "," so point to next chr
 2519/     F24 :                        								; got good input data
 2520/     F24 :                        LAB_19C2
 2521/     F24 : 274D 0466              	MOVE.l	a5,Rdptrl(a3)			; save the read pointer for now
 2522/     F28 : 2A5F                   	MOVEA.l	(sp)+,a5				; restore the execute pointer
 2523/     F2A : 6100 0288              	BSR		LAB_GBYT				; scan the memory
 2524/     F2E : 6736                   	BEQ.s		LAB_1A03				; if null go do extra ignored message
 2525/     F30 :                        
 2526/     F30 : 487A FF7A              	PEA		LAB_195B(pc)			; set return address
 2527/     F34 : 6000 0272              	BRA		LAB_1C01				; scan for "," else do syntax error/warm start
 2528/     F38 :                        								; then go INPUT next variable from list
 2529/     F38 :                        
 2530/     F38 :                        								; find next DATA statement or do "Out of Data"
 2531/     F38 :                        								; error
 2532/     F38 :                        LAB_19DD
 2533/     F38 : 6100 FBFE              	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 2534/     F3C :                        								; returns a0 as pointer to [:] or [EOL]
 2535/     F3C : 2A48                   	MOVEA.l	a0,a5					; add index, now = pointer to [EOL]/[EOS]
 2536/     F3E : 524D                   	ADDQ.w	#1,a5					; pointer to next character
 2537/     F40 : B03C 003A              	CMP.b		#':',d0				; was it statement end?
 2538/     F44 : 6712                   	BEQ.s		LAB_19F6				; branch if [:]
 2539/     F46 :                        
 2540/     F46 :                        								; was [EOL] so find next line
 2541/     F46 :                        
 2542/     F46 : 320D                   	MOVE.w	a5,d1					; past pad byte(s)
 2543/     F48 : C27C 0001              	AND.w		#1,d1					; mask odd bit
 2544/     F4C : DAC1                   	ADD.w		d1,a5					; add pointer
 2545/     F4E : 241D                   	MOVE.l	(a5)+,d2				; get next line pointer
 2546/     F50 : 6700 F612              	BEQ		LAB_ODER				; branch if end of program
 2547/     F54 :                        
 2548/     F54 : 275D 045E              	MOVE.l	(a5)+,Dlinel(a3)			; save current DATA line
 2549/     F58 :                        LAB_19F6
 2550/     F58 : 6100 025A              	BSR		LAB_GBYT				; scan memory
 2551/     F5C : B03C 0083              	CMP.b		#TK_DATA,d0				; compare with "DATA" token
 2552/     F60 : 6700 FF78              	BEQ		LAB_1985				; was "DATA" so go do next READ
 2553/     F64 :                        
 2554/     F64 : 60D2                   	BRA.s		LAB_19DD				; go find next statement if not "DATA"
 2555/     F66 :                        
 2556/     F66 :                        ; end of INPUT/READ routine
 2557/     F66 :                        
 2558/     F66 :                        LAB_1A03
 2559/     F66 : 206B 0466              	MOVEA.l	Rdptrl(a3),a0			; get temp READ pointer
 2560/     F6A : 4A2B 05E0              	TST.b		Imode(a3)				; get input mode flag, $00=INPUT, $98=READ
 2561/     F6E : 6A06                   	BPL.s		LAB_1A0E				; branch if INPUT
 2562/     F70 :                        
 2563/     F70 : 2748 0462              	MOVE.l	a0,Dptrl(a3)			; else save temp READ pointer as DATA pointer
 2564/     F74 : 4E75                   	RTS
 2565/     F76 :                        
 2566/     F76 :                        								; we were getting INPUT
 2567/     F76 :                        LAB_1A0E
 2568/     F76 : 4A10                   	TST.b		(a0)					; test next byte
 2569/     F78 : 6602                   	BNE.s		LAB_1A1B				; error if not end of INPUT
 2570/     F7A :                        
 2571/     F7A : 4E75                   	RTS
 2572/     F7C :                        								; user typed too much
 2573/     F7C :                        LAB_1A1B
 2574/     F7C : 41FA 2954              	LEA		LAB_IMSG(pc),a0			; point to extra ignored message
 2575/     F80 : 6000 FE66              	BRA		LAB_18C3				; print null terminated string from memory & RTS
 2576/     F84 :                        
 2577/     F84 :                        
 2578/     F84 :                        ;************************************************************************************
 2579/     F84 :                        ;
 2580/     F84 :                        ; perform NEXT
 2581/     F84 :                        
 2582/     F84 :                        LAB_NEXT
 2583/     F84 : 6610                   	BNE.s		LAB_1A46				; branch if NEXT var
 2584/     F86 :                        
 2585/     F86 : 584F                   	ADDQ.w	#4,sp					; back past return address
 2586/     F88 : 0C57 0081              	CMP.w		#TK_FOR,(sp)			; is FOR token on stack?
 2587/     F8C : 6600 F5E2              	BNE		LAB_NFER				; if not do NEXT without FOR err/warm start
 2588/     F90 :                        
 2589/     F90 : 206F 0002              	MOVEA.l	2(sp),a0				; get stacked FOR variable pointer
 2590/     F94 : 601C                   	BRA.s		LAB_11BD				; branch always (no variable to search for)
 2591/     F96 :                        
 2592/     F96 :                        ; NEXT var
 2593/     F96 :                        
 2594/     F96 :                        LAB_1A46
 2595/     F96 : 6100 042C              	BSR		LAB_GVAR				; get variable address in a0
 2596/     F9A : 584F                   	ADDQ.w	#4,sp					; back past return address
 2597/     F9C : 303C 0081              	MOVE.w	#TK_FOR,d0				; set for FOR token
 2598/     FA0 : 721C                   	MOVEQ		#$1C,d1				; set for FOR use size
 2599/     FA2 : 6002                   	BRA.s		LAB_11A6				; enter loop for next variable search
 2600/     FA4 :                        
 2601/     FA4 :                        LAB_11A5
 2602/     FA4 : DFC1                   	ADDA.l	d1,sp					; add FOR stack use size
 2603/     FA6 :                        LAB_11A6
 2604/     FA6 : B057                   	CMP.w		(sp),d0				; is FOR token on stack?
 2605/     FA8 : 6600 F5C6              	BNE		LAB_NFER				; if not found do NEXT without FOR error and
 2606/     FAC :                        								; warm start
 2607/     FAC :                        
 2608/     FAC :                        								; was FOR token
 2609/     FAC : B1EF 0002              	CMPA.l	2(sp),a0				; compare var pointer with stacked var pointer
 2610/     FB0 : 66F2                   	BNE.s		LAB_11A5				; loop if no match found
 2611/     FB2 :                        
 2612/     FB2 :                        LAB_11BD
 2613/     FB2 : 376F 0006 059C         	MOVE.w	6(sp),FAC2_e(a3)			; get STEP value exponent and sign
 2614/     FB8 : 276F 0008 0598         	MOVE.l	8(sp),FAC2_m(a3)			; get STEP value mantissa
 2615/     FBE :                        
 2616/     FBE : 176F 0012 05B5         	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type
 2617/     FC4 : 6100 021E              	BSR		LAB_1C19				; check type and unpack (a0)
 2618/     FC8 :                        
 2619/     FC8 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
 2620/     FCE : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2621/     FD2 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 2622/     FD6 :                        
 2623/     FD6 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable pointer
 2624/     FDA : 6100 0CBA              	BSR		LAB_ADD				; add STEP value to FOR variable
 2625/     FDE : 176F 0012 05B5         	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type (again)
 2626/     FE4 : 6100 0FB0              	BSR		LAB_PFAC				; pack FAC1 into FOR variable (Lvarpl)
 2627/     FE8 :                        
 2628/     FE8 : 376F 000C 059C         	MOVE.w	12(sp),FAC2_e(a3)			; get TO value exponent and sign
 2629/     FEE : 276F 000E 0598         	MOVE.l	14(sp),FAC2_m(a3)			; get TO value mantissa
 2630/     FF4 :                        
 2631/     FF4 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
 2632/     FFA : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2633/     FFE : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 2634/    1002 :                        
 2635/    1002 : 6100 103C              	BSR		LAB_27FA				; compare FAC1 with FAC2 (TO value)
 2636/    1006 :                        								; returns d0=+1 if FAC1 > FAC2
 2637/    1006 :                        								; returns d0= 0 if FAC1 = FAC2
 2638/    1006 :                        								; returns d0=-1 if FAC1 < FAC2
 2639/    1006 :                        
 2640/    1006 : 322F 0006              	MOVE.w	6(sp),d1				; get STEP value exponent and sign
 2641/    100A : B141                   	EOR.w		d0,d1					; EOR compare result with STEP exponent and sign
 2642/    100C :                        
 2643/    100C : 4A00                   	TST.b		d0					; test for =
 2644/    100E : 6704                   	BEQ.s		LAB_1A90				; branch if = (loop INcomplete)
 2645/    1010 :                        
 2646/    1010 : 4A01                   	TST.b		d1					; test result
 2647/    1012 : 6A0E                   	BPL.s		LAB_1A9B				; branch if > (loop complete)
 2648/    1014 :                        
 2649/    1014 :                        								; loop back and do it all again
 2650/    1014 :                        LAB_1A90
 2651/    1014 : 276F 0014 0452         	MOVE.l	20(sp),Clinel(a3)			; reset current line
 2652/    101A : 2A6F 0018              	MOVE.l	24(sp),a5				; reset BASIC execute pointer
 2653/    101E : 6000 F970              	BRA		LAB_15C2				; go do interpreter inner loop
 2654/    1022 :                        
 2655/    1022 :                        								; loop complete so carry on
 2656/    1022 :                        LAB_1A9B
 2657/    1022 : DEFC 001C              	ADDA.w	#28,sp				; add 28 to dump FOR structure
 2658/    1026 : 6100 018C              	BSR		LAB_GBYT				; scan memory
 2659/    102A : B03C 002C              	CMP.b		#$2C,d0				; compare with ","
 2660/    102E : 6600 F960              	BNE		LAB_15C2				; if not "," go do interpreter inner loop
 2661/    1032 :                        
 2662/    1032 :                        								; was "," so another NEXT variable to do
 2663/    1032 : 6100 017E              	BSR		LAB_IGBY				; else increment & scan memory
 2664/    1036 : 6100 FF5E              	BSR		LAB_1A46				; do NEXT (var)
 2665/    103A :                        
 2666/    103A :                        
 2667/    103A :                        ;************************************************************************************
 2668/    103A :                        ;
 2669/    103A :                        ; evaluate expression & check is numeric, else do type mismatch
 2670/    103A :                        
 2671/    103A :                        LAB_EVNM
 2672/    103A : 6116                   	BSR.s		LAB_EVEX				; evaluate expression
 2673/    103C :                        
 2674/    103C :                        
 2675/    103C :                        ;************************************************************************************
 2676/    103C :                        ;
 2677/    103C :                        ; check if source is numeric, else do type mismatch
 2678/    103C :                        
 2679/    103C :                        LAB_CTNM
 2680/    103C : B040                   	CMP.w		d0,d0					; required type is numeric so clear carry
 2681/    103E :                        
 2682/    103E :                        
 2683/    103E :                        ;************************************************************************************
 2684/    103E :                        ;
 2685/    103E :                        ; type match check, set C for string, clear C for numeric
 2686/    103E :                        
 2687/    103E :                        LAB_CKTM
 2688/    103E : 082B 0007 05B5         	BTST.b	#7,Dtypef(a3)			; test data type flag, don't change carry
 2689/    1044 : 6606                   	BNE.s		LAB_1ABA				; branch if data type is string
 2690/    1046 :                        
 2691/    1046 :                        								; else data type was numeric
 2692/    1046 : 6500 F4F8              	BCS		LAB_TMER				; if required type is string do type mismatch
 2693/    104A :                        								; error
 2694/    104A :                        
 2695/    104A : 4E75                   	RTS
 2696/    104C :                        								; data type was string, now check required type
 2697/    104C :                        LAB_1ABA
 2698/    104C : 6400 F4F2              	BCC		LAB_TMER				; if required type is numeric do type mismatch
 2699/    1050 :                        								; error
 2700/    1050 : 4E75                   	RTS
 2701/    1052 :                        
 2702/    1052 :                        
 2703/    1052 :                        ;************************************************************************************
 2704/    1052 :                        ;
 2705/    1052 :                        ; this routine evaluates any type of expression. first it pushes an end marker so
 2706/    1052 :                        ; it knows when the expression has been evaluated, this is a precedence value of zero.
 2707/    1052 :                        ; next the first value is evaluated, this can be an in line value, either numeric or
 2708/    1052 :                        ; string, a variable or array element of any type, a function or even an expression
 2709/    1052 :                        ; in parenthesis. this value is kept in FAC_1
 2710/    1052 :                        ; after the value is evaluated a test is made on the next BASIC program byte, if it
 2711/    1052 :                        ; is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
 2712/    1052 :                        ; in the comparison evaluation flag. this test loops until no more comparrison operators
 2713/    1052 :                        ; are found or more than one of any type is found. in the last case an error is generated
 2714/    1052 :                        
 2715/    1052 :                        ; evaluate expression
 2716/    1052 :                        
 2717/    1052 :                        LAB_EVEX
 2718/    1052 : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2719/    1054 :                        LAB_EVEZ
 2720/    1054 : 7200                   	MOVEQ		#0,d1					; clear precedence word
 2721/    1056 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
 2722/    105A :                        								; $00=float
 2723/    105A : 601C                   	BRA.s		LAB_1ACD				; enter loop
 2724/    105C :                        
 2725/    105C :                        ; get vector, set up operator then continue evaluation
 2726/    105C :                        
 2727/    105C :                        LAB_1B43
 2728/    105C : 41FA 22CA              	LEA		LAB_OPPT(pc),a0			; point to operator vector table
 2729/    1060 : 3030 1002              	MOVE.w	2(a0,d1.w),d0			; get vector offset
 2730/    1064 : 4870 0000              	PEA		(a0,d0.w)				; push vector
 2731/    1068 :                        
 2732/    1068 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push FAC1 mantissa
 2733/    106C : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push sign and exponent
 2734/    1070 : 1F2B 05E3              	MOVE.b	comp_f(a3),-(sp)			; push comparison evaluation flag
 2735/    1074 :                        
 2736/    1074 : 3230 1000              	MOVE.w	(a0,d1.w),d1			; get precedence value
 2737/    1078 :                        LAB_1ACD
 2738/    1078 : 3F01                   	MOVE.w	d1,-(sp)				; push precedence value
 2739/    107A : 6100 00E4              	BSR		LAB_GVAL				; get value from line
 2740/    107E : 177C 0000 05E3         	MOVE.b	#$00,comp_f(a3)			; clear compare function flag
 2741/    1084 :                        LAB_1ADB
 2742/    1084 : 6100 012E              	BSR		LAB_GBYT				; scan memory
 2743/    1088 :                        LAB_1ADE
 2744/    1088 : 903C 00BC              	SUB.b		#TK_GT,d0				; subtract token for > (lowest compare function)
 2745/    108C : 652A                   	BCS.s		LAB_1AFA				; branch if < TK_GT
 2746/    108E :                        
 2747/    108E : B03C 0003              	CMP.b		#$03,d0				; compare with ">" to "<" tokens
 2748/    1092 : 650A                   	BCS.s		LAB_1AE0				; branch if <= TK_SGN (is compare function)
 2749/    1094 :                        
 2750/    1094 : 4A2B 05E3              	TST.b		comp_f(a3)				; test compare function flag
 2751/    1098 : 6660                   	BNE.s		LAB_1B2A				; branch if compare function
 2752/    109A :                        
 2753/    109A : 6000 0086              	BRA		LAB_1B78				; go do functions
 2754/    109E :                        
 2755/    109E :                        								; was token for > = or < (d0 = 0, 1 or 2)
 2756/    109E :                        LAB_1AE0
 2757/    109E : 7201                   	MOVEQ		#1,d1					; set to 0000 0001
 2758/    10A0 : E121                   	ASL.b		d0,d1					; 1 if >, 2 if =, 4 if <
 2759/    10A2 : 102B 05E3              	MOVE.b	comp_f(a3),d0			; copy old compare function flag
 2760/    10A6 : B32B 05E3              	EOR.b		d1,comp_f(a3)			; EOR in this compare function bit
 2761/    10AA : B02B 05E3              	CMP.b		comp_f(a3),d0			; compare old with new compare function flag
 2762/    10AE : 6400 F4BC              	BCC		LAB_SNER				; if new <= old comp_f do syntax error and warm
 2763/    10B2 :                        								; start, there was more than one <, = or >
 2764/    10B2 : 6100 00FE              	BSR		LAB_IGBY				; increment & scan memory
 2765/    10B6 : 60D0                   	BRA.s		LAB_1ADE				; go do next character
 2766/    10B8 :                        
 2767/    10B8 :                        								; token is < ">" or > "<" tokens
 2768/    10B8 :                        LAB_1AFA
 2769/    10B8 : 4A2B 05E3              	TST.b		comp_f(a3)				; test compare function flag
 2770/    10BC : 663C                   	BNE.s		LAB_1B2A				; branch if compare function
 2771/    10BE :                        
 2772/    10BE :                        								; was < TK_GT so is operator or lower
 2773/    10BE : D03C 000A              	ADD.b	#(TK_GT-TK_PLUS),d0			; add # of operators (+ -	; / ^ AND OR EOR)
 2774/    10C2 : 645E                   	BCC.s		LAB_1B78				; branch if < + operator
 2775/    10C4 :                        
 2776/    10C4 : 6608                   	BNE.s		LAB_1B0B				; branch if not + token
 2777/    10C6 :                        
 2778/    10C6 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2779/    10CA :                        								; $00=float
 2780/    10CA : 6B00 087E              	BMI		LAB_224D				; type is string & token was +
 2781/    10CE :                        
 2782/    10CE :                        LAB_1B0B
 2783/    10CE : 7200                   	MOVEQ		#0,d1					; clear longword
 2784/    10D0 : D000                   	ADD.b		d0,d0					; *2
 2785/    10D2 : D000                   	ADD.b		d0,d0					; *4
 2786/    10D4 : 1200                   	MOVE.b	d0,d1					; copy to index
 2787/    10D6 :                        LAB_1B13
 2788/    10D6 : 301F                   	MOVE.w	(sp)+,d0				; pull previous precedence
 2789/    10D8 : 41FA 224E              	LEA		LAB_OPPT(pc),a0			; set pointer to operator table
 2790/    10DC : B070 1000              	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
 2791/    10E0 : 6446                   	BCC.s		LAB_1B7D				; branch if previous precedence (d0) >=
 2792/    10E2 :                        
 2793/    10E2 : 6100 FF58              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2794/    10E6 :                        LAB_1B1C
 2795/    10E6 : 3F00                   	MOVE.w	d0,-(sp)				; save precedence
 2796/    10E8 :                        LAB_1B1D
 2797/    10E8 : 6100 FF72              	BSR		LAB_1B43				; get vector, set-up operator and continue
 2798/    10EC :                        								; evaluation
 2799/    10EC : 301F                   	MOVE.w	(sp)+,d0				; restore precedence
 2800/    10EE : 222B 05D8              	MOVE.l	prstk(a3),d1			; get stacked function pointer
 2801/    10F2 : 6A22                   	BPL.s		LAB_1B3C				; branch if stacked values
 2802/    10F4 :                        
 2803/    10F4 : 3000                   	MOVE.w	d0,d0					; copy precedence (set flags)
 2804/    10F6 : 672E                   	BEQ.s		LAB_1B7B				; exit if done
 2805/    10F8 :                        
 2806/    10F8 : 603C                   	BRA.s		LAB_1B86				; else pop FAC2 & return (do function)
 2807/    10FA :                        
 2808/    10FA :                        								; was compare function (< = >)
 2809/    10FA :                        LAB_1B2A
 2810/    10FA : 102B 05B5              	MOVE.b	Dtypef(a3),d0			; get data type flag
 2811/    10FE : 122B 05E3              	MOVE.b	comp_f(a3),d1			; get compare function flag
 2812/    1102 : D000                   	ADD.b		d0,d0					; string bit flag into X bit
 2813/    1104 : D301                   	ADDX.b	d1,d1					; shift compare function flag
 2814/    1106 :                        
 2815/    1106 : 177C 0000 05B5         	MOVE.b	#0,Dtypef(a3)			; clear data type flag, $00=float
 2816/    110C : 1741 05E3              	MOVE.b	d1,comp_f(a3)			; save new compare function flag
 2817/    1110 : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2818/    1112 : 7230                   	MOVEQ		#(TK_LT-TK_PLUS)*4,d1		; set offset to last operator entry
 2819/    1114 : 60C0                   	BRA.s		LAB_1B13				; branch always
 2820/    1116 :                        
 2821/    1116 :                        LAB_1B3C
 2822/    1116 : 41FA 2210              	LEA		LAB_OPPT(pc),a0			; point to function vector table
 2823/    111A : B070 1000              	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
 2824/    111E : 6416                   	BCC.s		LAB_1B86				; branch if d0 >=, pop FAC2 & return
 2825/    1120 :                        
 2826/    1120 : 60C4                   	BRA.s		LAB_1B1C				; branch always
 2827/    1122 :                        
 2828/    1122 :                        ; do functions
 2829/    1122 :                        
 2830/    1122 :                        LAB_1B78
 2831/    1122 : 72FF                   	MOVEQ		#-1,d1				; flag all done
 2832/    1124 : 301F                   	MOVE.w	(sp)+,d0				; pull precedence word
 2833/    1126 :                        LAB_1B7B
 2834/    1126 : 6732                   	BEQ.s		LAB_1B9D				; exit if done
 2835/    1128 :                        
 2836/    1128 :                        LAB_1B7D
 2837/    1128 : B07C 0064              	CMP.w		#$64,d0				; compare previous precedence with $64
 2838/    112C : 6704                   	BEQ.s		LAB_1B84				; branch if was $64 (< function can be string)
 2839/    112E :                        
 2840/    112E : 6100 FF0C              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2841/    1132 :                        LAB_1B84
 2842/    1132 : 2741 05D8              	MOVE.l	d1,prstk(a3)			; save current operator index
 2843/    1136 :                        
 2844/    1136 :                        								; pop FAC2 & return
 2845/    1136 :                        LAB_1B86
 2846/    1136 : 101F                   	MOVE.b	(sp)+,d0				; pop comparison evaluation flag
 2847/    1138 : 1200                   	MOVE.b	d0,d1					; copy comparison evaluation flag
 2848/    113A : E208                   	LSR.b		#1,d0					; shift out comparison evaluation lowest bit
 2849/    113C : 1740 05E1              	MOVE.b	d0,Cflag(a3)			; save comparison evaluation flag
 2850/    1140 : 375F 059C              	MOVE.w	(sp)+,FAC2_e(a3)			; pop exponent and sign
 2851/    1144 : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
 2852/    1148 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign
 2853/    114E : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2854/    1152 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR FAC1 sign and set sign compare
 2855/    1156 :                        
 2856/    1156 : E209                   	LSR.b		#1,d1					; type bit into X and C
 2857/    1158 : 4E75                   	RTS
 2858/    115A :                        
 2859/    115A :                        LAB_1B9D
 2860/    115A : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 2861/    115E : 4E75                   	RTS
 2862/    1160 :                        
 2863/    1160 :                        
 2864/    1160 :                        ;************************************************************************************
 2865/    1160 :                        ;
 2866/    1160 :                        ; get a value from the BASIC line
 2867/    1160 :                        
 2868/    1160 :                        LAB_GVAL
 2869/    1160 : 6150                   	BSR.s		LAB_IGBY				; increment & scan memory
 2870/    1162 : 6500 1B4C              	BCS		LAB_2887				; if numeric get FAC1 from string & return
 2871/    1166 :                        
 2872/    1166 : 4A00                   	TST.b		d0					; test byte
 2873/    1168 : 6B00 0090              	BMI		LAB_1BD0				; if -ve go test token values
 2874/    116C :                        
 2875/    116C :                        								; else it is either a string, number, variable
 2876/    116C :                        								; or (<expr>)
 2877/    116C : B03C 0024              	CMP.b		#'$',d0				; compare with "$"
 2878/    1170 : 6700 1B3E              	BEQ		LAB_2887				; if "$" get hex number from string & return
 2879/    1174 :                        
 2880/    1174 : B03C 0025              	CMP.b		#'%',d0				; else compare with "%"
 2881/    1178 : 6700 1B36              	BEQ		LAB_2887				; if "%" get binary number from string & return
 2882/    117C :                        
 2883/    117C : B03C 002E              	CMP.b		#$2E,d0				; compare with "."
 2884/    1180 : 6700 1B2E              	BEQ		LAB_2887				; if so get FAC1 from string and return
 2885/    1184 :                        								; (e.g. .123)
 2886/    1184 :                        
 2887/    1184 :                        								; wasn't a number so ...
 2888/    1184 : B03C 0022              	CMP.b		#$22,d0				; compare with "
 2889/    1188 : 660C                   	BNE.s		LAB_1BF3				; if not open quote it must be a variable or
 2890/    118A :                        								; open bracket
 2891/    118A :                        
 2892/    118A :                        								; was open quote so get the enclosed string
 2893/    118A :                        
 2894/    118A :                        ; print "..." string to string stack
 2895/    118A :                        
 2896/    118A :                        LAB_1BC1
 2897/    118A : 101D                   	MOVE.b	(a5)+,d0				; increment BASIC execute pointer (past ")
 2898/    118C :                        								; fastest/shortest method
 2899/    118C : 204D                   	MOVEA.l	a5,a0					; copy basic execute pointer (string start)
 2900/    118E : 6100 063A              	BSR		LAB_20AE				; print " terminated string to stack
 2901/    1192 : 2A4A                   	MOVEA.l	a2,a5					; restore BASIC execute pointer from temp
 2902/    1194 : 4E75                   	RTS
 2903/    1196 :                        
 2904/    1196 :                        ; get value from line .. continued
 2905/    1196 :                        								; wasn't any sort of number so ...
 2906/    1196 :                        LAB_1BF3
 2907/    1196 : B03C 0028              	CMP.b		#'(',d0				; compare with "("
 2908/    119A : 6644                   	BNE.s		LAB_1C18				; if not "(" get (var) and return value in FAC1
 2909/    119C :                        								; and $ flag
 2910/    119C :                        
 2911/    119C :                        
 2912/    119C :                        ;************************************************************************************
 2913/    119C :                        ;
 2914/    119C :                        ; evaluate expression within parentheses
 2915/    119C :                        
 2916/    119C :                        LAB_1BF7
 2917/    119C : 6100 FEB6              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 2918/    11A0 :                        
 2919/    11A0 :                        
 2920/    11A0 :                        ;************************************************************************************
 2921/    11A0 :                        ;
 2922/    11A0 :                        ; all the 'scan for' routines return the character after the sought character
 2923/    11A0 :                        
 2924/    11A0 :                        ; scan for ")", else do syntax error, then warm start
 2925/    11A0 :                        
 2926/    11A0 :                        LAB_1BFB
 2927/    11A0 : 7029                   	MOVEQ		#$29,d0				; load d0 with ")"
 2928/    11A2 : 6006                   	BRA.s		LAB_SCCA
 2929/    11A4 :                        
 2930/    11A4 :                        
 2931/    11A4 :                        ;************************************************************************************
 2932/    11A4 :                        ;
 2933/    11A4 :                        ; scan for "," and get byte, else do Syntax error then warm start
 2934/    11A4 :                        
 2935/    11A4 :                        LAB_SCGB
 2936/    11A4 : 487A 0978              	PEA		LAB_GTBY(pc)			; return address is to get byte parameter
 2937/    11A8 :                        
 2938/    11A8 :                        
 2939/    11A8 :                        ;************************************************************************************
 2940/    11A8 :                        ;
 2941/    11A8 :                        ; scan for ",", else do syntax error, then warm start
 2942/    11A8 :                        
 2943/    11A8 :                        LAB_1C01
 2944/    11A8 : 702C                   	MOVEQ		#$2C,d0				; load d0 with ","
 2945/    11AA :                        
 2946/    11AA :                        
 2947/    11AA :                        ;************************************************************************************
 2948/    11AA :                        ;
 2949/    11AA :                        ; scan for CHR$(d0) , else do syntax error, then warm start
 2950/    11AA :                        
 2951/    11AA :                        LAB_SCCA
 2952/    11AA : B01D                   	CMP.b		(a5)+,d0				; check next byte is = d0
 2953/    11AC : 6706                   	BEQ.s		LAB_GBYT				; if so go get next
 2954/    11AE :                        
 2955/    11AE : 6000 F3BC              	BRA		LAB_SNER				; else do syntax error/warm start
 2956/    11B2 :                        
 2957/    11B2 :                        
 2958/    11B2 :                        ;************************************************************************************
 2959/    11B2 :                        ;
 2960/    11B2 :                        ; BASIC increment and scan memory routine
 2961/    11B2 :                        
 2962/    11B2 :                        LAB_IGBY
 2963/    11B2 : 101D                   	MOVE.b	(a5)+,d0				; get byte & increment pointer
 2964/    11B4 :                        
 2965/    11B4 :                        ; scan memory routine, exit with Cb = 1 if numeric character
 2966/    11B4 :                        ; also skips any spaces encountered
 2967/    11B4 :                        
 2968/    11B4 :                        LAB_GBYT
 2969/    11B4 : 1015                   	MOVE.b	(a5),d0				; get byte
 2970/    11B6 :                        
 2971/    11B6 : B03C 0020              	CMP.b		#$20,d0				; compare with " "
 2972/    11BA : 67F6                   	BEQ.s		LAB_IGBY				; if " " go do next
 2973/    11BC :                        
 2974/    11BC :                        ; test current BASIC byte, exit with Cb = 1 if numeric character
 2975/    11BC :                        
 2976/    11BC : B03C 00A9              	CMP.b		#TK_ELSE,d0				; compare with the token for ELSE
 2977/    11C0 : 640E                   	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
 2978/    11C2 :                        
 2979/    11C2 : B03C 003A              	CMP.b		#$3A,d0				; compare with ":"
 2980/    11C6 : 6408                   	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
 2981/    11C8 :                        
 2982/    11C8 : 1C3C 00D0              	MOVE.b		#$D0,d6				; set -"0"
 2983/    11CC : D006                   	ADD.b		d6,d0					; add -"0"
 2984/    11CE : 9006                   	SUB.b		d6,d0					; subtract -"0"
 2985/    11D0 :                        RTS_001							; carry set if byte = "0"-"9"
 2986/    11D0 : 4E75                   	RTS
 2987/    11D2 :                        
 2988/    11D2 :                        
 2989/    11D2 :                        ;************************************************************************************
 2990/    11D2 :                        ;
 2991/    11D2 :                        ; set-up for - operator
 2992/    11D2 :                        
 2993/    11D2 :                        LAB_1C11
 2994/    11D2 : 6100 FE68              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2995/    11D6 : 7228                   	MOVEQ	#(TK_GT-TK_PLUS)*4,d1			; set offset from base to - operator
 2996/    11D8 :                        LAB_1C13
 2997/    11D8 : 4FEF 0004              	LEA		4(sp),sp				; dump GVAL return address
 2998/    11DC : 6000 FF0A              	BRA		LAB_1B1D				; continue evaluating expression
 2999/    11E0 :                        
 3000/    11E0 :                        
 3001/    11E0 :                        ;************************************************************************************
 3002/    11E0 :                        ;
 3003/    11E0 :                        ; variable name set-up
 3004/    11E0 :                        ; get (var), return value in FAC_1 & data type flag
 3005/    11E0 :                        
 3006/    11E0 :                        LAB_1C18
 3007/    11E0 : 6100 01E2              	BSR		LAB_GVAR				; get variable address in a0
 3008/    11E4 :                        
 3009/    11E4 :                        ; return existing variable value
 3010/    11E4 :                        
 3011/    11E4 :                        LAB_1C19
 3012/    11E4 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 3013/    11E8 :                        								; $00=float
 3014/    11E8 : 6700 0D90              	BEQ		LAB_UFAC				; if float unpack memory (a0) into FAC1 and
 3015/    11EC :                        								; return
 3016/    11EC :                        
 3017/    11EC : 6A06                   	BPL.s		LAB_1C1A				; if integer unpack memory (a0) into FAC1
 3018/    11EE :                        								; and return
 3019/    11EE :                        
 3020/    11EE : 2748 0590              	MOVE.l	a0,FAC1_m(a3)			; else save descriptor pointer in FAC1
 3021/    11F2 : 4E75                   	RTS
 3022/    11F4 :                        
 3023/    11F4 :                        LAB_1C1A
 3024/    11F4 : 2010                   	MOVE.l	(a0),d0				; get integer value
 3025/    11F6 : 6000 04BC              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 3026/    11FA :                        
 3027/    11FA :                        
 3028/    11FA :                        ;************************************************************************************
 3029/    11FA :                        ;
 3030/    11FA :                        ; get value from line .. continued
 3031/    11FA :                        ; do tokens
 3032/    11FA :                        
 3033/    11FA :                        LAB_1BD0
 3034/    11FA : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 3035/    11FE : 67D2                   	BEQ.s		LAB_1C11				; branch if - token (do set-up for - operator)
 3036/    1200 :                        
 3037/    1200 :                        								; wasn't -123 so ...
 3038/    1200 : B03C 00B2              	CMP.b		#TK_PLUS,d0				; compare with token for +
 3039/    1204 : 6700 FF5A              	BEQ		LAB_GVAL				; branch if + token (+n = n so ignore leading +)
 3040/    1208 :                        
 3041/    1208 : B03C 00AE              	CMP.b		#TK_NOT,d0				; compare with token for NOT
 3042/    120C : 6606                   	BNE.s		LAB_1BE7				; branch if not token for NOT
 3043/    120E :                        
 3044/    120E :                        								; was NOT token
 3045/    120E : 323C 002C              	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1		; offset to NOT function
 3046/    1212 : 60C4                   	BRA.s		LAB_1C13				; do set-up for function then execute
 3047/    1214 :                        
 3048/    1214 :                        								; wasn't +, - or NOT so ...
 3049/    1214 :                        LAB_1BE7
 3050/    1214 : B03C 00AB              	CMP.b		#TK_FN,d0				; compare with token for FN
 3051/    1218 : 6700 0514              	BEQ		LAB_201E				; if FN go evaluate FNx
 3052/    121C :                        
 3053/    121C :                        								; wasn't +, -, NOT or FN so ...
 3054/    121C : 903C 00BF              	SUB.b		#TK_SGN,d0				; compare with token for SGN & normalise
 3055/    1220 : 6500 F34A              	BCS		LAB_SNER				; if < SGN token then do syntax error
 3056/    1224 :                        
 3057/    1224 :                        ; get value from line .. continued
 3058/    1224 :                        ; only functions left so set up function references
 3059/    1224 :                        
 3060/    1224 :                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
 3061/    1224 :                        ; to process function calls. now the function vector is computed and pushed on the stack
 3062/    1224 :                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
 3063/    1224 :                        ; is calculated and the routine called, if not this routine just does RTS. whichever
 3064/    1224 :                        ; happens the RTS at the end of this routine, or the preprocess routine calls, the
 3065/    1224 :                        ; function code
 3066/    1224 :                        
 3067/    1224 :                        ; this also removes some less than elegant code that was used to bypass type checking
 3068/    1224 :                        ; for functions that returned strings
 3069/    1224 :                        
 3070/    1224 : C07C 007F              	AND.w		#$7F,d0				; mask byte
 3071/    1228 : D040                   	ADD.w		d0,d0					; *2 (2 bytes per function offset)
 3072/    122A :                        
 3073/    122A : 41FA 20B0              	LEA		LAB_FTBL(pc),a0			; pointer to functions vector table
 3074/    122E : 3230 0000              	MOVE.w	(a0,d0.w),d1			; get function vector offset
 3075/    1232 : 4870 1000              	PEA		(a0,d1.w)				; push function vector
 3076/    1236 :                        
 3077/    1236 : 41FA 2058              	LEA		LAB_FTPP(pc),a0			; pointer to functions preprocess vector table
 3078/    123A : 3030 0000              	MOVE.w	(a0,d0.w),d0			; get function preprocess vector offset
 3079/    123E : 6712                   	BEQ.s		LAB_1C2A				; no preprocess vector so go do function
 3080/    1240 :                        
 3081/    1240 : 41F0 0000              	LEA		(a0,d0.w),a0			; get function preprocess vector
 3082/    1244 : 4ED0                   	JMP		(a0)					; go do preprocess routine then function
 3083/    1246 :                        
 3084/    1246 :                        
 3085/    1246 :                        ;************************************************************************************
 3086/    1246 :                        ;
 3087/    1246 :                        ; process string expression in parenthesis
 3088/    1246 :                        
 3089/    1246 :                        LAB_PPFS
 3090/    1246 : 6100 FF54              	BSR		LAB_1BF7				; process expression in parenthesis
 3091/    124A : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 3092/    124E : 6A00 F2F0              	BPL		LAB_TMER				; if numeric do Type missmatch Error/warm start
 3093/    1252 :                        
 3094/    1252 :                        LAB_1C2A
 3095/    1252 : 4E75                   	RTS							; else do function
 3096/    1254 :                        
 3097/    1254 :                        
 3098/    1254 :                        ;************************************************************************************
 3099/    1254 :                        ;
 3100/    1254 :                        ; process numeric expression in parenthesis
 3101/    1254 :                        
 3102/    1254 :                        LAB_PPFN
 3103/    1254 : 6100 FF46              	BSR		LAB_1BF7				; process expression in parenthesis
 3104/    1258 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 3105/    125C : 6B00 F2E2              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 3106/    1260 :                        
 3107/    1260 : 4E75                   	RTS							; else do function
 3108/    1262 :                        
 3109/    1262 :                        
 3110/    1262 :                        ;************************************************************************************
 3111/    1262 :                        ;
 3112/    1262 :                        ; set numeric data type and increment BASIC execute pointer
 3113/    1262 :                        
 3114/    1262 :                        LAB_PPBI
 3115/    1262 : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type flag, $00=float
 3116/    1268 : 101D                   	MOVE.b	(a5)+,d0				; get next BASIC byte
 3117/    126A : 4E75                   	RTS							; do function
 3118/    126C :                        
 3119/    126C :                        
 3120/    126C :                        ;************************************************************************************
 3121/    126C :                        ;
 3122/    126C :                        ; process string for LEFT$, RIGHT$ or MID$
 3123/    126C :                        
 3124/    126C :                        LAB_LRMS
 3125/    126C : 6100 FDE6              	BSR		LAB_EVEZ				; evaluate (should be string) expression
 3126/    1270 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 3127/    1274 : 6A00 F2CA              	BPL		LAB_TMER				; if type is not string do type mismatch error
 3128/    1278 :                        
 3129/    1278 : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 3130/    127A : B43C 002C              	CMP.b		#',',d2				; compare with comma
 3131/    127E : 6600 F2EC              	BNE		LAB_SNER				; if not "," go do syntax error/warm start
 3132/    1282 :                        
 3133/    1282 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; save descriptor pointer
 3134/    1286 : 6100 08AC              	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
 3135/    128A : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer
 3136/    128C : 4E75                   	RTS							; do function
 3137/    128E :                        
 3138/    128E :                        
 3139/    128E :                        ;************************************************************************************
 3140/    128E :                        ;
 3141/    128E :                        ; process numeric expression(s) for BIN$ or HEX$
 3142/    128E :                        
 3143/    128E :                        LAB_BHSS
 3144/    128E : 6100 FDC4              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 3145/    1292 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 3146/    1296 : 6B00 F2A8              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 3147/    129A :                        
 3148/    129A : 6100 0DD0              	BSR		LAB_2831				; convert FAC1 floating to fixed
 3149/    129E :                        								; result in d0 and Itemp
 3150/    129E : 7200                   	MOVEQ		#0,d1					; set default to no leading "0"s
 3151/    12A0 : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 3152/    12A2 : B43C 002C              	CMP.b		#',',d2				; compare with comma
 3153/    12A6 : 660C                   	BNE.s		LAB_BHCB				; if not "," go check close bracket
 3154/    12A8 :                        
 3155/    12A8 : 2F00                   	MOVE.l	d0,-(sp)				; copy number to stack
 3156/    12AA : 6100 0872              	BSR		LAB_GTBY				; get byte value
 3157/    12AE : 2200                   	MOVE.l	d0,d1					; copy leading 0s #
 3158/    12B0 : 201F                   	MOVE.l	(sp)+,d0				; restore number from stack
 3159/    12B2 : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 3160/    12B4 :                        LAB_BHCB
 3161/    12B4 : B43C 0029              	CMP.b		#')',d2				; compare with close bracket
 3162/    12B8 : 6600 F2B2              	BNE		LAB_SNER				; if not ")" do Syntax Error/warm start
 3163/    12BC :                        
 3164/    12BC : 4E75                   	RTS							; go do function
 3165/    12BE :                        
 3166/    12BE :                        
 3167/    12BE :                        ;************************************************************************************
 3168/    12BE :                        ;
 3169/    12BE :                        ; perform EOR
 3170/    12BE :                        
 3171/    12BE :                        LAB_EOR
 3172/    12BE : 6116                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 3173/    12C0 :                        								; first in d0, and Itemp, second in d2
 3174/    12C0 : B580                   	EOR.l		d2,d0					; EOR values
 3175/    12C2 : 6000 03F0              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3176/    12C6 :                        
 3177/    12C6 :                        
 3178/    12C6 :                        ;************************************************************************************
 3179/    12C6 :                        ;
 3180/    12C6 :                        ; perform OR
 3181/    12C6 :                        
 3182/    12C6 :                        LAB_OR
 3183/    12C6 : 610E                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 3184/    12C8 :                        								; first in d0, and Itemp, second in d2
 3185/    12C8 : 8082                   	OR.l		d2,d0					; do OR
 3186/    12CA : 6000 03E8              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3187/    12CE :                        
 3188/    12CE :                        
 3189/    12CE :                        ;************************************************************************************
 3190/    12CE :                        ;
 3191/    12CE :                        ; perform AND
 3192/    12CE :                        
 3193/    12CE :                        LAB_AND
 3194/    12CE : 6106                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 3195/    12D0 :                        								; first in d0, and Itemp, second in d2
 3196/    12D0 : C082                   	AND.l		d2,d0					; do AND
 3197/    12D2 : 6000 03E0              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3198/    12D6 :                        
 3199/    12D6 :                        
 3200/    12D6 :                        ;************************************************************************************
 3201/    12D6 :                        ;
 3202/    12D6 :                        ; get two values for OR, AND, EOR
 3203/    12D6 :                        ; first in d0, second in d2
 3204/    12D6 :                        
 3205/    12D6 :                        GetFirst
 3206/    12D6 : 6100 0228              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 3207/    12DA :                        								; result in d0 and Itemp
 3208/    12DA : 2400                   	MOVE.l	d0,d2					; copy second value
 3209/    12DC : 6100 0CF6              	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
 3210/    12E0 :                        								; expression
 3211/    12E0 : 6000 021E              	BRA		LAB_EVIR				; evaluate integer expression (no sign check)
 3212/    12E4 :                        								; result in d0 and Itemp & return
 3213/    12E4 :                        
 3214/    12E4 :                        
 3215/    12E4 :                        ;************************************************************************************
 3216/    12E4 :                        ;
 3217/    12E4 :                        ; perform NOT
 3218/    12E4 :                        
 3219/    12E4 :                        LAB_EQUAL
 3220/    12E4 : 6100 021A              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 3221/    12E8 :                        								; result in d0 and Itemp
 3222/    12E8 : 4680                   	NOT.l		d0					; bitwise invert
 3223/    12EA : 6000 03C8              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3224/    12EE :                        
 3225/    12EE :                        
 3226/    12EE :                        ;************************************************************************************
 3227/    12EE :                        ;
 3228/    12EE :                        ; perform comparisons
 3229/    12EE :                        ; do < compare
 3230/    12EE :                        
 3231/    12EE :                        LAB_LTHAN
 3232/    12EE : 6100 FD4E              	BSR		LAB_CKTM				; type match check, set C for string
 3233/    12F2 : 6506                   	BCS.s		LAB_1CAE				; branch if string
 3234/    12F4 :                        
 3235/    12F4 :                        								; do numeric < compare
 3236/    12F4 : 6100 0D4A              	BSR		LAB_27FA				; compare FAC1 with FAC2
 3237/    12F8 :                        								; returns d0=+1 if FAC1 > FAC2
 3238/    12F8 :                        								; returns d0= 0 if FAC1 = FAC2
 3239/    12F8 :                        								; returns d0=-1 if FAC1 < FAC2
 3240/    12F8 : 6042                   	BRA.s		LAB_1CF2				; process result
 3241/    12FA :                        
 3242/    12FA :                        								; do string < compare
 3243/    12FA :                        LAB_1CAE
 3244/    12FA : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
 3245/    1300 :                        								; $00=float
 3246/    1300 : 6100 06BC              	BSR		LAB_22B6				; pop string off descriptor stack, or from top
 3247/    1304 :                        								; of string space returns d0 = length,
 3248/    1304 :                        								; a0 = pointer
 3249/    1304 : 2248                   	MOVEA.l	a0,a1					; copy string 2 pointer
 3250/    1306 : 2200                   	MOVE.l	d0,d1					; copy string 2 length
 3251/    1308 : 206B 0598              	MOVEA.l	FAC2_m(a3),a0			; get string 1 descriptor pointer
 3252/    130C : 6100 06B4              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 3253/    1310 :                        								; d0 = length, a0 = pointer
 3254/    1310 : 2400                   	MOVE.l	d0,d2					; copy length
 3255/    1312 : 6604                   	BNE.s		LAB_1CB5				; branch if not null string
 3256/    1314 :                        
 3257/    1314 : 4A81                   	TST.l		d1					; test if string 2 is null also
 3258/    1316 : 6724                   	BEQ.s		LAB_1CF2				; if so do string 1 = string 2
 3259/    1318 :                        
 3260/    1318 :                        LAB_1CB5
 3261/    1318 : 9481                   	SUB.l		d1,d2					; subtract string 2 length
 3262/    131A : 670C                   	BEQ.s		LAB_1CD5				; branch if strings = length
 3263/    131C :                        
 3264/    131C : 6504                   	BCS.s		LAB_1CD4				; branch if string 1 < string 2
 3265/    131E :                        
 3266/    131E : 70FF                   	MOVEQ		#-1,d0				; set for string 1 > string 2
 3267/    1320 : 6008                   	BRA.s		LAB_1CD6				; go do character comapare
 3268/    1322 :                        
 3269/    1322 :                        LAB_1CD4
 3270/    1322 : 2200                   	MOVE.l	d0,d1					; string 1 length is compare length
 3271/    1324 : 7001                   	MOVEQ		#1,d0					; and set for string 1 < string 2
 3272/    1326 : 6002                   	BRA.s		LAB_1CD6				; go do character comapare
 3273/    1328 :                        
 3274/    1328 :                        LAB_1CD5
 3275/    1328 : 2002                   	MOVE.l	d2,d0					; set for string 1 = string 2
 3276/    132A :                        LAB_1CD6
 3277/    132A : 5381                   	SUBQ.l	#1,d1					; adjust length for DBcc loop
 3278/    132C :                        
 3279/    132C :                        								; d1 is length to compare, d0 is <=> for length
 3280/    132C :                        								; a0 is string 1 pointer, a1 is string 2 pointer
 3281/    132C :                        LAB_1CE6
 3282/    132C : B308                   	CMPM.b	(a0)+,(a1)+				; compare string bytes (1 with 2)
 3283/    132E : 56C9 FFFC              	DBNE		d1,LAB_1CE6				; loop if same and not end yet
 3284/    1332 :                        
 3285/    1332 : 6708                   	BEQ.s		LAB_1CF2				; if = to here, then go use length compare
 3286/    1334 :                        
 3287/    1334 : 6404                   	BCC.s		LAB_1CDB				; else branch if string 1 > string 2
 3288/    1336 :                        
 3289/    1336 : 70FF                   	MOVEQ		#-1,d0				; else set for string 1 < string 2
 3290/    1338 : 6002                   	BRA.s		LAB_1CF2				; go set result
 3291/    133A :                        
 3292/    133A :                        LAB_1CDB
 3293/    133A : 7001                   	MOVEQ		#1,d0					; and set for string 1 > string 2
 3294/    133C :                        
 3295/    133C :                        LAB_1CF2
 3296/    133C : 5200                   	ADDQ.b	#1,d0					; make result 0, 1 or 2
 3297/    133E : 1200                   	MOVE.b	d0,d1					; copy to d1
 3298/    1340 : 7001                   	MOVEQ		#1,d0					; set d0 longword
 3299/    1342 : E338                   	ROL.b		d1,d0					; make 1, 2 or 4 (result = flag bit)
 3300/    1344 : C02B 05E1              	AND.b		Cflag(a3),d0			; AND with comparison evaluation flag
 3301/    1348 : 6700 0CDE              	BEQ		LAB_27DB				; exit if not a wanted result (i.e. false)
 3302/    134C :                        
 3303/    134C : 70FF                   	MOVEQ		#-1,d0				; else set -1 (true)
 3304/    134E : 6000 0CD8              	BRA		LAB_27DB				; save d0 as integer & return
 3305/    1352 :                        
 3306/    1352 :                        
 3307/    1352 :                        LAB_1CFE
 3308/    1352 : 6100 FE54              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 3309/    1356 :                        
 3310/    1356 :                        
 3311/    1356 :                        ;************************************************************************************
 3312/    1356 :                        ;
 3313/    1356 :                        ; perform DIM
 3314/    1356 :                        
 3315/    1356 :                        LAB_DIM
 3316/    1356 : 72FF                   	MOVEQ		#-1,d1				; set "DIM" flag
 3317/    1358 : 6170                   	BSR.s		LAB_1D10				; search for or dimension a variable
 3318/    135A : 6100 FE58              	BSR		LAB_GBYT				; scan memory
 3319/    135E : 66F2                   	BNE.s		LAB_1CFE				; loop and scan for "," if not null
 3320/    1360 :                        
 3321/    1360 : 4E75                   	RTS
 3322/    1362 :                        
 3323/    1362 :                        
 3324/    1362 :                        ;************************************************************************************
 3325/    1362 :                        ;
 3326/    1362 :                        ; perform << (left shift)
 3327/    1362 :                        
 3328/    1362 :                        LAB_LSHIFT
 3329/    1362 : 612E                   	BSR.s		GetPair				; get an integer and byte pair
 3330/    1364 :                        								; byte is in d2, integer is in d0 and Itemp
 3331/    1364 : 6708                   	BEQ.s		NoShift				; branch if byte zero
 3332/    1366 :                        
 3333/    1366 : B43C 0020              	CMP.b		#$20,d2				; compare bit count with 32d
 3334/    136A : 6420                   	BCC.s		TooBig				; branch if >=
 3335/    136C :                        
 3336/    136C : E5A0                   	ASL.l		d2,d0					; shift longword
 3337/    136E :                        NoShift
 3338/    136E : 6000 0344              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3339/    1372 :                        
 3340/    1372 :                        
 3341/    1372 :                        ;************************************************************************************
 3342/    1372 :                        ;
 3343/    1372 :                        ; perform >> (right shift)
 3344/    1372 :                        
 3345/    1372 :                        LAB_RSHIFT
 3346/    1372 : 611E                   	BSR.s		GetPair				; get an integer and byte pair
 3347/    1374 :                        								; byte is in d2, integer is in d0 and Itemp
 3348/    1374 : 67F8                   	BEQ.s		NoShift				; branch if byte zero
 3349/    1376 :                        
 3350/    1376 : B43C 0020              	CMP.b		#$20,d2				; compare bit count with 32d
 3351/    137A : 650A                   	BCS.s		Not2Big				; branch if >= (return shift)
 3352/    137C :                        
 3353/    137C : 4A80                   	TST.l		d0					; test sign bit
 3354/    137E : 6A0C                   	BPL.s		TooBig				; branch if +ve
 3355/    1380 :                        
 3356/    1380 : 70FF                   	MOVEQ		#-1,d0				; set longword
 3357/    1382 : 6000 0330              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3358/    1386 :                        
 3359/    1386 :                        Not2Big
 3360/    1386 : E4A0                   	ASR.l		d2,d0					; shift longword
 3361/    1388 : 6000 032A              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3362/    138C :                        
 3363/    138C :                        TooBig
 3364/    138C : 7000                   	MOVEQ		#0,d0					; clear longword
 3365/    138E : 6000 0324              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3366/    1392 :                        
 3367/    1392 :                        
 3368/    1392 :                        ;************************************************************************************
 3369/    1392 :                        ;
 3370/    1392 :                        ; get an integer and byte pair
 3371/    1392 :                        ; byte is in d2, integer is in d0 and Itemp
 3372/    1392 :                        
 3373/    1392 :                        GetPair
 3374/    1392 : 6100 078E              	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
 3375/    1396 :                        								; Itemp
 3376/    1396 : 1400                   	MOVE.b	d0,d2					; save it
 3377/    1398 : 6100 0C3A              	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
 3378/    139C :                        								; expression
 3379/    139C : 6100 0162              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 3380/    13A0 :                        								; result in d0 and Itemp
 3381/    13A0 : 4A02                   	TST.b		d2					; test byte value
 3382/    13A2 : 4E75                   	RTS
 3383/    13A4 :                        
 3384/    13A4 :                        
 3385/    13A4 :                        ;************************************************************************************
 3386/    13A4 :                        ;
 3387/    13A4 :                        ; check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
 3388/    13A4 :                        
 3389/    13A4 :                        LAB_CASC
 3390/    13A4 : B03C 0061              	CMP.b		#$61,d0				; compare with "a"
 3391/    13A8 : 6410                   	BCC.s		LAB_1D83				; if >="a" go check =<"z"
 3392/    13AA :                        
 3393/    13AA :                        
 3394/    13AA :                        ;************************************************************************************
 3395/    13AA :                        ;
 3396/    13AA :                        ; check alpha upper case, return C=0 if<"A" or >"Z"
 3397/    13AA :                        
 3398/    13AA :                        LAB_CAUC
 3399/    13AA : B03C 0041              	CMP.b		#$41,d0				; compare with "A"
 3400/    13AE : 6404                   	BCC.s		LAB_1D8A				; if >="A" go check =<"Z"
 3401/    13B0 :                        
 3402/    13B0 : 8040                   	OR		d0,d0					; make C=0
 3403/    13B2 : 4E75                   	RTS
 3404/    13B4 :                        
 3405/    13B4 :                        LAB_1D8A
 3406/    13B4 : B03C 005B              	CMP.b		#$5B,d0				; compare with "Z"+1
 3407/    13B8 :                        								; carry set if byte<="Z"
 3408/    13B8 : 4E75                   	RTS
 3409/    13BA :                        
 3410/    13BA :                        LAB_1D83
 3411/    13BA : B03C 007B              	CMP.b		#$7B,d0				; compare with "z"+1
 3412/    13BE :                        								; carry set if byte<="z"
 3413/    13BE : 4E75                   	RTS
 3414/    13C0 :                        
 3415/    13C0 :                        
 3416/    13C0 :                        ;************************************************************************************
 3417/    13C0 :                        ;
 3418/    13C0 :                        ; search for or create variable. this is used to automatically create a variable if
 3419/    13C0 :                        ; it is not found. any routines that need to create the variable call LAB_GVAR via
 3420/    13C0 :                        ; this point and error generation is supressed and the variable will be created
 3421/    13C0 :                        ;
 3422/    13C0 :                        ; return pointer to variable in Cvaral and a0
 3423/    13C0 :                        ; set data type to variable type
 3424/    13C0 :                        
 3425/    13C0 :                        LAB_SVAR
 3426/    13C0 : 6102                   	BSR.s		LAB_GVAR				; search for variable
 3427/    13C2 :                        LAB_FVAR
 3428/    13C2 : 4E75                   	RTS
 3429/    13C4 :                        
 3430/    13C4 :                        
 3431/    13C4 :                        ;************************************************************************************
 3432/    13C4 :                        ;
 3433/    13C4 :                        ; search for variable. if this routine is called from anywhere but the above call and
 3434/    13C4 :                        ; the variable searched for does not exist then an error will be returned
 3435/    13C4 :                        ;
 3436/    13C4 :                        ; DIM flag is in d1.b
 3437/    13C4 :                        ; return pointer to variable in Cvaral and a0
 3438/    13C4 :                        ; set data type to variable type
 3439/    13C4 :                        
 3440/    13C4 :                        LAB_GVAR
 3441/    13C4 : 7200                   	MOVEQ		#$00,d1				; set DIM flag = $00
 3442/    13C6 : 6100 FDEC              	BSR		LAB_GBYT				; scan memory (1st character)
 3443/    13CA :                        LAB_1D10
 3444/    13CA : 1741 05B4              	MOVE.b	d1,Defdim(a3)			; save DIM flag
 3445/    13CE :                        
 3446/    13CE :                        ; search for FN name entry point
 3447/    13CE :                        
 3448/    13CE :                        LAB_1D12
 3449/    13CE : 61D4                   	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
 3450/    13D0 : 6400 F19A              	BCC		LAB_SNER				; if not, syntax error then warm start
 3451/    13D4 :                        
 3452/    13D4 :                        								; it is a variable name so ...
 3453/    13D4 : 7200                   	MOVEQ		#$0,d1				; set index for name byte
 3454/    13D6 : 41EB 046A              	LEA		Varname(a3),a0			; pointer to variable name
 3455/    13DA : 2081                   	MOVE.l	d1,(a0)				; clear the variable name
 3456/    13DC : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
 3457/    13E0 :                        								; $00=float
 3458/    13E0 :                        
 3459/    13E0 :                        LAB_1D2D
 3460/    13E0 : B27C 0004              	CMP.w		#$04,d1				; done all significant characters?
 3461/    13E4 : 6406                   	BCC.s		LAB_1D2E				; if so go ignore any more
 3462/    13E6 :                        
 3463/    13E6 : 1180 1000              	MOVE.b	d0,(a0,d1.w)			; save the character
 3464/    13EA : 5241                   	ADDQ.w	#1,d1					; increment index
 3465/    13EC :                        LAB_1D2E
 3466/    13EC : 6100 FDC4              	BSR		LAB_IGBY				; increment & scan memory (next character)
 3467/    13F0 : 65EE                   	BCS.s		LAB_1D2D				; branch if character = "0"-"9" (ok)
 3468/    13F2 :                        
 3469/    13F2 :                        								; character wasn't "0" to "9" so ...
 3470/    13F2 : 61B0                   	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
 3471/    13F4 : 65EA                   	BCS.s		LAB_1D2D				; branch if = "A"-"Z" (ok)
 3472/    13F6 :                        
 3473/    13F6 :                        								; check if string variable
 3474/    13F6 : B03C 0024              	CMP.b		#'$',d0				; compare with "$"
 3475/    13FA : 660C                   	BNE.s		LAB_1D44				; branch if not string
 3476/    13FC :                        
 3477/    13FC :                        								; type is string
 3478/    13FC : 002B 0080 046B         	OR.b		#$80,Varname+1(a3)		; set top bit of 2nd character, indicate string
 3479/    1402 : 6100 FDAE              	BSR		LAB_IGBY				; increment & scan memory
 3480/    1406 : 6010                   	BRA.s		LAB_1D45				; skip integer check
 3481/    1408 :                        
 3482/    1408 :                        								; check if integer variable
 3483/    1408 :                        LAB_1D44
 3484/    1408 : B03C 0026              	CMP.b		#'&',d0				; compare with "&"
 3485/    140C : 660A                   	BNE.s		LAB_1D45				; branch if not integer
 3486/    140E :                        
 3487/    140E :                        								; type is integer
 3488/    140E : 002B 0080 046C         	OR.b		#$80,Varname+2(a3)		; set top bit of 3rd character, indicate integer
 3489/    1414 : 6100 FD9C              	BSR		LAB_IGBY				; increment & scan memory
 3490/    1418 :                        
 3491/    1418 :                        ; after we have determined the variable type we need to determine
 3492/    1418 :                        ; if it's an array of type
 3493/    1418 :                        
 3494/    1418 :                        								; gets here with character after var name in d0
 3495/    1418 :                        LAB_1D45
 3496/    1418 : 4A2B 05DF              	TST.b		Sufnxf(a3)				; test function name flag
 3497/    141C : 670E                   	BEQ.s		LAB_1D48				; if not FN or FN variable continue
 3498/    141E :                        
 3499/    141E : 6A14                   	BPL.s		LAB_1D49				; if FN variable go find or create it
 3500/    1420 :                        
 3501/    1420 :                        								; else was FN name
 3502/    1420 : 202B 046A              	MOVE.l	Varname(a3),d0			; get whole function name
 3503/    1424 : 7208                   	MOVEQ		#8,d1					; set step to next function size -4
 3504/    1426 : 41EB 0432              	LEA		Sfncl(a3),a0			; get pointer to start of functions
 3505/    142A : 601C                   	BRA.s		LAB_1D4B				; go find function
 3506/    142C :                        
 3507/    142C :                        LAB_1D48
 3508/    142C : 903C 0028              	SUB.b		#'(',d0				; subtract "("
 3509/    1430 : 6700 00F4              	BEQ		LAB_1E17				; if "(" go find, or make, array
 3510/    1434 :                        
 3511/    1434 :                        ; either find or create var
 3512/    1434 :                        ; var name (1st four characters only!) is in Varname
 3513/    1434 :                        
 3514/    1434 :                        								; variable name wasn't var( .. so look for
 3515/    1434 :                        								; plain variable
 3516/    1434 :                        LAB_1D49
 3517/    1434 : 202B 046A              	MOVE.l	Varname(a3),d0			; get whole variable name
 3518/    1438 :                        LAB_1D4A
 3519/    1438 : 7204                   	MOVEQ		#4,d1					; set step to next variable size -4
 3520/    143A : 41EB 0436              	LEA		Svarl(a3),a0			; get pointer to start of variables
 3521/    143E :                        
 3522/    143E : 0800 0017              	BTST.l	#23,d0				; test if string name
 3523/    1442 : 6704                   	BEQ.s		LAB_1D4B				; branch if not
 3524/    1444 :                        
 3525/    1444 : 5441                   	ADDQ.w	#2,d1					; 6 bytes per string entry
 3526/    1446 : 5848                   	ADDQ.w	#(Sstrl-Svarl),a0			; move to string area
 3527/    1448 :                        
 3528/    1448 :                        LAB_1D4B
 3529/    1448 : 2268 0004              	MOVEA.l	4(a0),a1				; get end address
 3530/    144C : 2050                   	MOVEA.l	(a0),a0				; get start address
 3531/    144E : 6006                   	BRA.s		LAB_1D5E				; enter loop at exit check
 3532/    1450 :                        
 3533/    1450 :                        LAB_1D5D
 3534/    1450 : B098                   	CMP.l		(a0)+,d0				; compare this variable with name
 3535/    1452 : 6776                   	BEQ.s		LAB_1DD7				; branch if match (found var)
 3536/    1454 :                        
 3537/    1454 : D1C1                   	ADDA.l	d1,a0					; add offset to next variable
 3538/    1456 :                        LAB_1D5E
 3539/    1456 : B1C9                   	CMPA.l	a1,a0					; compare address with variable space end
 3540/    1458 : 66F6                   	BNE.s		LAB_1D5D				; if not end go check next
 3541/    145A :                        
 3542/    145A : 4A2B 05DF              	TST.b		Sufnxf(a3)				; is it a function or function variable
 3543/    145E : 660A                   	BNE.s		LAB_1D94				; if was go do DEF or function variable
 3544/    1460 :                        
 3545/    1460 :                        								; reached end of variable mem without match
 3546/    1460 :                        								; ... so create new variable, possibly
 3547/    1460 :                        
 3548/    1460 : 45FA FF60              	LEA		LAB_FVAR(pc),a2			; get the address of the create if doesn't
 3549/    1464 :                        								; exist call to LAB_GVAR
 3550/    1464 : B5D7                   	CMPA.l	(sp),a2				; compare the return address with expected
 3551/    1466 : 6600 F0C0              	BNE		LAB_UVER				; if not create go do error or return null
 3552/    146A :                        
 3553/    146A :                        ; this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
 3554/    146A :                        
 3555/    146A :                        LAB_1D94
 3556/    146A : 082B 0000 05DF         	BTST.b	#0,Sufnxf(a3)			; test function search flag
 3557/    1470 : 6600 F0BE              	BNE		LAB_UFER				; if not doing DEF then go do undefined
 3558/    1474 :                        								; function error
 3559/    1474 :                        
 3560/    1474 :                        								; else create new variable/function
 3561/    1474 :                        LAB_1D98
 3562/    1474 : 246B 0442              	MOVEA.l	Earryl(a3),a2			; get end of block to move
 3563/    1478 : 240A                   	MOVE.l	a2,d2					; copy end of block to move
 3564/    147A : 9489                   	SUB.l		a1,d2					; calculate block to move size
 3565/    147C :                        
 3566/    147C : 204A                   	MOVEA.l	a2,a0					; copy end of block to move
 3567/    147E : 5881                   	ADDQ.l	#4,d1					; space for one variable/function + name
 3568/    1480 : D5C1                   	ADDA.l	d1,a2					; add space for one variable/function
 3569/    1482 : 274A 0442              	MOVE.l	a2,Earryl(a3)			; set new array mem end
 3570/    1486 : E28A                   	LSR.l		#1,d2					; /2 for word copy
 3571/    1488 : 6712                   	BEQ.s		LAB_1DAF				; skip move if zero length block
 3572/    148A :                        
 3573/    148A : 5382                   	SUBQ.l	#1,d2					; -1 for DFB loop
 3574/    148C : 4842                   	SWAP		d2					; swap high word to low word
 3575/    148E :                        LAB_1DAC
 3576/    148E : 4842                   	SWAP		d2					; swap high word to low word
 3577/    1490 :                        LAB_1DAE
 3578/    1490 : 3520                   	MOVE.w	-(a0),-(a2)				; copy word
 3579/    1492 : 51CA FFFC              	DBF		d2,LAB_1DAE				; loop until done
 3580/    1496 :                        
 3581/    1496 : 4842                   	SWAP		d2					; swap high word to low word
 3582/    1498 : 51CA FFF4              	DBF		d2,LAB_1DAC				; decrement high count and loop until done
 3583/    149C :                        
 3584/    149C :                        ; get here after creating either a function, variable or string
 3585/    149C :                        ; if function set variables start, string start, array start
 3586/    149C :                        ; if variable set string start, array start
 3587/    149C :                        ; if string set array start
 3588/    149C :                        
 3589/    149C :                        LAB_1DAF
 3590/    149C : 4A2B 05DF              	TST.b		Sufnxf(a3)				; was it function
 3591/    14A0 : 6B08                   	BMI.s		LAB_1DB0				; branch if was FN
 3592/    14A2 :                        
 3593/    14A2 : 0800 0017              	BTST.l	#23,d0				; was it string
 3594/    14A6 : 660A                   	BNE.s		LAB_1DB2				; branch if string
 3595/    14A8 :                        
 3596/    14A8 : 6004                   	BRA.s		LAB_1DB1				; branch if was plain variable
 3597/    14AA :                        
 3598/    14AA :                        LAB_1DB0
 3599/    14AA : D3AB 0436              	ADD.l		d1,Svarl(a3)			; set new variable memory start
 3600/    14AE :                        LAB_1DB1
 3601/    14AE : D3AB 043A              	ADD.l		d1,Sstrl(a3)			; set new start of strings
 3602/    14B2 :                        LAB_1DB2
 3603/    14B2 : D3AB 043E              	ADD.l		d1,Sarryl(a3)			; set new array memory start
 3604/    14B6 : 20C0                   	MOVE.l	d0,(a0)+				; save variable/function name
 3605/    14B8 : 20BC 0000 0000         	MOVE.l	#$00,(a0)				; initialise variable
 3606/    14BE : 0800 0017              	BTST.l	#23,d0				; was it string
 3607/    14C2 : 6706                   	BEQ.s		LAB_1DD7				; branch if not string
 3608/    14C4 :                        
 3609/    14C4 : 317C 0000 0004         	MOVE.w	#$00,4(a0)				; else initialise string length
 3610/    14CA :                        
 3611/    14CA :                        								; found a match for var ((Vrschl) = ptr)
 3612/    14CA :                        LAB_1DD7
 3613/    14CA : 2200                   	MOVE.l	d0,d1					; ........ $....... &....... ........
 3614/    14CC : D281                   	ADD.l		d1,d1					; .......$ .......& ........ .......0
 3615/    14CE : 4841                   	SWAP		d1					; ........ .......0 .......$ .......&
 3616/    14D0 : E219                   	ROR.b		#1,d1					; ........ .......0 .......$ &.......
 3617/    14D2 : E249                   	LSR.w		#1,d1					; ........ .......0 0....... $&.....�.
 3618/    14D4 : C23C 00C0              	AND.b		#$C0,d1				; mask the type bits
 3619/    14D8 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; save the data type
 3620/    14DC :                        
 3621/    14DC : 177C 0000 05DF         	MOVE.b	#$00,Sufnxf(a3)			; clear FN flag byte
 3622/    14E2 : 4E75                   	RTS
 3623/    14E4 :                        
 3624/    14E4 :                        
 3625/    14E4 :                        ;************************************************************************************
 3626/    14E4 :                        ;
 3627/    14E4 :                        ; set-up array pointer, d0, to first element in array
 3628/    14E4 :                        ; set d0 to (a0)+2*(Dimcnt)+$0A
 3629/    14E4 :                        
 3630/    14E4 :                        LAB_1DE6
 3631/    14E4 : 7005                   	MOVEQ		#5,d0					; set d0 to 5 (*2 = 10, later)
 3632/    14E6 : D02B 05DB              	ADD.b		Dimcnt(a3),d0			; add # of dimensions (1, 2 or 3)
 3633/    14EA : D080                   	ADD.l		d0,d0					; *2 (bytes per dimension size)
 3634/    14EC : D088                   	ADD.l		a0,d0					; add array start pointer
 3635/    14EE : 4E75                   	RTS
 3636/    14F0 :                        
 3637/    14F0 :                        
 3638/    14F0 :                        ;************************************************************************************
 3639/    14F0 :                        ;
 3640/    14F0 :                        ; evaluate unsigned integer expression
 3641/    14F0 :                        
 3642/    14F0 :                        LAB_EVIN
 3643/    14F0 : 6100 FCC0              	BSR		LAB_IGBY				; increment & scan memory
 3644/    14F4 : 6100 FB44              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 3645/    14F8 :                        								; else do type mismatch
 3646/    14F8 :                        
 3647/    14F8 :                        
 3648/    14F8 :                        ;************************************************************************************
 3649/    14F8 :                        ;
 3650/    14F8 :                        ; evaluate positive integer expression, result in d0 and Itemp
 3651/    14F8 :                        
 3652/    14F8 :                        LAB_EVPI
 3653/    14F8 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
 3654/    14FC : 6B00 F062              	BMI		LAB_FCER				; do function call error if -ve
 3655/    1500 :                        
 3656/    1500 :                        
 3657/    1500 :                        ;************************************************************************************
 3658/    1500 :                        ;
 3659/    1500 :                        ; evaluate integer expression, no sign check
 3660/    1500 :                        ; result in d0 and Itemp, exit with flags set correctly
 3661/    1500 :                        
 3662/    1500 :                        LAB_EVIR
 3663/    1500 : 0C2B 00A0 0594         	CMPI.b	#$A0,FAC1_e(a3)			; compare exponent with exponent = 2^32 (n>2^31)
 3664/    1506 : 6500 0B64              	BCS		LAB_2831				; convert FAC1 floating to fixed
 3665/    150A :                        								; result in d0 and Itemp
 3666/    150A : 6600 F054              	BNE		LAB_FCER				; if > do function call error, then warm start
 3667/    150E :                        
 3668/    150E : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign of FAC1
 3669/    1512 : 6A00 0B58              	BPL		LAB_2831				; if +ve then ok
 3670/    1516 :                        
 3671/    1516 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 3672/    151A : 4480                   	NEG.l		d0					; do -d0
 3673/    151C : 6800 F042              	BVC		LAB_FCER				; if not $80000000 do FC error, then warm start
 3674/    1520 :                        
 3675/    1520 : 2740 042A              	MOVE.l	d0,Itemp(a3)			; else just set it
 3676/    1524 : 4E75                   	RTS
 3677/    1526 :                        
 3678/    1526 :                        
 3679/    1526 :                        ;************************************************************************************
 3680/    1526 :                        ;
 3681/    1526 :                        ; find or make array
 3682/    1526 :                        
 3683/    1526 :                        LAB_1E17
 3684/    1526 : 3F2B 05B4              	MOVE.w	Defdim(a3),-(sp)			; get DIM flag and data type flag (word in mem)
 3685/    152A : 7200                   	MOVEQ		#0,d1					; clear dimensions count
 3686/    152C :                        
 3687/    152C :                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
 3688/    152C :                        
 3689/    152C :                        LAB_1E1F
 3690/    152C : 3F01                   	MOVE.w	d1,-(sp)				; save dimensions count
 3691/    152E : 2F2B 046A              	MOVE.l	Varname(a3),-(sp)			; save variable name
 3692/    1532 : 61BC                   	BSR.s		LAB_EVIN				; evaluate integer expression
 3693/    1534 :                        
 3694/    1534 : 4840                   	SWAP		d0					; swap high word to low word
 3695/    1536 : 4A40                   	TST.w		d0					; test swapped high word
 3696/    1538 : 6600 F016              	BNE		LAB_ABER				; if too big do array bounds error
 3697/    153C :                        
 3698/    153C : 275F 046A              	MOVE.l	(sp)+,Varname(a3)			; restore variable name
 3699/    1540 : 321F                   	MOVE.w	(sp)+,d1				; restore dimensions count
 3700/    1542 : 301F                   	MOVE.w	(sp)+,d0				; restore DIM and data type flags
 3701/    1544 : 3F2B 042C              	MOVE.w	Itemp+2(a3),-(sp)			; stack this dimension size
 3702/    1548 : 3F00                   	MOVE.w	d0,-(sp)				; save DIM and data type flags
 3703/    154A : 5241                   	ADDQ.w	#1,d1					; increment dimensions count
 3704/    154C : 6100 FC66              	BSR		LAB_GBYT				; scan memory
 3705/    1550 : B03C 002C              	CMP.b		#$2C,d0				; compare with ","
 3706/    1554 : 67D6                   	BEQ.s		LAB_1E1F				; if found go do next dimension
 3707/    1556 :                        
 3708/    1556 : 1741 05DB              	MOVE.b	d1,Dimcnt(a3)			; store dimensions count
 3709/    155A : 6100 FC44              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 3710/    155E : 375F 05B4              	MOVE.w	(sp)+,Defdim(a3)			; restore DIM and data type flags (word in mem)
 3711/    1562 : 206B 043E              	MOVEA.l	Sarryl(a3),a0			; get array mem start
 3712/    1566 :                        
 3713/    1566 :                        ; now check to see if we are at the end of array memory (we would be if there were
 3714/    1566 :                        ; no arrays).
 3715/    1566 :                        
 3716/    1566 :                        LAB_1E5C
 3717/    1566 : 2748 05AC              	MOVE.l	a0,Astrtl(a3)			; save as array start pointer
 3718/    156A : B1EB 0442              	CMPA.l	Earryl(a3),a0			; compare with array mem end
 3719/    156E : 672E                   	BEQ.s		LAB_1EA1				; go build array if not found
 3720/    1570 :                        
 3721/    1570 :                        								; search for array
 3722/    1570 : 2010                   	MOVE.l	(a0),d0				; get this array name
 3723/    1572 : B0AB 046A              	CMP.l		Varname(a3),d0			; compare with array name
 3724/    1576 : 670A                   	BEQ.s		LAB_1E8D				; array found so branch
 3725/    1578 :                        
 3726/    1578 :                        								; no match
 3727/    1578 : 2068 0004              	MOVEA.l	4(a0),a0				; get this array size
 3728/    157C : D1EB 05AC              	ADDA.l	Astrtl(a3),a0			; add to array start pointer
 3729/    1580 : 60E4                   	BRA.s		LAB_1E5C				; go check next array
 3730/    1582 :                        
 3731/    1582 :                        								; found array, are we trying to dimension it?
 3732/    1582 :                        LAB_1E8D
 3733/    1582 : 4A2B 05B4              	TST.b		Defdim(a3)				; are we trying to dimension it?
 3734/    1586 : 6600 EFC4              	BNE		LAB_DDER				; if so do double dimension error/warm start
 3735/    158A :                        
 3736/    158A :                        ; found the array and we're not dimensioning it so we must find an element in it
 3737/    158A :                        
 3738/    158A : 6100 FF58              	BSR		LAB_1DE6				; set data pointer, d0, to the first element
 3739/    158E :                        								; in the array
 3740/    158E : 5048                   	ADDQ.w	#8,a0					; index to dimension count
 3741/    1590 : 3018                   	MOVE.w	(a0)+,d0				; get no of dimensions
 3742/    1592 : B02B 05DB              	CMP.b		Dimcnt(a3),d0			; compare with dimensions count
 3743/    1596 : 6700 0094              	BEQ		LAB_1F28				; found array so go get element
 3744/    159A :                        
 3745/    159A : 6000 EF84              	BRA		LAB_WDER				; else wrong so do "Wrong dimensions" error
 3746/    159E :                        
 3747/    159E :                        								; array not found, so possibly build it
 3748/    159E :                        LAB_1EA1
 3749/    159E : 4A2B 05B4              	TST.b		Defdim(a3)				; test the default DIM flag
 3750/    15A2 : 6700 EF80              	BEQ		LAB_UDER				; if default flag is clear then we are not
 3751/    15A6 :                        								; explicitly dimensioning an array so go
 3752/    15A6 :                        								; do an "Undimensioned array" error
 3753/    15A6 :                        
 3754/    15A6 : 6100 FF3C              	BSR		LAB_1DE6				; set data pointer, d0, to the first element
 3755/    15AA :                        								; in the array
 3756/    15AA : 202B 046A              	MOVE.l	Varname(a3),d0			; get array name
 3757/    15AE : 20C0                   	MOVE.l	d0,(a0)+				; save array name
 3758/    15B0 : 7204                   	MOVEQ		#4,d1					; set 4 bytes per element
 3759/    15B2 : 0800 0017              	BTST.l	#23,d0				; test if string array
 3760/    15B6 : 6702                   	BEQ.s		LAB_1EDF				; branch if not string
 3761/    15B8 :                        
 3762/    15B8 : 7206                   	MOVEQ		#6,d1					; else 6 bytes per element
 3763/    15BA :                        LAB_1EDF
 3764/    15BA : 2741 05A8              	MOVE.l	d1,Asptl(a3)			; set array data size (bytes per element)
 3765/    15BE : 122B 05DB              	MOVE.b	Dimcnt(a3),d1			; get dimensions count
 3766/    15C2 : 5848                   	ADDQ.w	#4,a0					; skip the array size now (don't know it yet!)
 3767/    15C4 : 30C1                   	MOVE.w	d1,(a0)+				; set array's dimensions count
 3768/    15C6 :                        
 3769/    15C6 :                        ; now calculate the array data space size
 3770/    15C6 :                        
 3771/    15C6 :                        LAB_1EC0
 3772/    15C6 :                        
 3773/    15C6 :                        ; If you want arrays to dimension themselves by default then comment out the test
 3774/    15C6 :                        ; above and uncomment the next three code lines and the label LAB_1ED0
 3775/    15C6 :                        
 3776/    15C6 :                        ;	MOVE.w	#$0A,d1				; set default dimension value, allow 0 to 9
 3777/    15C6 :                        ;	TST.b		Defdim(a3)				; test default DIM flag
 3778/    15C6 :                        ;	BNE.s		LAB_1ED0				; branch if b6 of Defdim is clear
 3779/    15C6 :                        
 3780/    15C6 : 321F                   	MOVE.w	(sp)+,d1				; get dimension size
 3781/    15C8 :                        ;LAB_1ED0
 3782/    15C8 : 30C1                   	MOVE.w	d1,(a0)+				; save to array header
 3783/    15CA : 6100 00AE              	BSR		LAB_1F7C				; do this dimension size+1	; array size
 3784/    15CE :                        								; (d1+1)*(Asptl), result in d0
 3785/    15CE : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; save array data size
 3786/    15D2 : 532B 05DB              	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
 3787/    15D6 : 66EE                   	BNE.s		LAB_1EC0				; loop while not = 0
 3788/    15D8 :                        
 3789/    15D8 : D1EB 05A8              	ADDA.l	Asptl(a3),a0			; add size to first element address
 3790/    15DC : 6500 EF7A              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 3791/    15E0 :                        
 3792/    15E0 : B1EB 0446              	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
 3793/    15E4 : 650C                   	BCS.s		LAB_1ED6				; branch if less (is ok)
 3794/    15E6 :                        
 3795/    15E6 : 6100 028E              	BSR		LAB_GARB				; do garbage collection routine
 3796/    15EA : B1EB 0446              	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
 3797/    15EE : 6400 EF68              	BCC		LAB_OMER				; if Sstorl <= a0 do "Out of memory"
 3798/    15F2 :                        								; error then warm start
 3799/    15F2 :                        
 3800/    15F2 :                        LAB_1ED6							; ok exit, carry set
 3801/    15F2 : 2748 0442              	MOVE.l	a0,Earryl(a3)			; save array mem end
 3802/    15F6 : 7000                   	MOVEQ		#0,d0					; zero d0
 3803/    15F8 : 222B 05A8              	MOVE.l	Asptl(a3),d1			; get size in bytes
 3804/    15FC : E289                   	LSR.l		#1,d1					; /2 for word fill (may be odd # words)
 3805/    15FE : 5341                   	SUBQ.w	#1,d1					; adjust for DBF loop
 3806/    1600 :                        LAB_1ED8
 3807/    1600 : 3100                   	MOVE.w	d0,-(a0)				; decrement pointer and clear word
 3808/    1602 : 51C9 FFFC              	DBF		d1,LAB_1ED8				; decrement & loop until low word done
 3809/    1606 :                        
 3810/    1606 : 4841                   	SWAP		d1					; swap words
 3811/    1608 : 4A41                   	TST.w		d1					; test high word
 3812/    160A : 6706                   	BEQ.s		LAB_1F07				; exit if done
 3813/    160C :                        
 3814/    160C : 5341                   	SUBQ.w	#1,d1					; decrement low (high) word
 3815/    160E : 4841                   	SWAP		d1					; swap back
 3816/    1610 : 60EE                   	BRA.s		LAB_1ED8				; go do a whole block
 3817/    1612 :                        
 3818/    1612 :                        ; now we need to calculate the array size by doing Earryl - Astrtl
 3819/    1612 :                        
 3820/    1612 :                        LAB_1F07
 3821/    1612 : 206B 05AC              	MOVEA.l	Astrtl(a3),a0			; get for calculation and as pointer
 3822/    1616 : 202B 0442              	MOVE.l	Earryl(a3),d0			; get array memory end
 3823/    161A : 9088                   	SUB.l		a0,d0					; calculate array size
 3824/    161C : 2140 0004              	MOVE.l	d0,4(a0)				; save size to array
 3825/    1620 : 4A2B 05B4              	TST.b		Defdim(a3)				; test default DIM flag
 3826/    1624 : 6652                   	BNE.s		RTS_011				; exit (RET) if this was a DIM command
 3827/    1626 :                        
 3828/    1626 :                        								; else, find element
 3829/    1626 : 5048                   	ADDQ.w	#8,a0					; index to dimension count
 3830/    1628 : 3758 05DB              	MOVE.w	(a0)+,Dimcnt(a3)			; get array's dimension count
 3831/    162C :                        
 3832/    162C :                        ; we have found, or built, the array. now we need to find the element
 3833/    162C :                        
 3834/    162C :                        LAB_1F28
 3835/    162C : 7000                   	MOVEQ		#0,d0					; clear first result
 3836/    162E : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; clear array data pointer
 3837/    1632 :                        
 3838/    1632 :                        ; compare nth dimension bound (a0) with nth index (sp)+
 3839/    1632 :                        ; if greater do array bounds error
 3840/    1632 :                        
 3841/    1632 :                        LAB_1F2C
 3842/    1632 : 3218                   	MOVE.w	(a0)+,d1				; get nth dimension bound
 3843/    1634 : B257                   	CMP.w		(sp),d1				; compare nth index with nth dimension bound
 3844/    1636 : 6500 EF18              	BCS		LAB_ABER				; if d1 less or = do array bounds error
 3845/    163A :                        
 3846/    163A :                        ; now do pointer = pointer	; nth dimension + nth index
 3847/    163A :                        
 3848/    163A : 4A80                   	TST.l		d0					; test pointer
 3849/    163C : 6702                   	BEQ.s		LAB_1F5A				; skip multiply if last result = null
 3850/    163E :                        
 3851/    163E : 613A                   	BSR.s		LAB_1F7C				; do this dimension size+1	; array size
 3852/    1640 :                        LAB_1F5A
 3853/    1640 : 7200                   	MOVEQ		#0,d1					; clear longword
 3854/    1642 : 321F                   	MOVE.w	(sp)+,d1				; get nth dimension index
 3855/    1644 : D081                   	ADD.l		d1,d0					; add index to size
 3856/    1646 : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; save array data pointer
 3857/    164A :                        
 3858/    164A : 532B 05DB              	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
 3859/    164E : 66E2                   	BNE.s		LAB_1F2C				; loop if dimensions still to do
 3860/    1650 :                        
 3861/    1650 : 177C 0000 05B5         	MOVE.b	#0,Dtypef(a3)			; set data type to float
 3862/    1656 : 7203                   	MOVEQ		#3,d1					; set for numeric array
 3863/    1658 : 4A2B 046B              	TST.b		Varname+1(a3)			; test if string array
 3864/    165C : 6A0A                   	BPL.s		LAB_1F6A				; branch if not string
 3865/    165E :                        
 3866/    165E : 7205                   	MOVEQ		#5,d1					; else set for string array
 3867/    1660 : 177C 0080 05B5         	MOVE.b	#$80,Dtypef(a3)			; and set data type to string
 3868/    1666 : 600C                   	BRA.s		LAB_1F6B				; skip integer test
 3869/    1668 :                        
 3870/    1668 :                        LAB_1F6A
 3871/    1668 : 4A2B 046C              	TST.b		Varname+2(a3)			; test if integer array
 3872/    166C : 6A06                   	BPL.s		LAB_1F6B				; branch if not integer
 3873/    166E :                        
 3874/    166E : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; else set data type to integer
 3875/    1674 :                        LAB_1F6B
 3876/    1674 : 6104                   	BSR.s		LAB_1F7C				; do element size (d1)	; array size (Asptl)
 3877/    1676 : D1C0                   	ADDA.l	d0,a0					; add array data start pointer
 3878/    1678 :                        RTS_011
 3879/    1678 : 4E75                   	RTS
 3880/    167A :                        
 3881/    167A :                        
 3882/    167A :                        ;************************************************************************************
 3883/    167A :                        ;
 3884/    167A :                        ; do this dimension size (d1)	; array data size (Asptl)
 3885/    167A :                        
 3886/    167A :                        ; do a 16 x 32 bit multiply
 3887/    167A :                        ; d1 holds the 16 bit multiplier
 3888/    167A :                        ; Asptl holds the 32 bit multiplicand
 3889/    167A :                        
 3890/    167A :                        ; d0	bbbb  bbbb
 3891/    167A :                        ; d1	0000  aaaa
 3892/    167A :                        ;	----------
 3893/    167A :                        ; d0	rrrr  rrrr
 3894/    167A :                        
 3895/    167A :                        LAB_1F7C
 3896/    167A : 202B 05A8              	MOVE.l	Asptl(a3),d0			; get result
 3897/    167E : 2400                   	MOVE.l	d0,d2					; copy it
 3898/    1680 : 4842                   	SWAP		d2					; shift high word to low word
 3899/    1682 : C0C1                   	MULU.w	d1,d0					; d1	; low word = low result
 3900/    1684 : C4C1                   	MULU.w	d1,d2					; d1	; high word = high result
 3901/    1686 : 4842                   	SWAP		d2					; align words for test
 3902/    1688 : 4A42                   	TST.w		d2					; must be zero
 3903/    168A : 6600 EECC              	BNE		LAB_OMER				; if overflow go do "Out of memory" error
 3904/    168E :                        
 3905/    168E : D082                   	ADD.l		d2,d0					; calculate result
 3906/    1690 : 6500 EEC6              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 3907/    1694 :                        
 3908/    1694 : D0AB 05A8              	ADD.l		Asptl(a3),d0			; add original
 3909/    1698 : 6500 EEBE              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 3910/    169C :                        
 3911/    169C : 4E75                   	RTS
 3912/    169E :                        
 3913/    169E :                        
 3914/    169E :                        ;************************************************************************************
 3915/    169E :                        ;
 3916/    169E :                        ; perform FRE()
 3917/    169E :                        
 3918/    169E :                        LAB_FRE
 3919/    169E : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 3920/    16A2 :                        								; $00=float
 3921/    16A2 : 6A04                   	BPL.s		LAB_1FB4				; branch if numeric
 3922/    16A4 :                        
 3923/    16A4 : 6100 0318              	BSR		LAB_22B6				; pop string off descriptor stack, or from
 3924/    16A8 :                        								; top of string space, returns d0 = length,
 3925/    16A8 :                        								; a0 = pointer
 3926/    16A8 :                        
 3927/    16A8 :                        								; FRE(n) was numeric so do this
 3928/    16A8 :                        LAB_1FB4
 3929/    16A8 : 6100 01CC              	BSR		LAB_GARB				; go do garbage collection
 3930/    16AC : 202B 0446              	MOVE.l	Sstorl(a3),d0			; get bottom of string space
 3931/    16B0 : 90AB 0442              	SUB.l		Earryl(a3),d0			; subtract array mem end
 3932/    16B4 :                        
 3933/    16B4 :                        
 3934/    16B4 :                        ;************************************************************************************
 3935/    16B4 :                        ;
 3936/    16B4 :                        ; convert d0 to signed longword in FAC1
 3937/    16B4 :                        
 3938/    16B4 :                        LAB_AYFC
 3939/    16B4 : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
 3940/    16BA :                        								; $00=float
 3941/    16BA : 377C A000 0594         	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent and clear sign (b7)
 3942/    16C0 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
 3943/    16C4 : 6A00 0640              	BPL		LAB_24D0				; convert if +ve
 3944/    16C8 :                        
 3945/    16C8 : 003C 0001              	ORI.b		#1,CCR				; else set carry
 3946/    16CC : 6000 0638              	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
 3947/    16D0 :                        
 3948/    16D0 :                        
 3949/    16D0 :                        ;************************************************************************************
 3950/    16D0 :                        ;
 3951/    16D0 :                        ; remember if the line length is zero (infinite line) then POS(n) will return
 3952/    16D0 :                        ; position MOD tabsize
 3953/    16D0 :                        
 3954/    16D0 :                        ; perform POS()
 3955/    16D0 :                        
 3956/    16D0 :                        LAB_POS
 3957/    16D0 : 102B 05E5              	MOVE.b	TPos(a3),d0				; get terminal position
 3958/    16D4 :                        
 3959/    16D4 :                        ; convert d0 to unsigned byte in FAC1
 3960/    16D4 :                        
 3961/    16D4 :                        LAB_1FD0
 3962/    16D4 : C0BC 0000 00FF         	AND.l		#$FF,d0				; clear high bits
 3963/    16DA : 60D8                   	BRA.s		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3964/    16DC :                        
 3965/    16DC :                        ; check not direct (used by DEF and INPUT)
 3966/    16DC :                        
 3967/    16DC :                        LAB_CKRN
 3968/    16DC : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #
 3969/    16E0 : 6B00 EE62              	BMI		LAB_IDER				; if -ve go do illegal direct error then warm
 3970/    16E4 :                        								; start
 3971/    16E4 :                        
 3972/    16E4 : 4E75                   	RTS							; can continue so return
 3973/    16E6 :                        
 3974/    16E6 :                        
 3975/    16E6 :                        ;************************************************************************************
 3976/    16E6 :                        ;
 3977/    16E6 :                        ; perform DEF
 3978/    16E6 :                        
 3979/    16E6 :                        LAB_DEF
 3980/    16E6 : 70AB                   	MOVEQ		#TK_FN-$100,d0			; get FN token
 3981/    16E8 : 6100 FAC0              	BSR		LAB_SCCA				; scan for CHR$(d0), else syntax error and
 3982/    16EC :                        								; warm start
 3983/    16EC :                        								; return character after d0
 3984/    16EC : 177C 0080 05DF         	MOVE.b	#$80,Sufnxf(a3)			; set FN flag bit
 3985/    16F2 : 6100 FCDA              	BSR		LAB_1D12				; get FN name
 3986/    16F6 : 2748 05B0              	MOVE.l	a0,func_l(a3)			; save function pointer
 3987/    16FA :                        
 3988/    16FA : 61E0                   	BSR.s		LAB_CKRN				; check not direct (back here if ok)
 3989/    16FC : 0C1D 0028              	CMP.b		#$28,(a5)+				; check next byte is "(" and increment
 3990/    1700 : 6600 EE6A              	BNE		LAB_SNER				; else do syntax error/warm start
 3991/    1704 :                        
 3992/    1704 : 177C 007E 05DF         	MOVE.b	#$7E,Sufnxf(a3)			; set FN variable flag bits
 3993/    170A : 6100 FCB4              	BSR		LAB_SVAR				; search for or create a variable
 3994/    170E :                        								; return the variable address in a0
 3995/    170E : 6100 FA90              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 3996/    1712 : 70BD                   	MOVEQ		#TK_EQUAL-$100,d0			; = token
 3997/    1714 : 6100 FA94              	BSR		LAB_SCCA				; scan for CHR$(A), else syntax error/warm start
 3998/    1718 :                        								; return character after d0
 3999/    1718 : 2F2B 046A              	MOVE.l	Varname(a3),-(sp)			; push current variable name
 4000/    171C : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 4001/    171E : 6100 F412              	BSR		LAB_DATA				; go perform DATA, find end of DEF FN statement
 4002/    1722 : 206B 05B0              	MOVEA.l	func_l(a3),a0			; get the function pointer
 4003/    1726 : 209F                   	MOVE.l	(sp)+,(a0)				; save BASIC execute pointer to function
 4004/    1728 : 215F 0004              	MOVE.l	(sp)+,4(a0)				; save current variable name to function
 4005/    172C : 4E75                   	RTS
 4006/    172E :                        
 4007/    172E :                        
 4008/    172E :                        ;************************************************************************************
 4009/    172E :                        ;
 4010/    172E :                        ; evaluate FNx
 4011/    172E :                        
 4012/    172E :                        LAB_201E
 4013/    172E : 177C 0081 05DF         	MOVE.b	#$81,Sufnxf(a3)			; set FN flag (find not create)
 4014/    1734 : 6100 FA7C              	BSR		LAB_IGBY				; increment & scan memory
 4015/    1738 : 6100 FC94              	BSR		LAB_1D12				; get FN name
 4016/    173C : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function type)
 4017/    1740 : 2F08                   	MOVE.l	a0,-(sp)				; push function pointer
 4018/    1742 : 0C15 0028              	CMP.b		#$28,(a5)				; check next byte is "(", no increment
 4019/    1746 : 6600 EE24              	BNE		LAB_SNER				; else do syntax error/warm start
 4020/    174A :                        
 4021/    174A : 6100 FA50              	BSR		LAB_1BF7				; evaluate expression within parentheses
 4022/    174E : 205F                   	MOVEA.l	(sp)+,a0				; pop function pointer
 4023/    1750 : 2748 05B0              	MOVE.l	a0,func_l(a3)			; set function pointer
 4024/    1754 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function expression type)
 4025/    1758 :                        
 4026/    1758 : 2028 0004              	MOVE.l	4(a0),d0				; get function variable name
 4027/    175C : 6100 FCDA              	BSR		LAB_1D4A				; go find function variable (already created)
 4028/    1760 :                        
 4029/    1760 :                        								; now check type match for variable
 4030/    1760 : 101F                   	MOVE.b	(sp)+,d0				; pop data type flag (function expression type)
 4031/    1762 : E318                   	ROL.b		#1,d0					; set carry if type = string
 4032/    1764 : 6100 F8D8              	BSR		LAB_CKTM				; type match check, set C for string
 4033/    1768 :                        
 4034/    1768 :                        								; now stack the function variable value before
 4035/    1768 :                        								; use
 4036/    1768 : 6712                   	BEQ.s		LAB_2043				; branch if not string
 4037/    176A :                        
 4038/    176A : 43EB 0476              	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
 4039/    176E : B9C9                   	CMPA.l	a1,a4					; compare string stack pointer with max+1
 4040/    1770 : 6700 EDC6              	BEQ		LAB_SCER				; if no space on the stack go do string too
 4041/    1774 :                        								; complex error
 4042/    1774 :                        
 4043/    1774 : 3928 0004              	MOVE.w	4(a0),-(a4)				; string length on descriptor stack
 4044/    1778 : 2910                   	MOVE.l	(a0),-(a4)				; string address on stack
 4045/    177A : 6002                   	BRA.s		LAB_204S				; skip var push
 4046/    177C :                        
 4047/    177C :                        LAB_2043
 4048/    177C : 2F10                   	MOVE.l	(a0),-(sp)				; push variable
 4049/    177E :                        LAB_204S
 4050/    177E : 2F08                   	MOVE.l	a0,-(sp)				; push variable address
 4051/    1780 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push variable data type
 4052/    1784 :                        
 4053/    1784 : 6132                   	BSR.s		LAB_2045				; pack function expression value into (a0)
 4054/    1786 :                        								; (function variable)
 4055/    1786 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 4056/    1788 : 206B 05B0              	MOVEA.l	func_l(a3),a0			; get function pointer
 4057/    178C : 2A50                   	MOVEA.l	(a0),a5				; save function execute ptr as BASIC execute ptr
 4058/    178E : 6100 F8C2              	BSR		LAB_EVEX				; evaluate expression
 4059/    1792 : 6100 FA20              	BSR		LAB_GBYT				; scan memory
 4060/    1796 : 6600 EDD4              	BNE		LAB_SNER				; if not [EOL] or [EOS] do syntax error and
 4061/    179A :                        								; warm start
 4062/    179A :                        
 4063/    179A : 2A5F                   	MOVE.l	(sp)+,a5				; restore BASIC execute pointer
 4064/    179C :                        
 4065/    179C :                        ; restore variable from stack and test data type
 4066/    179C :                        
 4067/    179C : 101F                   	MOVE.b	(sp)+,d0				; pull variable data type
 4068/    179E : 205F                   	MOVEA.l	(sp)+,a0				; pull variable address
 4069/    17A0 : 4A00                   	TST.b		d0					; test variable data type
 4070/    17A2 : 6A08                   	BPL.s		LAB_204T				; branch if not string
 4071/    17A4 :                        
 4072/    17A4 : 209C                   	MOVE.l	(a4)+,(a0)				; string address from descriptor stack
 4073/    17A6 : 315C 0004              	MOVE.w	(a4)+,4(a0)				; string length from descriptor stack
 4074/    17AA : 6002                   	BRA.s		LAB_2044				; skip variable pull
 4075/    17AC :                        
 4076/    17AC :                        LAB_204T
 4077/    17AC : 209F                   	MOVE.l	(sp)+,(a0)				; restore variable from stack
 4078/    17AE :                        LAB_2044
 4079/    17AE : 101F                   	MOVE.b	(sp)+,d0				; pop data type flag (function type)
 4080/    17B0 : E318                   	ROL.b		#1,d0					; set carry if type = string
 4081/    17B2 : 6100 F88A              	BSR		LAB_CKTM				; type match check, set C for string
 4082/    17B6 : 4E75                   	RTS
 4083/    17B8 :                        
 4084/    17B8 :                        LAB_2045
 4085/    17B8 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 4086/    17BC : 6A00 07F0              	BPL		LAB_2778				; if numeric pack FAC1 into variable (a0)
 4087/    17C0 :                        								; and return
 4088/    17C0 :                        
 4089/    17C0 : 2448                   	MOVEA.l	a0,a2					; copy variable pointer
 4090/    17C2 : 6000 F512              	BRA		LAB_17D6				; go do string LET & return
 4091/    17C6 :                        
 4092/    17C6 :                        
 4093/    17C6 :                        
 4094/    17C6 :                        ;************************************************************************************
 4095/    17C6 :                        ;
 4096/    17C6 :                        ; perform STR$()
 4097/    17C6 :                        
 4098/    17C6 :                        LAB_STRS
 4099/    17C6 : 6100 0950              	BSR		LAB_2970				; convert FAC1 to string
 4100/    17CA :                        
 4101/    17CA :                        ; scan, set up string
 4102/    17CA :                        ; print " terminated string to FAC1 stack
 4103/    17CA :                        
 4104/    17CA :                        LAB_20AE
 4105/    17CA : 7422                   	MOVEQ		#$22,d2				; set Srchc character (terminator 1)
 4106/    17CC : 3602                   	MOVE.w	d2,d3					; set Asrch character (terminator 2)
 4107/    17CE :                        
 4108/    17CE :                        ; print d2/d3 terminated string to FAC1 stack
 4109/    17CE :                        ; d2 = Srchc, d3 = Asrch, a0 is source
 4110/    17CE :                        ; a6 is temp
 4111/    17CE :                        
 4112/    17CE :                        LAB_20B4
 4113/    17CE : 7200                   	MOVEQ		#0,d1					; clear longword
 4114/    17D0 : 5341                   	SUBQ.w	#1,d1					; set length to -1
 4115/    17D2 : 2448                   	MOVEA.l	a0,a2					; copy start to calculate end
 4116/    17D4 :                        LAB_20BE
 4117/    17D4 : 5241                   	ADDQ.w	#1,d1					; increment length
 4118/    17D6 : 1030 1000              	MOVE.b	(a0,d1.w),d0			; get byte from string
 4119/    17DA : 6710                   	BEQ.s		LAB_20D0				; exit loop if null byte [EOS]
 4120/    17DC :                        
 4121/    17DC : B002                   	CMP.b		d2,d0					; compare with search character (terminator 1)
 4122/    17DE : 6704                   	BEQ.s		LAB_20CB				; branch if terminator
 4123/    17E0 :                        
 4124/    17E0 : B003                   	CMP.b		d3,d0					; compare with terminator 2
 4125/    17E2 : 66F0                   	BNE.s		LAB_20BE				; loop if not terminator 2 (or null string)
 4126/    17E4 :                        
 4127/    17E4 :                        LAB_20CB
 4128/    17E4 : B03C 0022              	CMP.b		#$22,d0				; compare with "
 4129/    17E8 : 6602                   	BNE.s		LAB_20D0				; branch if not "
 4130/    17EA :                        
 4131/    17EA : 524A                   	ADDQ.w	#1,a2					; else increment string start (skip " at end)
 4132/    17EC :                        LAB_20D0
 4133/    17EC : D5C1                   	ADDA.l	d1,a2					; add longowrd length to make string end+1
 4134/    17EE :                        
 4135/    17EE : B1CB                   	CMPA.l	a3,a0					; is string in ram
 4136/    17F0 : 651E                   	BCS.s		LAB_RTST				; if not go push descriptor on stack & exit
 4137/    17F2 :                        								; (could be message string from ROM)
 4138/    17F2 :                        
 4139/    17F2 : B1EB 042E              	CMPA.l	Smeml(a3),a0			; is string in utility ram
 4140/    17F6 : 6418                   	BCC.s		LAB_RTST				; if not go push descriptor on stack & exit
 4141/    17F8 :                        								; (is in string or program space)
 4142/    17F8 :                        
 4143/    17F8 :                        								; (else) copy string to string memory
 4144/    17F8 :                        LAB_20C9
 4145/    17F8 : 2248                   	MOVEA.l	a0,a1					; copy descriptor pointer
 4146/    17FA : 2001                   	MOVE.l	d1,d0					; copy longword length
 4147/    17FC : 6604                   	BNE.s		LAB_20D8				; branch if not null string
 4148/    17FE :                        
 4149/    17FE : 2041                   	MOVEA.l	d1,a0					; make null pointer
 4150/    1800 : 600E                   	BRA.s		LAB_RTST				; go push descriptor on stack & exit
 4151/    1802 :                        
 4152/    1802 :                        LAB_20D8
 4153/    1802 : 6126                   	BSR.s		LAB_2115				; make string space d1 bytes long
 4154/    1804 : D1C1                   	ADDA.l	d1,a0					; new string end
 4155/    1806 : D3C1                   	ADDA.l	d1,a1					; old string end
 4156/    1808 : 5340                   	SUBQ.w	#1,d0					; -1 for DBF loop
 4157/    180A :                        LAB_20E0
 4158/    180A : 1121                   	MOVE.b	-(a1),-(a0)				; copy byte (source can be odd aligned)
 4159/    180C : 51C8 FFFC              	DBF		d0,LAB_20E0				; loop until done
 4160/    1810 :                        
 4161/    1810 :                        
 4162/    1810 :                        
 4163/    1810 :                        ;************************************************************************************
 4164/    1810 :                        ;
 4165/    1810 :                        ; check for space on descriptor stack then ...
 4166/    1810 :                        ; put string address and length on descriptor stack & update stack pointers
 4167/    1810 :                        ; start is in a0, length is in d1
 4168/    1810 :                        
 4169/    1810 :                        LAB_RTST
 4170/    1810 : 43EB 0476              	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
 4171/    1814 : B9C9                   	CMPA.l	a1,a4					; compare string stack pointer with max+1
 4172/    1816 : 6700 ED20              	BEQ		LAB_SCER				; if no space on string stack ..
 4173/    181A :                        								; .. go do 'string too complex' error
 4174/    181A :                        
 4175/    181A :                        								; push string & update pointers
 4176/    181A : 3901                   	MOVE.w	d1,-(a4)				; string length on descriptor stack
 4177/    181C : 2908                   	MOVE.l	a0,-(a4)				; string address on stack
 4178/    181E : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; string descriptor pointer in FAC1
 4179/    1822 : 177C 0080 05B5         	MOVE.b	#$80,Dtypef(a3)			; save data type flag, $80=string
 4180/    1828 : 4E75                   	RTS
 4181/    182A :                        
 4182/    182A :                        
 4183/    182A :                        ;************************************************************************************
 4184/    182A :                        ;
 4185/    182A :                        ; build descriptor a0/d1
 4186/    182A :                        ; make space in string memory for string d1.w long
 4187/    182A :                        ; return pointer in a0/Sutill
 4188/    182A :                        
 4189/    182A :                        LAB_2115
 4190/    182A : 4A41                   	TST.w		d1					; test length
 4191/    182C : 672E                   	BEQ.s		LAB_2128				; branch if user wants null string
 4192/    182E :                        
 4193/    182E :                        								; make space for string d1 long
 4194/    182E : 2F00                   	MOVE.l	d0,-(sp)				; save d0
 4195/    1830 : 7000                   	MOVEQ		#0,d0					; clear longword
 4196/    1832 : 1740 05DE              	MOVE.b	d0,Gclctd(a3)			; clear garbage collected flag (b7)
 4197/    1836 : 7001                   	MOVEQ		#1,d0					; +1 to possibly round up
 4198/    1838 : C041                   	AND.w		d1,d0					; mask odd bit
 4199/    183A : D041                   	ADD.w		d1,d0					; ensure d0 is even length
 4200/    183C : 6404                   	BCC.s		LAB_2117				; branch if no overflow
 4201/    183E :                        
 4202/    183E : 7001                   	MOVEQ		#1,d0					; set to allocate 65536 bytes
 4203/    1840 : 4840                   	SWAP		d0					; makes $00010000
 4204/    1842 :                        LAB_2117
 4205/    1842 : 206B 0446              	MOVEA.l	Sstorl(a3),a0			; get bottom of string space
 4206/    1846 : 91C0                   	SUBA.l	d0,a0					; subtract string length
 4207/    1848 : B1EB 0442              	CMPA.l	Earryl(a3),a0			; compare with top of array space
 4208/    184C : 6512                   	BCS.s		LAB_2137				; if less do out of memory error
 4209/    184E :                        
 4210/    184E : 2748 0446              	MOVE.l	a0,Sstorl(a3)			; save bottom of string space
 4211/    1852 : 2748 044E              	MOVE.l	a0,Sutill(a3)			; save string utility pointer
 4212/    1856 : 201F                   	MOVE.l	(sp)+,d0				; restore d0
 4213/    1858 : 4A41                   	TST.w		d1					; set flags on length
 4214/    185A : 4E75                   	RTS
 4215/    185C :                        
 4216/    185C :                        LAB_2128
 4217/    185C : 3041                   	MOVEA.w	d1,a0					; make null pointer
 4218/    185E : 4E75                   	RTS
 4219/    1860 :                        
 4220/    1860 :                        LAB_2137
 4221/    1860 : 4A2B 05DE              	TST.b		Gclctd(a3)				; get garbage collected flag
 4222/    1864 : 6B00 ECF2              	BMI		LAB_OMER				; do "Out of memory" error, then warm start
 4223/    1868 :                        
 4224/    1868 : 2F09                   	MOVE.l	a1,-(sp)				; save a1
 4225/    186A : 610A                   	BSR.s		LAB_GARB				; else go do garbage collection
 4226/    186C : 225F                   	MOVEA.l	(sp)+,a1				; restore a1
 4227/    186E : 177C 0080 05DE         	MOVE.b	#$80,Gclctd(a3)			; set garbage collected flag
 4228/    1874 : 60CC                   	BRA.s		LAB_2117				; go try again
 4229/    1876 :                        
 4230/    1876 :                        
 4231/    1876 :                        ;************************************************************************************
 4232/    1876 :                        ;
 4233/    1876 :                        ; garbage collection routine
 4234/    1876 :                        
 4235/    1876 :                        LAB_GARB
 4236/    1876 : 48E7 E0E0              	MOVEM.l	d0-d2/a0-a2,-(sp)			; save registers
 4237/    187A : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; start with no strings
 4238/    1880 :                        
 4239/    1880 :                        								; re-run routine from last ending
 4240/    1880 :                        LAB_214B
 4241/    1880 : 222B 0442              	MOVE.l	Earryl(a3),d1			; set highest uncollected string so far
 4242/    1884 : 7000                   	MOVEQ		#0,d0					; clear longword
 4243/    1886 : 2240                   	MOVEA.l	d0,a1					; clear string to move pointer
 4244/    1888 : 206B 043A              	MOVEA.l	Sstrl(a3),a0			; set pointer to start of strings
 4245/    188C : 41E8 0004              	LEA		4(a0),a0				; index to string pointer
 4246/    1890 : 246B 043E              	MOVEA.l	Sarryl(a3),a2			; set end pointer to start of arrays (end of
 4247/    1894 :                        								; strings)
 4248/    1894 : 6008                   	BRA.s		LAB_2176				; branch into loop at end loop test
 4249/    1896 :                        
 4250/    1896 :                        LAB_2161
 4251/    1896 : 6100 0084              	BSR		LAB_2206				; test and set if this is the highest string
 4252/    189A : 41E8 000A              	LEA		10(a0),a0				; increment to next string
 4253/    189E :                        LAB_2176
 4254/    189E : B1CA                   	CMPA.l	a2,a0					; compare end of area with pointer
 4255/    18A0 : 65F4                   	BCS.s		LAB_2161				; go do next if not at end
 4256/    18A2 :                        
 4257/    18A2 :                        ; done strings, now do arrays.
 4258/    18A2 :                        
 4259/    18A2 : 41E8 FFFC              	LEA		-4(a0),a0				; decrement pointer to start of arrays
 4260/    18A6 : 246B 0442              	MOVEA.l	Earryl(a3),a2			; set end pointer to end of arrays
 4261/    18AA : 6024                   	BRA.s		LAB_218F				; branch into loop at end loop test
 4262/    18AC :                        
 4263/    18AC :                        LAB_217E
 4264/    18AC : 2428 0004              	MOVE.l	4(a0),d2				; get array size
 4265/    18B0 : D488                   	ADD.l		a0,d2					; makes start of next array
 4266/    18B2 :                        
 4267/    18B2 : 2010                   	MOVE.l	(a0),d0				; get array name
 4268/    18B4 : 0800 0017              	BTST		#23,d0				; test string flag
 4269/    18B8 : 6714                   	BEQ.s		LAB_218B				; branch if not string
 4270/    18BA :                        
 4271/    18BA : 3028 0008              	MOVE.w	8(a0),d0				; get # of dimensions
 4272/    18BE : D040                   	ADD.w		d0,d0					; *2
 4273/    18C0 : D0C0                   	ADDA.w	d0,a0					; add to skip dimension size(s)
 4274/    18C2 : 41E8 000A              	LEA		10(a0),a0				; increment to first element
 4275/    18C6 :                        LAB_2183
 4276/    18C6 : 6154                   	BSR.s		LAB_2206				; test and set if this is the highest string
 4277/    18C8 : 5C48                   	ADDQ.w	#6,a0					; increment to next element
 4278/    18CA : B1C2                   	CMPA.l	d2,a0					; compare with start of next array
 4279/    18CC : 66F8                   	BNE.s		LAB_2183				; go do next if not at end of array
 4280/    18CE :                        
 4281/    18CE :                        LAB_218B
 4282/    18CE : 2042                   	MOVEA.l	d2,a0					; pointer to next array
 4283/    18D0 :                        LAB_218F
 4284/    18D0 : B5C8                   	CMPA.l	a0,a2					; compare pointer with array end
 4285/    18D2 : 66D8                   	BNE.s		LAB_217E				; go do next if not at end
 4286/    18D4 :                        
 4287/    18D4 :                        ; done arrays and variables, now just the descriptor stack to do
 4288/    18D4 :                        
 4289/    18D4 : 204C                   	MOVEA.l	a4,a0					; get descriptor stack pointer
 4290/    18D6 : 45EB 048E              	LEA		des_sk(a3),a2			; set end pointer to end of stack
 4291/    18DA : 6006                   	BRA.s		LAB_21C4				; branch into loop at end loop test
 4292/    18DC :                        
 4293/    18DC :                        LAB_21C2
 4294/    18DC : 613E                   	BSR.s		LAB_2206				; test and set if this is the highest string
 4295/    18DE : 41E8 0006              	LEA		6(a0),a0				; increment to next string
 4296/    18E2 :                        LAB_21C4
 4297/    18E2 : B5C8                   	CMPA.l	a0,a2					; compare pointer with stack end
 4298/    18E4 : 66F6                   	BNE.s		LAB_21C2				; go do next if not at end
 4299/    18E6 :                        
 4300/    18E6 :                        ; descriptor search complete, now either exit or set-up and move string
 4301/    18E6 :                        
 4302/    18E6 : 2009                   	MOVE.l	a1,d0					; set the flags (a1 is move string)
 4303/    18E8 : 672C                   	BEQ.s		LAB_21D1				; go tidy up and exit if no move
 4304/    18EA :                        
 4305/    18EA : 2051                   	MOVEA.l	(a1),a0				; a0 is now string start
 4306/    18EC : 7200                   	MOVEQ		#0,d1					; clear d1
 4307/    18EE : 3229 0004              	MOVE.w	4(a1),d1				; d1 is string length
 4308/    18F2 : 5281                   	ADDQ.l	#1,d1					; +1
 4309/    18F4 : C23C 00FE              	AND.b		#$FE,d1				; make even length
 4310/    18F8 : D1C1                   	ADDA.l	d1,a0					; pointer is now to string end+1
 4311/    18FA : 246B 0446              	MOVEA.l	Sstorl(a3),a2			; is destination end+1
 4312/    18FE : B1CA                   	CMPA.l	a2,a0					; does the string need moving
 4313/    1900 : 670C                   	BEQ.s		LAB_2240				; branch if not
 4314/    1902 :                        
 4315/    1902 : E289                   	LSR.l		#1,d1					; word move so do /2
 4316/    1904 : 5341                   	SUBQ.w	#1,d1					; -1 for DBF loop
 4317/    1906 :                        LAB_2216
 4318/    1906 : 3520                   	MOVE.w	-(a0),-(a2)				; copy word
 4319/    1908 : 51C9 FFFC              	DBF		d1,LAB_2216				; loop until done
 4320/    190C :                        
 4321/    190C : 228A                   	MOVE.l	a2,(a1)				; save new string start
 4322/    190E :                        LAB_2240
 4323/    190E : 2751 0446              	MOVE.l	(a1),Sstorl(a3)			; string start is new string mem start
 4324/    1912 : 6000 FF6C              	BRA		LAB_214B				; re-run routine from last ending
 4325/    1916 :                        								; (but don't collect this string)
 4326/    1916 :                        
 4327/    1916 :                        LAB_21D1
 4328/    1916 : 4CDF 0707              	MOVEM.l	(sp)+,d0-d2/a0-a2			; restore registers
 4329/    191A : 4E75                   	RTS
 4330/    191C :                        
 4331/    191C :                        ; test and set if this is the highest string
 4332/    191C :                        
 4333/    191C :                        LAB_2206
 4334/    191C : 2010                   	MOVE.l	(a0),d0				; get this string pointer
 4335/    191E : 6728                   	BEQ.s		RTS_012				; exit if null string
 4336/    1920 :                        
 4337/    1920 : B280                   	CMP.l		d0,d1					; compare with highest uncollected string so far
 4338/    1922 : 6424                   	BCC.s		RTS_012				; exit if <= with highest so far
 4339/    1924 :                        
 4340/    1924 : B0AB 0446              	CMP.l		Sstorl(a3),d0			; compare with bottom of string space
 4341/    1928 : 641E                   	BCC.s		RTS_012				; exit if >= bottom of string space
 4342/    192A :                        
 4343/    192A : 70FF                   	MOVEQ		#-1,d0				; d0 = $FFFFFFFF
 4344/    192C : 3028 0004              	MOVE.w	4(a0),d0				; d0 is string length
 4345/    1930 : 4440                   	NEG.w		d0					; make -ve
 4346/    1932 : C03C 00FE              	AND.b		#$FE,d0				; make -ve even length
 4347/    1936 : D0AB 0446              	ADD.l		Sstorl(a3),d0			; add string store to -ve length
 4348/    193A : B090                   	CMP.l		(a0),d0				; compare with string address
 4349/    193C : 6706                   	BEQ.s		LAB_2212				; if = go move string store pointer down
 4350/    193E :                        
 4351/    193E : 2210                   	MOVE.l	(a0),d1				; highest = current
 4352/    1940 : 2248                   	MOVEA.l	a0,a1					; string to move = current
 4353/    1942 : 4E75                   	RTS
 4354/    1944 :                        
 4355/    1944 :                        LAB_2212
 4356/    1944 : 2740 0446              	MOVE.l	d0,Sstorl(a3)			; set new string store start
 4357/    1948 :                        RTS_012
 4358/    1948 : 4E75                   	RTS
 4359/    194A :                        
 4360/    194A :                        
 4361/    194A :                        ;************************************************************************************
 4362/    194A :                        ;
 4363/    194A :                        ; concatenate - add strings
 4364/    194A :                        ; string descriptor 1 is in FAC1_m, string 2 is in line
 4365/    194A :                        
 4366/    194A :                        LAB_224D
 4367/    194A : 487A F738              	PEA		LAB_1ADB(pc)			; continue evaluation after concatenate
 4368/    194E : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; stack descriptor pointer for string 1
 4369/    1952 :                        
 4370/    1952 : 6100 F80C              	BSR		LAB_GVAL				; get value from line
 4371/    1956 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 4372/    195A : 6A00 EBE4              	BPL		LAB_TMER				; if type is not string do type mismatch error
 4373/    195E :                        
 4374/    195E : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer for string 1
 4375/    1960 :                        
 4376/    1960 :                        ;************************************************************************************
 4377/    1960 :                        ;
 4378/    1960 :                        ; concatenate
 4379/    1960 :                        ; string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
 4380/    1960 :                        
 4381/    1960 :                        LAB_224E
 4382/    1960 : 226B 0590              	MOVEA.l	FAC1_m(a3),a1			; copy descriptor pointer 2
 4383/    1964 : 3228 0004              	MOVE.w	4(a0),d1				; get length 1
 4384/    1968 : D269 0004              	ADD.w		4(a1),d1				; add length 2
 4385/    196C : 6500 EBCE              	BCS		LAB_SLER				; if overflow go do 'string too long' error
 4386/    1970 :                        
 4387/    1970 : 2F08                   	MOVE.l	a0,-(sp)				; save descriptor pointer 1
 4388/    1972 : 6100 FEB6              	BSR		LAB_2115				; make space d1 bytes long
 4389/    1976 : 2748 0598              	MOVE.l	a0,FAC2_m(a3)			; save new string start pointer
 4390/    197A : 2057                   	MOVEA.l	(sp),a0				; copy descriptor pointer 1 from stack
 4391/    197C : 3028 0004              	MOVE.w	4(a0),d0				; get length
 4392/    1980 : 2050                   	MOVEA.l	(a0),a0				; get string pointer
 4393/    1982 : 6120                   	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
 4394/    1984 :                        								; return with a0 = pointer, d1 = length
 4395/    1984 :                        
 4396/    1984 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer for string 2
 4397/    1988 : 6138                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4398/    198A :                        								; a0 = pointer, d0 = length
 4399/    198A : 6118                   	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
 4400/    198C :                        								; return with a0 = pointer, d1 = length
 4401/    198C :                        
 4402/    198C : 205F                   	MOVEA.l	(sp)+,a0				; get descriptor pointer for string 1
 4403/    198E : 6132                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4404/    1990 :                        								; d0 = length, a0 = pointer
 4405/    1990 :                        
 4406/    1990 : 206B 0598              	MOVEA.l	FAC2_m(a3),a0			; retreive the result string pointer
 4407/    1994 : 2208                   	MOVE.l	a0,d1					; copy the result string pointer
 4408/    1996 : 6700 FE78              	BEQ		LAB_RTST				; if it is a null string just return it
 4409/    199A :                        								; a0 = pointer, d1 = length
 4410/    199A :                        
 4411/    199A : 4481                   	NEG.l		d1					; else make the start pointer negative
 4412/    199C : D2AB 044E              	ADD.l		Sutill(a3),d1			; add the end pointert to give the length
 4413/    19A0 : 6000 FE6E              	BRA		LAB_RTST				; push string on descriptor stack
 4414/    19A4 :                        								; a0 = pointer, d1 = length
 4415/    19A4 :                        
 4416/    19A4 :                        
 4417/    19A4 :                        ;************************************************************************************
 4418/    19A4 :                        ;
 4419/    19A4 :                        ; copy string d0 bytes long from a0 to Sutill
 4420/    19A4 :                        ; return with a0 = pointer, d1 = length
 4421/    19A4 :                        
 4422/    19A4 :                        LAB_229E
 4423/    19A4 : 3200                   	MOVE.w	d0,d1					; copy and check length
 4424/    19A6 : 6714                   	BEQ.s		RTS_013				; skip copy if null
 4425/    19A8 :                        
 4426/    19A8 : 226B 044E              	MOVEA.l	Sutill(a3),a1			; get destination pointer
 4427/    19AC : 2F09                   	MOVE.l	a1,-(sp)				; save destination string pointer
 4428/    19AE : 5340                   	SUBQ.w	#1,d0					; subtract for DBF loop
 4429/    19B0 :                        LAB_22A0
 4430/    19B0 : 12D8                   	MOVE.b	(a0)+,(a1)+				; copy byte
 4431/    19B2 : 51C8 FFFC              	DBF		d0,LAB_22A0				; loop if not done
 4432/    19B6 :                        
 4433/    19B6 : 2749 044E              	MOVE.l	a1,Sutill(a3)			; update Sutill to end of copied string
 4434/    19BA : 205F                   	MOVEA.l	(sp)+,a0				; restore destination string pointer
 4435/    19BC :                        RTS_013
 4436/    19BC : 4E75                   	RTS
 4437/    19BE :                        
 4438/    19BE :                        
 4439/    19BE :                        ;************************************************************************************
 4440/    19BE :                        ;
 4441/    19BE :                        ; pop string off descriptor stack, or from top of string space
 4442/    19BE :                        ; returns with d0.l = length, a0 = pointer
 4443/    19BE :                        
 4444/    19BE :                        LAB_22B6
 4445/    19BE : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
 4446/    19C2 :                        
 4447/    19C2 :                        
 4448/    19C2 :                        ;************************************************************************************
 4449/    19C2 :                        ;
 4450/    19C2 :                        ; pop (a0) descriptor off stack or from string space
 4451/    19C2 :                        ; returns with d0.l = length, a0 = pointer
 4452/    19C2 :                        
 4453/    19C2 :                        LAB_22BA
 4454/    19C2 : 48E7 4040              	MOVEM.l	a1/d1,-(sp)				; save other regs
 4455/    19C6 : B9C8                   	CMPA.l	a0,a4					; is string on the descriptor stack
 4456/    19C8 : 6602                   	BNE.s		LAB_22BD				; skip pop if not
 4457/    19CA :                        
 4458/    19CA : 5C4C                   	ADDQ.w	#$06,a4				; else update stack pointer
 4459/    19CC :                        LAB_22BD
 4460/    19CC : 7000                   	MOVEQ		#0,d0					; clear string length longword
 4461/    19CE : 2258                   	MOVEA.l	(a0)+,a1				; get string address
 4462/    19D0 : 3018                   	MOVE.w	(a0)+,d0				; get string length
 4463/    19D2 :                        
 4464/    19D2 : B9C8                   	CMPA.l	a0,a4					; was it on the descriptor stack
 4465/    19D4 : 6610                   	BNE.s		LAB_22E6				; branch if it wasn't
 4466/    19D6 :                        
 4467/    19D6 : B3EB 0446              	CMPA.l	Sstorl(a3),a1			; compare string address with bottom of string
 4468/    19DA :                        								; space
 4469/    19DA : 660A                   	BNE.s		LAB_22E6				; branch if <>
 4470/    19DC :                        
 4471/    19DC : 7201                   	MOVEQ		#1,d1					; mask for odd bit
 4472/    19DE : C240                   	AND.w		d0,d1					; AND length
 4473/    19E0 : D280                   	ADD.l		d0,d1					; make it fit word aligned length
 4474/    19E2 :                        
 4475/    19E2 : D3AB 0446              	ADD.l		d1,Sstorl(a3)			; add to bottom of string space
 4476/    19E6 :                        LAB_22E6
 4477/    19E6 : 2049                   	MOVEA.l	a1,a0					; copy to a0
 4478/    19E8 : 4CDF 0202              	MOVEM.l	(sp)+,a1/d1				; restore other regs
 4479/    19EC : 4A80                   	TST.l		d0					; set flags on length
 4480/    19EE : 4E75                   	RTS
 4481/    19F0 :                        
 4482/    19F0 :                        
 4483/    19F0 :                        ;************************************************************************************
 4484/    19F0 :                        ;
 4485/    19F0 :                        ; perform CHR$()
 4486/    19F0 :                        
 4487/    19F0 :                        LAB_CHRS
 4488/    19F0 : 6100 0130              	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
 4489/    19F4 :                        								; Itemp
 4490/    19F4 :                        LAB_MKCHR
 4491/    19F4 : 7201                   	MOVEQ		#1,d1					; string is single byte
 4492/    19F6 : 6100 FE32              	BSR		LAB_2115				; make string space d1 bytes long
 4493/    19FA :                        								; return a0/Sutill = pointer, others unchanged
 4494/    19FA : 1080                   	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
 4495/    19FC : 6000 FE12              	BRA		LAB_RTST				; push string on descriptor stack
 4496/    1A00 :                        								; a0 = pointer, d1 = length
 4497/    1A00 :                        
 4498/    1A00 :                        
 4499/    1A00 :                        ;************************************************************************************
 4500/    1A00 :                        ;
 4501/    1A00 :                        ; perform LEFT$()
 4502/    1A00 :                        
 4503/    1A00 :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4504/    1A00 :                        
 4505/    1A00 :                        LAB_LEFT
 4506/    1A00 : C141                   	EXG		d0,d1					; word in d1
 4507/    1A02 : 6100 F79C              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4508/    1A06 :                        
 4509/    1A06 : 4A81                   	TST.l		d1					; test returned length
 4510/    1A08 : 6722                   	BEQ.s		LAB_231C				; branch if null return
 4511/    1A0A :                        
 4512/    1A0A : 7000                   	MOVEQ		#0,d0					; clear start offset
 4513/    1A0C : B268 0004              	CMP.w		4(a0),d1				; compare word parameter with string length
 4514/    1A10 : 651A                   	BCS.s		LAB_231C				; branch if string length > word parameter
 4515/    1A12 :                        
 4516/    1A12 : 6014                   	BRA.s		LAB_2317				; go copy whole string
 4517/    1A14 :                        
 4518/    1A14 :                        
 4519/    1A14 :                        ;************************************************************************************
 4520/    1A14 :                        ;
 4521/    1A14 :                        ; perform RIGHT$()
 4522/    1A14 :                        
 4523/    1A14 :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4524/    1A14 :                        
 4525/    1A14 :                        LAB_RIGHT
 4526/    1A14 : C141                   	EXG		d0,d1					; word in d1
 4527/    1A16 : 6100 F788              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4528/    1A1A :                        
 4529/    1A1A : 4A81                   	TST.l		d1					; test returned length
 4530/    1A1C : 670E                   	BEQ.s		LAB_231C				; branch if null return
 4531/    1A1E :                        
 4532/    1A1E : 3028 0004              	MOVE.w	4(a0),d0				; get string length
 4533/    1A22 : 9081                   	SUB.l		d1,d0					; subtract word
 4534/    1A24 : 6406                   	BCC.s		LAB_231C				; branch if string length > word parameter
 4535/    1A26 :                        
 4536/    1A26 :                        								; else copy whole string
 4537/    1A26 :                        LAB_2316
 4538/    1A26 : 7000                   	MOVEQ		#0,d0					; clear start offset
 4539/    1A28 :                        LAB_2317
 4540/    1A28 : 3228 0004              	MOVE.w	4(a0),d1				; else make parameter = length
 4541/    1A2C :                        
 4542/    1A2C :                        ; get here with ...
 4543/    1A2C :                        ;   a0 - points to descriptor
 4544/    1A2C :                        ;   d0 - is offset from string start
 4545/    1A2C :                        ;   d1 - is required string length
 4546/    1A2C :                        
 4547/    1A2C :                        LAB_231C
 4548/    1A2C : 2248                   	MOVEA.l	a0,a1					; save string descriptor pointer
 4549/    1A2E : 6100 FDFA              	BSR		LAB_2115				; make string space d1 bytes long
 4550/    1A32 :                        								; return a0/Sutill = pointer, others unchanged
 4551/    1A32 : 2049                   	MOVEA.l	a1,a0					; restore string descriptor pointer
 4552/    1A34 : 2F00                   	MOVE.l	d0,-(sp)				; save start offset (longword)
 4553/    1A36 : 618A                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4554/    1A38 :                        								; d0 = length, a0 = pointer
 4555/    1A38 : D1DF                   	ADDA.l	(sp)+,a0				; adjust pointer to start of wanted string
 4556/    1A3A : 3001                   	MOVE.w	d1,d0					; length to d0
 4557/    1A3C : 6100 FF66              	BSR		LAB_229E				; store string d0 bytes long from (a0) to
 4558/    1A40 :                        								; (Sutill) return with a0 = pointer,
 4559/    1A40 :                        								; d1 = length
 4560/    1A40 : 6000 FDCE              	BRA		LAB_RTST				; push string on descriptor stack
 4561/    1A44 :                        								; a0 = pointer, d1 = length
 4562/    1A44 :                        
 4563/    1A44 :                        
 4564/    1A44 :                        ;************************************************************************************
 4565/    1A44 :                        ;
 4566/    1A44 :                        ; perform MID$()
 4567/    1A44 :                        
 4568/    1A44 :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4569/    1A44 :                        
 4570/    1A44 :                        LAB_MIDS
 4571/    1A44 : 7E00                   	MOVEQ		#0,d7					; clear longword
 4572/    1A46 : 5347                   	SUBQ.w	#1,d7					; set default length = 65535
 4573/    1A48 : 2F00                   	MOVE.l	d0,-(sp)				; save word 1
 4574/    1A4A : 6100 F768              	BSR		LAB_GBYT				; scan memory
 4575/    1A4E : B03C 002C              	CMP.b		#',',d0				; was it ","
 4576/    1A52 : 660C                   	BNE.s		LAB_2358				; branch if not "," (skip second byte get)
 4577/    1A54 :                        
 4578/    1A54 : 101D                   	MOVE.b	(a5)+,d0				; increment pointer past ","
 4579/    1A56 : 2F08                   	MOVE.l	a0,-(sp)				; save descriptor pointer
 4580/    1A58 : 6100 00DA              	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
 4581/    1A5C : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer
 4582/    1A5E : 2E00                   	MOVE.l	d0,d7					; copy length
 4583/    1A60 :                        LAB_2358
 4584/    1A60 : 6100 F73E              	BSR		LAB_1BFB				; scan for ")", else do syntax error then warm
 4585/    1A64 :                        								; start
 4586/    1A64 : 201F                   	MOVE.l	(sp)+,d0				; restore word 1
 4587/    1A66 : 7200                   	MOVEQ		#0,d1					; null length
 4588/    1A68 : 5380                   	SUBQ.l	#1,d0					; decrement start index (word 1)
 4589/    1A6A : 6B00 EAF4              	BMI		LAB_FCER				; if was null do function call error then warm
 4590/    1A6E :                        								; start
 4591/    1A6E :                        
 4592/    1A6E : B068 0004              	CMP.w		4(a0),d0				; compare string length with start index
 4593/    1A72 : 64B8                   	BCC.s		LAB_231C				; if start not in string do null string (d1=0)
 4594/    1A74 :                        
 4595/    1A74 : 2207                   	MOVE.l	d7,d1					; get length back
 4596/    1A76 : DE40                   	ADD.w		d0,d7					; d7 now = MID$() end
 4597/    1A78 : 6506                   	BCS.s		LAB_2368				; already too long so do RIGHT$ equivalent
 4598/    1A7A :                        
 4599/    1A7A : BE68 0004              	CMP.w		4(a0),d7				; compare string length with start index+length
 4600/    1A7E : 65AC                   	BCS.s		LAB_231C				; if end in string go do string
 4601/    1A80 :                        
 4602/    1A80 :                        LAB_2368
 4603/    1A80 : 3228 0004              	MOVE.w	4(a0),d1				; get string length
 4604/    1A84 : 9240                   	SUB.w		d0,d1					; subtract start offset
 4605/    1A86 : 60A4                   	BRA.s		LAB_231C				; go do string (effectively RIGHT$)
 4606/    1A88 :                        
 4607/    1A88 :                        
 4608/    1A88 :                        ;************************************************************************************
 4609/    1A88 :                        ;
 4610/    1A88 :                        ; perform LCASE$()
 4611/    1A88 :                        
 4612/    1A88 :                        LAB_LCASE
 4613/    1A88 : 6100 FF34              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4614/    1A8C :                        								; returns with d0 = length, a0 = pointer
 4615/    1A8C : 2200                   	MOVE.l	d0,d1					; copy the string length
 4616/    1A8E : 6756                   	BEQ.s		NoString				; if null go return a null string
 4617/    1A90 :                        
 4618/    1A90 :                        ; else copy and change the string
 4619/    1A90 :                        
 4620/    1A90 : 2248                   	MOVEA.l	a0,a1					; copy the string address
 4621/    1A92 : 6100 FD96              	BSR		LAB_2115				; make a string space d1 bytes long
 4622/    1A96 : D1C1                   	ADDA.l	d1,a0					; new string end
 4623/    1A98 : D3C1                   	ADDA.l	d1,a1					; old string end
 4624/    1A9A : 3401                   	MOVE.w	d1,d2					; copy length for loop
 4625/    1A9C : 5342                   	SUBQ.w	#1,d2					; -1 for DBF loop
 4626/    1A9E :                        LC_loop
 4627/    1A9E : 1021                   	MOVE.b	-(a1),d0				; get byte from string
 4628/    1AA0 :                        
 4629/    1AA0 : B03C 005B              	CMP.b		#$5B,d0				; compare with "Z"+1
 4630/    1AA4 : 640A                   	BCC.s		NoUcase				; if > "Z" skip change
 4631/    1AA6 :                        
 4632/    1AA6 : B03C 0041              	CMP.b		#$41,d0				; compare with "A"
 4633/    1AAA : 6504                   	BCS.s		NoUcase				; if < "A" skip change
 4634/    1AAC :                        
 4635/    1AAC : 0000 0020              	ORI.b		#$20,d0				; convert upper case to lower case
 4636/    1AB0 :                        NoUcase
 4637/    1AB0 : 1100                   	MOVE.b	d0,-(a0)				; copy upper case byte back to string
 4638/    1AB2 : 51CA FFEA              	DBF		d2,LC_loop				; decrement and loop if not all done
 4639/    1AB6 :                        
 4640/    1AB6 : 602E                   	BRA.s		NoString				; tidy up & exit (branch always)
 4641/    1AB8 :                        
 4642/    1AB8 :                        
 4643/    1AB8 :                        ;************************************************************************************
 4644/    1AB8 :                        ;
 4645/    1AB8 :                        ; perform UCASE$()
 4646/    1AB8 :                        
 4647/    1AB8 :                        LAB_UCASE
 4648/    1AB8 : 6100 FF04              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4649/    1ABC :                        								; returns with d0 = length, a0 = pointer
 4650/    1ABC : 2200                   	MOVE.l	d0,d1					; copy the string length
 4651/    1ABE : 6726                   	BEQ.s		NoString				; if null go return a null string
 4652/    1AC0 :                        
 4653/    1AC0 :                        ; else copy and change the string
 4654/    1AC0 :                        
 4655/    1AC0 : 2248                   	MOVEA.l	a0,a1					; copy the string address
 4656/    1AC2 : 6100 FD66              	BSR		LAB_2115				; make a string space d1 bytes long
 4657/    1AC6 : D1C1                   	ADDA.l	d1,a0					; new string end
 4658/    1AC8 : D3C1                   	ADDA.l	d1,a1					; old string end
 4659/    1ACA : 3401                   	MOVE.w	d1,d2					; copy length for loop
 4660/    1ACC : 5342                   	SUBQ.w	#1,d2					; -1 for DBF loop
 4661/    1ACE :                        UC_loop
 4662/    1ACE : 1021                   	MOVE.b	-(a1),d0				; get a byte from the string
 4663/    1AD0 :                        
 4664/    1AD0 : B03C 0061              	CMP.b		#$61,d0				; compare with "a"
 4665/    1AD4 : 650A                   	BCS.s		NoLcase				; if < "a" skip change
 4666/    1AD6 :                        
 4667/    1AD6 : B03C 007B              	CMP.b		#$7B,d0				; compare with "z"+1
 4668/    1ADA : 6404                   	BCC.s		NoLcase				; if > "z" skip change
 4669/    1ADC :                        
 4670/    1ADC : 0200 00DF              	ANDI.b	#$DF,d0				; convert lower case to upper case
 4671/    1AE0 :                        NoLcase
 4672/    1AE0 : 1100                   	MOVE.b	d0,-(a0)				; copy upper case byte back to string
 4673/    1AE2 : 51CA FFEA              	DBF		d2,UC_loop				; decrement and loop if not all done
 4674/    1AE6 :                        
 4675/    1AE6 :                        NoString
 4676/    1AE6 : 6000 FD28              	BRA		LAB_RTST				; push string on descriptor stack
 4677/    1AEA :                        								; a0 = pointer, d1 = length
 4678/    1AEA :                        
 4679/    1AEA :                        
 4680/    1AEA :                        ;************************************************************************************
 4681/    1AEA :                        ;
 4682/    1AEA :                        ; perform SADD()
 4683/    1AEA :                        
 4684/    1AEA :                        LAB_SADD
 4685/    1AEA : 101D                   	MOVE.b	(a5)+,d0				; increment pointer
 4686/    1AEC : 6100 F8D6              	BSR		LAB_GVAR				; get variable address in a0
 4687/    1AF0 : 6100 F6AE              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4688/    1AF4 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 4689/    1AF8 : 6A00 EA46              	BPL		LAB_TMER				; if numeric do Type missmatch Error
 4690/    1AFC : 2010                   	MOVE.l	(a0),d0					; get string address
 4691/    1AFE : 6000 FBB4              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 4692/    1B02 :                        
 4693/    1B02 :                        
 4694/    1B02 :                        ;************************************************************************************
 4695/    1B02 :                        ;
 4696/    1B02 :                        ; perform LEN()
 4697/    1B02 :                        
 4698/    1B02 :                        LAB_LENS
 4699/    1B02 : 487A FBB0              	PEA		LAB_AYFC(pc)			; set return address to convert d0 to signed
 4700/    1B06 :                        								; longword in FAC1
 4701/    1B06 : 6000 FEB6              	BRA		LAB_22B6				; pop string off descriptor stack or from memory
 4702/    1B0A :                        								; returns with d0 = length, a0 = pointer
 4703/    1B0A :                        
 4704/    1B0A :                        
 4705/    1B0A :                        ;************************************************************************************
 4706/    1B0A :                        ;
 4707/    1B0A :                        ; perform ASC()
 4708/    1B0A :                        
 4709/    1B0A :                        LAB_ASC
 4710/    1B0A : 6100 FEB2              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4711/    1B0E :                        								; returns with d0 = length, a0 = pointer
 4712/    1B0E : 4A40                   	TST.w		d0					; test length
 4713/    1B10 : 6700 EA4E              	BEQ		LAB_FCER				; if null do function call error then warm start
 4714/    1B14 :                        
 4715/    1B14 : 1010                   	MOVE.b	(a0),d0				; get first character byte
 4716/    1B16 : 6000 FBBC              	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
 4717/    1B1A :                        
 4718/    1B1A :                        
 4719/    1B1A :                        ;************************************************************************************
 4720/    1B1A :                        ;
 4721/    1B1A :                        ; increment and get byte, result in d0 and Itemp
 4722/    1B1A :                        
 4723/    1B1A :                        LAB_SGBY
 4724/    1B1A : 6100 F696              	BSR		LAB_IGBY				; increment & scan memory
 4725/    1B1E :                        
 4726/    1B1E :                        
 4727/    1B1E :                        ;************************************************************************************
 4728/    1B1E :                        ;
 4729/    1B1E :                        ; get byte parameter, result in d0 and Itemp
 4730/    1B1E :                        
 4731/    1B1E :                        LAB_GTBY
 4732/    1B1E : 6100 F51A              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4733/    1B22 :                        								; else do type mismatch
 4734/    1B22 :                        
 4735/    1B22 :                        
 4736/    1B22 :                        ;************************************************************************************
 4737/    1B22 :                        ;
 4738/    1B22 :                        ; evaluate byte expression, result in d0 and Itemp
 4739/    1B22 :                        
 4740/    1B22 :                        LAB_EVBY
 4741/    1B22 : 6100 F9D4              	BSR		LAB_EVPI				; evaluate positive integer expression
 4742/    1B26 :                        								; result in d0 and Itemp
 4743/    1B26 : 123C 0080              	MOVE.b		#$80,d1				; set mask/2
 4744/    1B2A : D281                   	ADD.l		d1,d1					; =$FFFFFF00
 4745/    1B2C : C280                   	AND.l		d0,d1					; check top 24 bits
 4746/    1B2E : 6600 EA30              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4747/    1B32 :                        
 4748/    1B32 : 4E75                   	RTS
 4749/    1B34 :                        
 4750/    1B34 :                        
 4751/    1B34 :                        ;************************************************************************************
 4752/    1B34 :                        ;
 4753/    1B34 :                        ; get word parameter, result in d0 and Itemp
 4754/    1B34 :                        
 4755/    1B34 :                        LAB_GTWO
 4756/    1B34 : 6100 F504              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4757/    1B38 :                        								; else do type mismatch
 4758/    1B38 : 6100 F9BE              	BSR		LAB_EVPI				; evaluate positive integer expression
 4759/    1B3C :                        								; result in d0 and Itemp
 4760/    1B3C : 4840                   	SWAP		d0					; copy high word to low word
 4761/    1B3E : 4A40                   	TST.w		d0					; set flags
 4762/    1B40 : 6600 EA1E              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4763/    1B44 :                        
 4764/    1B44 : 4840                   	SWAP		d0					; copy high word to low word
 4765/    1B46 : 4E75                   	RTS
 4766/    1B48 :                        
 4767/    1B48 :                        
 4768/    1B48 :                        ;************************************************************************************
 4769/    1B48 :                        ;
 4770/    1B48 :                        ; perform VAL()
 4771/    1B48 :                        
 4772/    1B48 :                        LAB_VAL
 4773/    1B48 : 6100 FE74              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4774/    1B4C :                        								; returns with d0 = length, a0 = pointer
 4775/    1B4C : 6722                   	BEQ.s		LAB_VALZ				; string was null so set result = $00
 4776/    1B4E :                        								; clear FAC1 exponent & sign & return
 4777/    1B4E :                        
 4778/    1B4E : 2C4D                   	MOVEA.l	a5,a6					; save BASIC execute pointer
 4779/    1B50 : 2A48                   	MOVEA.l	a0,a5					; copy string pointer to execute pointer
 4780/    1B52 : D1C0                   	ADDA.l	d0,a0					; string end+1
 4781/    1B54 : 1010                   	MOVE.b	(a0),d0				; get byte from string+1
 4782/    1B56 : 3F00                   	MOVE.w	d0,-(sp)				; save it
 4783/    1B58 : 2F08                   	MOVE.l	a0,-(sp)				; save address
 4784/    1B5A : 10BC 0000              	MOVE.b	#0,(a0)				; null terminate string
 4785/    1B5E : 6100 F654              	BSR		LAB_GBYT				; scan memory
 4786/    1B62 : 6100 114C              	BSR		LAB_2887				; get FAC1 from string
 4787/    1B66 : 205F                   	MOVEA.l	(sp)+,a0				; restore pointer
 4788/    1B68 : 301F                   	MOVE.w	(sp)+,d0				; pop byte
 4789/    1B6A : 1080                   	MOVE.b	d0,(a0)				; restore to memory
 4790/    1B6C : 2A4E                   	MOVEA.l	a6,a5					; restore BASIC execute pointer
 4791/    1B6E : 4E75                   	RTS
 4792/    1B70 :                        
 4793/    1B70 :                        LAB_VALZ
 4794/    1B70 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; clear FAC1 exponent & sign
 4795/    1B74 : 4E75                   	RTS
 4796/    1B76 :                        
 4797/    1B76 :                        
 4798/    1B76 :                        ;************************************************************************************
 4799/    1B76 :                        ;
 4800/    1B76 :                        ; get two parameters for POKE or WAIT, first parameter in a0, second in d0
 4801/    1B76 :                        
 4802/    1B76 :                        LAB_GADB
 4803/    1B76 : 6100 F4C2              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4804/    1B7A :                        								; else do type mismatch
 4805/    1B7A : 6100 F984              	BSR		LAB_EVIR				; evaluate integer expression
 4806/    1B7E :                        								; (does FC error not OF error if out of range)
 4807/    1B7E : 2F00                   	MOVE.l	d0,-(sp)				; copy to stack
 4808/    1B80 : 6100 F626              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4809/    1B84 : 6198                   	BSR.s		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 4810/    1B86 : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4811/    1B88 : 4E75                   	RTS
 4812/    1B8A :                        
 4813/    1B8A :                        
 4814/    1B8A :                        ;************************************************************************************
 4815/    1B8A :                        ;
 4816/    1B8A :                        ; get two parameters for DOKE or WAITW, first parameter in a0, second in d0
 4817/    1B8A :                        
 4818/    1B8A :                        LAB_GADW
 4819/    1B8A : 611E                   	BSR.s		LAB_GEAD				; get even address for word/long memory actions
 4820/    1B8C :                        								; address returned in d0 and on the stack
 4821/    1B8C : 6100 F61A              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4822/    1B90 : 6100 F4A8              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4823/    1B94 :                        								; else do type mismatch
 4824/    1B94 : 6100 F96A              	BSR		LAB_EVIR				; evaluate integer expression
 4825/    1B98 :                        								; result in d0 and Itemp
 4826/    1B98 : 4840                   	SWAP		d0					; swap words
 4827/    1B9A : 4A40                   	TST.w		d0					; test high word
 4828/    1B9C : 6706                   	BEQ.s		LAB_XGADW				; exit if null
 4829/    1B9E :                        
 4830/    1B9E : 5240                   	ADDQ.w	#1,d0					; increment word
 4831/    1BA0 : 6600 E9BE              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4832/    1BA4 :                        
 4833/    1BA4 :                        LAB_XGADW
 4834/    1BA4 : 4840                   	SWAP		d0					; swap words back
 4835/    1BA6 : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4836/    1BA8 : 4E75                   	RTS
 4837/    1BAA :                        
 4838/    1BAA :                        
 4839/    1BAA :                        ;************************************************************************************
 4840/    1BAA :                        ;
 4841/    1BAA :                        ; get even address (for word or longword memory actions)
 4842/    1BAA :                        ; address returned in d0 and on the stack
 4843/    1BAA :                        ; does address error if the address is odd
 4844/    1BAA :                        
 4845/    1BAA :                        LAB_GEAD
 4846/    1BAA : 6100 F48E              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4847/    1BAE :                        								; else do type mismatch
 4848/    1BAE : 6100 F950              	BSR		LAB_EVIR				; evaluate integer expression
 4849/    1BB2 :                        								; (does FC error not OF error if out of range)
 4850/    1BB2 : 0800 0000              	BTST		#0,d0					; test low bit of longword
 4851/    1BB6 : 6600 E964              	BNE		LAB_ADER				; if address is odd do address error/warm start
 4852/    1BBA :                        
 4853/    1BBA : 2057                   	MOVEA.l	(sp),a0				; copy return address
 4854/    1BBC : 2E80                   	MOVE.l	d0,(sp)				; even address on stack
 4855/    1BBE : 4ED0                   	JMP		(a0)					; effectively RTS
 4856/    1BC0 :                        
 4857/    1BC0 :                        
 4858/    1BC0 :                        ;************************************************************************************
 4859/    1BC0 :                        ;
 4860/    1BC0 :                        ; perform PEEK()
 4861/    1BC0 :                        
 4862/    1BC0 :                        LAB_PEEK
 4863/    1BC0 : 6100 F93E              	BSR		LAB_EVIR				; evaluate integer expression
 4864/    1BC4 :                        								; (does FC error not OF error if out of range)
 4865/    1BC4 : 2040                   	MOVEA.l	d0,a0					; copy to address register
 4866/    1BC6 : 1010                   	MOVE.b	(a0),d0				; get byte
 4867/    1BC8 : 6000 FB0A              	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
 4868/    1BCC :                        
 4869/    1BCC :                        
 4870/    1BCC :                        ;************************************************************************************
 4871/    1BCC :                        ;
 4872/    1BCC :                        ; perform POKE
 4873/    1BCC :                        
 4874/    1BCC :                        LAB_POKE
 4875/    1BCC : 61A8                   	BSR.s		LAB_GADB				; get two parameters for POKE or WAIT
 4876/    1BCE :                        								; first parameter in a0, second in d0
 4877/    1BCE : 1080                   	MOVE.b	d0,(a0)				; put byte in memory
 4878/    1BD0 : 4E75                   	RTS
 4879/    1BD2 :                        
 4880/    1BD2 :                        
 4881/    1BD2 :                        ;************************************************************************************
 4882/    1BD2 :                        ;
 4883/    1BD2 :                        ; perform DEEK()
 4884/    1BD2 :                        
 4885/    1BD2 :                        LAB_DEEK
 4886/    1BD2 : 6100 F92C              	BSR		LAB_EVIR				; evaluate integer expression
 4887/    1BD6 :                        								; (does FC error not OF error if out of range)
 4888/    1BD6 : E208                   	LSR.b		#1,d0					; shift bit 0 to carry
 4889/    1BD8 : 6500 E942              	BCS		LAB_ADER				; if address is odd do address error/warm start
 4890/    1BDC :                        
 4891/    1BDC : D000                   	ADD.b		d0,d0					; shift byte back
 4892/    1BDE : C188                   	EXG		d0,a0					; copy to address register
 4893/    1BE0 : 7000                   	MOVEQ		#0,d0					; clear top bits
 4894/    1BE2 : 3010                   	MOVE.w	(a0),d0				; get word
 4895/    1BE4 : 6000 FACE              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 4896/    1BE8 :                        
 4897/    1BE8 :                        
 4898/    1BE8 :                        ;************************************************************************************
 4899/    1BE8 :                        ;
 4900/    1BE8 :                        ; perform LEEK()
 4901/    1BE8 :                        
 4902/    1BE8 :                        LAB_LEEK
 4903/    1BE8 : 6100 F916              	BSR		LAB_EVIR				; evaluate integer expression
 4904/    1BEC :                        								; (does FC error not OF error if out of range)
 4905/    1BEC : E208                   	LSR.b		#1,d0					; shift bit 0 to carry
 4906/    1BEE : 6500 E92C              	BCS		LAB_ADER				; if address is odd do address error/warm start
 4907/    1BF2 :                        
 4908/    1BF2 : D000                   	ADD.b		d0,d0					; shift byte back
 4909/    1BF4 : C188                   	EXG		d0,a0					; copy to address register
 4910/    1BF6 : 2010                   	MOVE.l	(a0),d0				; get longword
 4911/    1BF8 : 6000 FABA              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 4912/    1BFC :                        
 4913/    1BFC :                        
 4914/    1BFC :                        ;************************************************************************************
 4915/    1BFC :                        ;
 4916/    1BFC :                        ; perform DOKE
 4917/    1BFC :                        
 4918/    1BFC :                        LAB_DOKE
 4919/    1BFC : 618C                   	BSR.s		LAB_GADW				; get two parameters for DOKE or WAIT
 4920/    1BFE :                        								; first parameter in a0, second in d0
 4921/    1BFE : 3080                   	MOVE.w	d0,(a0)				; put word in memory
 4922/    1C00 : 4E75                   	RTS
 4923/    1C02 :                        
 4924/    1C02 :                        
 4925/    1C02 :                        ;************************************************************************************
 4926/    1C02 :                        ;
 4927/    1C02 :                        ; perform LOKE
 4928/    1C02 :                        
 4929/    1C02 :                        LAB_LOKE
 4930/    1C02 : 61A6                   	BSR.s		LAB_GEAD				; get even address for word/long memory actions
 4931/    1C04 :                        								; address returned in d0 and on the stack
 4932/    1C04 : 6100 F5A2              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4933/    1C08 : 6100 F430              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4934/    1C0C :                        								; else do type mismatch
 4935/    1C0C : 6100 F8F2              	BSR		LAB_EVIR				; evaluate integer value (no sign check)
 4936/    1C10 : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4937/    1C12 : 2080                   	MOVE.l	d0,(a0)				; put longword in memory
 4938/    1C14 :                        RTS_015
 4939/    1C14 : 4E75                   	RTS
 4940/    1C16 :                        
 4941/    1C16 :                        
 4942/    1C16 :                        ;************************************************************************************
 4943/    1C16 :                        ;
 4944/    1C16 :                        ; perform SWAP
 4945/    1C16 :                        
 4946/    1C16 :                        LAB_SWAP
 4947/    1C16 : 6100 F7AC              	BSR		LAB_GVAR				; get variable 1 address in a0
 4948/    1C1A : 2F08                   	MOVE.l	a0,-(sp)				; save variable 1 address
 4949/    1C1C : 182B 05B5              	MOVE.b	Dtypef(a3),d4			; copy variable 1 data type, $80=string,
 4950/    1C20 :                        								; $40=inetger, $00=float
 4951/    1C20 :                        
 4952/    1C20 : 6100 F586              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4953/    1C24 : 6100 F79E              	BSR		LAB_GVAR				; get variable 2 address in a0
 4954/    1C28 : 245F                   	MOVEA.l	(sp)+,a2				; restore variable 1 address
 4955/    1C2A : B82B 05B5              	CMP.b		Dtypef(a3),d4			; compare variable 1 data type with variable 2
 4956/    1C2E :                        								; data type
 4957/    1C2E : 6600 E910              	BNE		LAB_TMER				; if not both the same type do "Type mismatch"
 4958/    1C32 :                        								; error then warm start
 4959/    1C32 :                        
 4960/    1C32 : 2010                   	MOVE.l	(a0),d0				; get variable 2
 4961/    1C34 : 20D2                   	MOVE.l	(a2),(a0)+				; copy variable 1 to variable 2
 4962/    1C36 : 24C0                   	MOVE.l	d0,(a2)+				; save variable 2 to variable 1
 4963/    1C38 :                        
 4964/    1C38 : 4A04                   	TST.b		d4					; check data type
 4965/    1C3A : 6AD8                   	BPL.s		RTS_015				; exit if not string
 4966/    1C3C :                        
 4967/    1C3C : 3010                   	MOVE.w	(a0),d0				; get string 2 length
 4968/    1C3E : 3092                   	MOVE.w	(a2),(a0)				; copy string 1 length to string 2 length
 4969/    1C40 : 3480                   	MOVE.w	d0,(a2)				; save string 2 length to string 1 length
 4970/    1C42 : 4E75                   	RTS
 4971/    1C44 :                        
 4972/    1C44 :                        
 4973/    1C44 :                        ;************************************************************************************
 4974/    1C44 :                        ;
 4975/    1C44 :                        ; perform USR
 4976/    1C44 :                        
 4977/    1C44 :                        LAB_USR
 4978/    1C44 : 4EAB 0406              	JSR		Usrjmp(a3)				; do user vector
 4979/    1C48 : 6000 F556              	BRA		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4980/    1C4C :                        
 4981/    1C4C :                        
 4982/    1C4C :                        ;************************************************************************************
 4983/    1C4C :                        ;
 4984/    1C4C :                        ; perform LOAD
 4985/    1C4C :                        
 4986/    1C4C :                        LAB_LOAD
 4987/    1C4C : 4EEB 0418              	JMP		V_LOAD(a3)				; do load vector
 4988/    1C50 :                        
 4989/    1C50 :                        
 4990/    1C50 :                        ;************************************************************************************
 4991/    1C50 :                        ;
 4992/    1C50 :                        ; perform SAVE
 4993/    1C50 :                        
 4994/    1C50 :                        LAB_SAVE
 4995/    1C50 : 4EEB 041E              	JMP		V_SAVE(a3)				; do save vector
 4996/    1C54 :                        
 4997/    1C54 :                        
 4998/    1C54 :                        ;************************************************************************************
 4999/    1C54 :                        ;
 5000/    1C54 :                        ; perform CALL
 5001/    1C54 :                        
 5002/    1C54 :                        LAB_CALL
 5003/    1C54 : 487A F55E              	PEA		LAB_GBYT(pc)			; put return address on stack
 5004/    1C58 : 6100 FF50              	BSR		LAB_GEAD				; get even address for word/long memory actions
 5005/    1C5C :                        								; address returned in d0 and on the stack
 5006/    1C5C : 4E75                   	RTS							; effectively calls the routine
 5007/    1C5E :                        
 5008/    1C5E :                        ; if the called routine exits correctly then it will return via the get byte routine.
 5009/    1C5E :                        ; this will then get the next byte for the interpreter and return
 5010/    1C5E :                        
 5011/    1C5E :                        
 5012/    1C5E :                        ;************************************************************************************
 5013/    1C5E :                        ;
 5014/    1C5E :                        ; perform WAIT
 5015/    1C5E :                        
 5016/    1C5E :                        LAB_WAIT
 5017/    1C5E : 6100 FF16              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 5018/    1C62 :                        								; first parameter in a0, second in d0
 5019/    1C62 : 2F08                   	MOVE.l	a0,-(sp)				; save address
 5020/    1C64 : 3F00                   	MOVE.w	d0,-(sp)				; save byte
 5021/    1C66 : 7400                   	MOVEQ		#0,d2					; clear mask
 5022/    1C68 : 6100 F54A              	BSR		LAB_GBYT				; scan memory
 5023/    1C6C : 6706                   	BEQ.s		LAB_2441				; skip if no third argument
 5024/    1C6E :                        
 5025/    1C6E : 6100 F534              	BSR		LAB_SCGB				; scan for "," & get byte,
 5026/    1C72 :                        								; else do syntax error/warm start
 5027/    1C72 : 2400                   	MOVE.l	d0,d2					; copy mask
 5028/    1C74 :                        LAB_2441
 5029/    1C74 : 321F                   	MOVE.w	(sp)+,d1				; get byte
 5030/    1C76 : 205F                   	MOVEA.l	(sp)+,a0				; get address
 5031/    1C78 :                        LAB_2445
 5032/    1C78 : 1010                   	MOVE.b	(a0),d0				; read memory byte
 5033/    1C7A : B500                   	EOR.b		d2,d0					; EOR with second argument (mask)
 5034/    1C7C : C001                   	AND.b		d1,d0					; AND with first argument (byte)
 5035/    1C7E : 67F8                   	BEQ.s		LAB_2445				; loop if result is zero
 5036/    1C80 :                        
 5037/    1C80 : 4E75                   	RTS
 5038/    1C82 :                        
 5039/    1C82 :                        
 5040/    1C82 :                        ;************************************************************************************
 5041/    1C82 :                        ;
 5042/    1C82 :                        ; perform subtraction, FAC1 from FAC2
 5043/    1C82 :                        
 5044/    1C82 :                        LAB_SUBTRACT
 5045/    1C82 : 0A2B 0080 0595         	EORI.b	#$80,FAC1_s(a3)			; complement FAC1 sign
 5046/    1C88 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign byte
 5047/    1C8E :                        
 5048/    1C8E : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign byte
 5049/    1C92 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR with FAC2 sign
 5050/    1C96 :                        
 5051/    1C96 :                        
 5052/    1C96 :                        ;************************************************************************************
 5053/    1C96 :                        ;
 5054/    1C96 :                        ; add FAC2 to FAC1
 5055/    1C96 :                        
 5056/    1C96 :                        LAB_ADD
 5057/    1C96 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent
 5058/    1C9A : 6700 0338              	BEQ		LAB_279B				; FAC1 was zero so copy FAC2 to FAC1 & return
 5059/    1C9E :                        
 5060/    1C9E :                        								; FAC1 is non zero
 5061/    1C9E : 41EB 0598              	LEA		FAC2_m(a3),a0			; set pointer1 to FAC2 mantissa
 5062/    1CA2 : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 5063/    1CA6 : 6746                   	BEQ.s		RTS_016				; exit if zero
 5064/    1CA8 :                        
 5065/    1CA8 : 902B 0594              	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
 5066/    1CAC : 6722                   	BEQ.s		LAB_24A8				; branch if = (go add mantissa)
 5067/    1CAE :                        
 5068/    1CAE : 650A                   	BCS.s		LAB_249C				; branch if FAC2 < FAC1
 5069/    1CB0 :                        
 5070/    1CB0 :                        								; FAC2 > FAC1
 5071/    1CB0 : 376B 059C 0594         	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy sign and exponent of FAC2
 5072/    1CB6 : 4400                   	NEG.b		d0					; negate exponent difference (make diff -ve)
 5073/    1CB8 : 5148                   	SUBQ.w	#8,a0					; pointer1 to FAC1
 5074/    1CBA :                        
 5075/    1CBA :                        LAB_249C
 5076/    1CBA : 4400                   	NEG.b		d0					; negate exponent difference (make diff +ve)
 5077/    1CBC : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 5078/    1CBE : B03C 0020              	CMP.b		#32,d0				; compare exponent diff with 32
 5079/    1CC2 : 6D04                   	BLT.s		LAB_2467				; branch if range >= 32
 5080/    1CC4 :                        
 5081/    1CC4 : 7200                   	MOVEQ		#0,d1					; clear d1
 5082/    1CC6 : 6004                   	BRA.s		LAB_2468				; go clear smaller mantissa
 5083/    1CC8 :                        
 5084/    1CC8 :                        LAB_2467
 5085/    1CC8 : 2210                   	MOVE.l	(a0),d1				; get FACx mantissa
 5086/    1CCA : E0A9                   	LSR.l		d0,d1					; shift d0 times right
 5087/    1CCC :                        LAB_2468
 5088/    1CCC : 2081                   	MOVE.l	d1,(a0)				; save it back
 5089/    1CCE : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 5090/    1CD0 :                        
 5091/    1CD0 :                        								; exponents are equal now do mantissa add or
 5092/    1CD0 :                        								; subtract
 5093/    1CD0 :                        LAB_24A8
 5094/    1CD0 : 4A2B 059E              	TST.b		FAC_sc(a3)				; test sign compare (FAC1 EOR FAC2)
 5095/    1CD4 : 6B1A                   	BMI.s		LAB_24F8				; if <> go do subtract
 5096/    1CD6 :                        
 5097/    1CD6 : 202B 0598              	MOVE.l	FAC2_m(a3),d0			; get FAC2 mantissa
 5098/    1CDA : D0AB 0590              	ADD.l		FAC1_m(a3),d0			; add FAC1 mantissa
 5099/    1CDE : 640A                   	BCC.s		LAB_24F7				; save and exit if no carry (FAC1 is normal)
 5100/    1CE0 :                        
 5101/    1CE0 : E290                   	ROXR.l	#1,d0					; else shift carry back into mantissa
 5102/    1CE2 : 522B 0594              	ADDQ.b	#1,FAC1_e(a3)			; increment FAC1 exponent
 5103/    1CE6 : 6500 E874              	BCS		LAB_OFER				; if carry do overflow error & warm start
 5104/    1CEA :                        
 5105/    1CEA :                        LAB_24F7
 5106/    1CEA : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save mantissa
 5107/    1CEE :                        RTS_016
 5108/    1CEE : 4E75                   	RTS
 5109/    1CF0 :                        								; signs are different
 5110/    1CF0 :                        LAB_24F8
 5111/    1CF0 : 43EB 0590              	LEA		FAC1_m(a3),a1			; pointer 2 to FAC1
 5112/    1CF4 : B3C8                   	CMPA.l	a0,a1					; compare pointers
 5113/    1CF6 : 6602                   	BNE.s		LAB_24B4				; branch if <>
 5114/    1CF8 :                        
 5115/    1CF8 : 5049                   	ADDQ.w	#8,a1					; else pointer2 to FAC2
 5116/    1CFA :                        
 5117/    1CFA :                        								; take smaller from bigger (take sign of bigger)
 5118/    1CFA :                        LAB_24B4
 5119/    1CFA : 2011                   	MOVE.l	(a1),d0				; get larger mantissa
 5120/    1CFC : 2210                   	MOVE.l	(a0),d1				; get smaller mantissa
 5121/    1CFE : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save larger mantissa
 5122/    1D02 : 93AB 0590              	SUB.l		d1,FAC1_m(a3)			; subtract smaller
 5123/    1D06 :                        
 5124/    1D06 :                        
 5125/    1D06 :                        ;************************************************************************************
 5126/    1D06 :                        ;
 5127/    1D06 :                        ; do +/- (carry is sign) & normalise FAC1
 5128/    1D06 :                        
 5129/    1D06 :                        LAB_24D0
 5130/    1D06 : 640A                   	BCC.s		LAB_24D5				; branch if result is +ve
 5131/    1D08 :                        
 5132/    1D08 :                        								; erk! subtract is the wrong way round so
 5133/    1D08 :                        								; negate everything
 5134/    1D08 : 0A2B 00FF 0595         	EORI.b	#$FF,FAC1_s(a3)			; complement FAC1 sign
 5135/    1D0E : 44AB 0590              	NEG.l		FAC1_m(a3)				; negate FAC1 mantissa
 5136/    1D12 :                        
 5137/    1D12 :                        
 5138/    1D12 :                        ;************************************************************************************
 5139/    1D12 :                        ;
 5140/    1D12 :                        ; normalise FAC1
 5141/    1D12 :                        
 5142/    1D12 :                        LAB_24D5
 5143/    1D12 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 5144/    1D16 : 6B2E                   	BMI.s		LAB_24DA				; mantissa is normal so just exit
 5145/    1D18 :                        
 5146/    1D18 : 6606                   	BNE.s		LAB_24D9				; mantissa is not zero so go normalise FAC1
 5147/    1D1A :                        
 5148/    1D1A : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; else make FAC1 = +zero
 5149/    1D1E : 4E75                   	RTS
 5150/    1D20 :                        
 5151/    1D20 :                        LAB_24D9
 5152/    1D20 : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 5153/    1D22 : 2200                   	MOVE.l	d0,d1					; mantissa to d1
 5154/    1D24 : 7000                   	MOVEQ		#0,d0					; clear d0
 5155/    1D26 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent byte
 5156/    1D2A : 6714                   	BEQ.s		LAB_24D8				; if exponent is zero then clean up and exit
 5157/    1D2C :                        LAB_24D6
 5158/    1D2C : D281                   	ADD.l		d1,d1					; shift mantissa, ADD is quicker for a single
 5159/    1D2E :                        								; shift
 5160/    1D2E : 5BC8 FFFC              	DBMI		d0,LAB_24D6				; decrement exponent and loop if mantissa and
 5161/    1D32 :                        								; exponent +ve
 5162/    1D32 :                        
 5163/    1D32 : 4A40                   	TST.w		d0					; test exponent
 5164/    1D34 : 670A                   	BEQ.s		LAB_24D8				; if exponent is zero make FAC1 zero
 5165/    1D36 :                        
 5166/    1D36 : 6A02                   	BPL.s		LAB_24D7				; if exponent is >zero go save FAC1
 5167/    1D38 :                        
 5168/    1D38 : 7001                   	MOVEQ		#1,d0					; else set for zero after correction
 5169/    1D3A :                        LAB_24D7
 5170/    1D3A : 5300                   	SUBQ.b	#1,d0					; adjust exponent for loop
 5171/    1D3C : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save normalised mantissa
 5172/    1D40 :                        LAB_24D8
 5173/    1D40 : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 5174/    1D42 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save corrected exponent
 5175/    1D46 :                        LAB_24DA
 5176/    1D46 : 4E75                   	RTS
 5177/    1D48 :                        
 5178/    1D48 :                        
 5179/    1D48 :                        ;************************************************************************************
 5180/    1D48 :                        ;
 5181/    1D48 :                        ; perform LOG()
 5182/    1D48 :                        
 5183/    1D48 :                        LAB_LOG
 5184/    1D48 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 5185/    1D4C : 6B00 E812              	BMI		LAB_FCER				; if -ve do function call error/warm start
 5186/    1D50 :                        
 5187/    1D50 : 7E00                   	MOVEQ		#0,d7					; clear d7
 5188/    1D52 : 1747 059E              	MOVE.b	d7,FAC_sc(a3)			; clear sign compare
 5189/    1D56 : 1E2B 0594              	MOVE.b	FAC1_e(a3),d7			; get exponent
 5190/    1D5A : 6700 E804              	BEQ		LAB_FCER				; if 0 do function call error/warm start
 5191/    1D5E :                        
 5192/    1D5E : 9EBC 0000 0081         	SUB.l		#$81,d7				; normalise exponent
 5193/    1D64 : 177C 0081 0594         	MOVE.b	#$81,FAC1_e(a3)			; force a value between 1 and 2
 5194/    1D6A : 2C2B 0590              	MOVE.l	FAC1_m(a3),d6			; copy mantissa
 5195/    1D6E :                        
 5196/    1D6E : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
 5197/    1D76 : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
 5198/    1D7C : 6100 FF18              	BSR		LAB_ADD				; find arg+1
 5199/    1D80 : 7000                   	MOVEQ		#0,d0					; setup for calc skip
 5200/    1D82 : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; set FAC1 for zero result
 5201/    1D86 : DC86                   	ADD.l		d6,d6					; shift 1 bit out
 5202/    1D88 : 2746 0598              	MOVE.l	d6,FAC2_m(a3)			; put back FAC2
 5203/    1D8C : 6758                   	BEQ.s		LAB_LONN				; if 0 skip calculation
 5204/    1D8E :                        
 5205/    1D8E : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for .5
 5206/    1D94 : 6100 0130              	BSR		LAB_DIVIDE				; do (arg-1)/(arg+1)
 5207/    1D98 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test exponent
 5208/    1D9C : 6748                   	BEQ.s		LAB_LONN				; if 0 skip calculation
 5209/    1D9E :                        
 5210/    1D9E : 122B 0594              	MOVE.b	FAC1_e(a3),d1			; get exponent
 5211/    1DA2 : 923C 0082              	SUB.b		#$82,d1				; normalise and two integer bits
 5212/    1DA6 : 4401                   	NEG.b		d1					; negate for shift
 5213/    1DA8 :                        ;	CMP.b		#$1F,d1				; will mantissa vanish?
 5214/    1DA8 :                        ;	BGT.s		LAB_dunno				; if so do ???
 5215/    1DA8 :                        
 5216/    1DA8 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 5217/    1DAC : E2A8                   	LSR.l		d1,d0					; shift in two integer bits
 5218/    1DAE :                        
 5219/    1DAE :                        ; d0 = arg
 5220/    1DAE :                        ; d0 = x, d1 = y
 5221/    1DAE :                        ; d2 = x1, d3 = y1
 5222/    1DAE :                        ; d4 = shift count
 5223/    1DAE :                        ; d5 = loop count
 5224/    1DAE :                        ; d6 = z
 5225/    1DAE :                        ; a0 = table pointer
 5226/    1DAE :                        
 5227/    1DAE : 7C00                   	MOVEQ		#0,d6					; z = 0
 5228/    1DB0 : 223C 4000 0000         	MOVE.l	#1<<30,d1				; y = 1
 5229/    1DB6 : 41FA 1408              	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic tangent table
 5230/    1DBA : 7A1E                   	MOVEQ		#30,d5				; loop 31 times
 5231/    1DBC : 7801                   	MOVEQ		#1,d4					; set shift count
 5232/    1DBE : 6006                   	BRA.s		LAB_LOCC				; entry point for loop
 5233/    1DC0 :                        
 5234/    1DC0 :                        LAB_LAAD
 5235/    1DC0 : E8A2                   	ASR.l		d4,d2					; x1 >> i
 5236/    1DC2 : 9282                   	SUB.l		d2,d1					; y = y - x1
 5237/    1DC4 : DC90                   	ADD.l		(a0),d6				; z = z + tanh(i)
 5238/    1DC6 :                        LAB_LOCC
 5239/    1DC6 : 2400                   	MOVE.l	d0,d2					; x1 = x
 5240/    1DC8 : 2601                   	MOVE.l	d1,d3					; y1 = Y
 5241/    1DCA : E8A3                   	ASR.l		d4,d3					; y1 >> i
 5242/    1DCC : 6402                   	BCC.s		LAB_LOLP
 5243/    1DCE :                        
 5244/    1DCE : 5283                   	ADDQ.l	#1,d3
 5245/    1DD0 :                        LAB_LOLP
 5246/    1DD0 : 9083                   	SUB.l		d3,d0					; x = x - y1
 5247/    1DD2 : 6AEC                   	BPL.s		LAB_LAAD				; branch if > 0
 5248/    1DD4 :                        
 5249/    1DD4 : 2002                   	MOVE.l	d2,d0					; get x back
 5250/    1DD6 : 5848                   	ADDQ.w	#4,a0					; next entry
 5251/    1DD8 : 5284                   	ADDQ.l	#1,d4					; next i
 5252/    1DDA : E28B                   	LSR.l		#1,d3					; /2
 5253/    1DDC : 6704                   	BEQ.s		LAB_LOCX				; branch y1 = 0
 5254/    1DDE :                        
 5255/    1DDE : 51CD FFF0              	DBF		d5,LAB_LOLP				; decrement and loop if not done
 5256/    1DE2 :                        
 5257/    1DE2 :                        								; now sort out the result
 5258/    1DE2 :                        LAB_LOCX
 5259/    1DE2 : DC86                   	ADD.l		d6,d6					; *2
 5260/    1DE4 : 2006                   	MOVE.l	d6,d0					; setup for d7 = 0
 5261/    1DE6 :                        LAB_LONN
 5262/    1DE6 : 2800                   	MOVE.l	d0,d4					; save cordic result
 5263/    1DE8 : 7A00                   	MOVEQ		#0,d5					; set default exponent sign
 5264/    1DEA : 4A87                   	TST.l		d7					; check original exponent sign
 5265/    1DEC : 6716                   	BEQ.s		LAB_LOXO				; branch if original was 0
 5266/    1DEE :                        
 5267/    1DEE : 6A04                   	BPL.s		LAB_LOXP				; branch if was +ve
 5268/    1DF0 :                        
 5269/    1DF0 : 4487                   	NEG.l		d7					; make original exponent +ve
 5270/    1DF2 : 7A80                   	MOVEQ		#$80-$100,d5			; make sign -ve
 5271/    1DF4 :                        LAB_LOXP
 5272/    1DF4 : 1745 0595              	MOVE.b	d5,FAC1_s(a3)			; save original exponent sign
 5273/    1DF8 : 4847                   	SWAP		d7					; 16 bit shift
 5274/    1DFA : E18F                   	LSL.l		#8,d7					; easy first part
 5275/    1DFC : 7A88                   	MOVEQ		#$88-$100,d5			; start with byte
 5276/    1DFE :                        LAB_LONE
 5277/    1DFE : 5385                   	SUBQ.l	#1,d5					; decrement exponent
 5278/    1E00 : DE87                   	ADD.l		d7,d7					; shift mantissa
 5279/    1E02 : 6AFA                   	BPL.s		LAB_LONE				; loop if not normal
 5280/    1E04 :                        
 5281/    1E04 :                        LAB_LOXO
 5282/    1E04 : 2747 0590              	MOVE.l	d7,FAC1_m(a3)			; save original exponent as mantissa
 5283/    1E08 : 1745 0594              	MOVE.b	d5,FAC1_e(a3)			; save exponent for this
 5284/    1E0C : 277C B172 17F8 0598    	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
 5285/    1E14 : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
 5286/    1E1A : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
 5287/    1E20 : 6118                   	BSR.s		LAB_MULTIPLY			; do multiply
 5288/    1E22 : 2744 0598              	MOVE.l	d4,FAC2_m(a3)			; save cordic result
 5289/    1E26 : 6710                   	BEQ.s		LAB_LOWZ				; branch if zero
 5290/    1E28 :                        
 5291/    1E28 : 377C 8200 059C         	MOVE.w	#$8200,FAC2_e(a3)			; set exponent & sign
 5292/    1E2E : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; clear sign compare
 5293/    1E34 : 6100 FE60              	BSR		LAB_ADD				; and add for final result
 5294/    1E38 :                        
 5295/    1E38 :                        LAB_LOWZ
 5296/    1E38 : 4E75                   	RTS
 5297/    1E3A :                        
 5298/    1E3A :                        
 5299/    1E3A :                        ;************************************************************************************
 5300/    1E3A :                        ;
 5301/    1E3A :                        ; multiply FAC1 by FAC2
 5302/    1E3A :                        
 5303/    1E3A :                        LAB_MULTIPLY
 5304/    1E3A : 48E7 F800              	MOVEM.l	d0-d4,-(sp)				; save registers
 5305/    1E3E : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 5306/    1E42 : 6776                   	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
 5307/    1E44 :                        
 5308/    1E44 : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 5309/    1E48 : 6770                   	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
 5310/    1E4A :                        
 5311/    1E4A : 176B 059E 0595         	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare becomes sign
 5312/    1E50 :                        
 5313/    1E50 : D02B 0594              	ADD.b		FAC1_e(a3),d0			; multiply exponents by adding
 5314/    1E54 : 640A                   	BCC.s		LAB_MNOC				; branch if no carry
 5315/    1E56 :                        
 5316/    1E56 : 903C 0080              	SUB.b		#$80,d0				; normalise result
 5317/    1E5A : 6400 E700              	BCC		LAB_OFER				; if no carry do overflow
 5318/    1E5E :                        
 5319/    1E5E : 6006                   	BRA.s		LAB_MADD				; branch
 5320/    1E60 :                        
 5321/    1E60 :                        								; no carry for exponent add
 5322/    1E60 :                        LAB_MNOC
 5323/    1E60 : 903C 0080              	SUB.b		#$80,d0				; normalise result
 5324/    1E64 : 6554                   	BCS.s		LAB_MUUF				; return zero if underflow
 5325/    1E66 :                        
 5326/    1E66 :                        LAB_MADD
 5327/    1E66 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save exponent
 5328/    1E6A :                        
 5329/    1E6A :                        								; d1 (FAC1) x d2 (FAC2)
 5330/    1E6A : 222B 0590              	MOVE.l	FAC1_m(a3),d1			; get FAC1 mantissa
 5331/    1E6E : 242B 0598              	MOVE.l	FAC2_m(a3),d2			; get FAC2 mantissa
 5332/    1E72 :                        
 5333/    1E72 : 3801                   	MOVE.w	d1,d4					; copy low word FAC1
 5334/    1E74 : 2001                   	MOVE.l	d1,d0					; copy long word FAC1
 5335/    1E76 : 4840                   	SWAP		d0					; high word FAC1 to low word FAC1
 5336/    1E78 : 3600                   	MOVE.w	d0,d3					; copy high word FAC1
 5337/    1E7A :                        
 5338/    1E7A : C2C2                   	MULU		d2,d1					; low word FAC2 x low word FAC1
 5339/    1E7C : C0C2                   	MULU		d2,d0					; low word FAC2 x high word FAC1
 5340/    1E7E : 4842                   	SWAP		d2					; high word FAC2 to low word FAC2
 5341/    1E80 : C8C2                   	MULU		d2,d4					; high word FAC2 x low word FAC1
 5342/    1E82 : C6C2                   	MULU		d2,d3					; high word FAC2 x high word FAC1
 5343/    1E84 :                        
 5344/    1E84 :                        ; done multiply, now add partial products
 5345/    1E84 :                        
 5346/    1E84 :                        ;			d1 =					aaaa  ----	FAC2_L x FAC1_L
 5347/    1E84 :                        ;			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
 5348/    1E84 :                        ;			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
 5349/    1E84 :                        ;			d3 =			cccc  bbbb			FAC2_H x FAC1_H
 5350/    1E84 :                        ;			product =		mmmm  mmmm
 5351/    1E84 :                        
 5352/    1E84 : D2BC 0000 8000         	ADD.L		#$8000,d1				; round up lowest word
 5353/    1E8A : 4241                   	CLR.w		d1					; clear low word, don't need it
 5354/    1E8C : 4841                   	SWAP		d1					; align high word
 5355/    1E8E : D280                   	ADD.l		d0,d1					; add FAC2_L x FAC1_H (can't be carry)
 5356/    1E90 :                        LAB_MUF1
 5357/    1E90 : D284                   	ADD.l		d4,d1					; now add intermediate (FAC2_H x FAC1_L)
 5358/    1E92 : 6406                   	BCC.s		LAB_MUF2				; branch if no carry
 5359/    1E94 :                        
 5360/    1E94 : D6BC 0001 0000         	ADD.l		#$10000,d3				; else correct result
 5361/    1E9A :                        LAB_MUF2
 5362/    1E9A : D2BC 0000 8000         	ADD.l		#$8000,d1				; round up low word
 5363/    1EA0 : 4241                   	CLR.w		d1					; clear low word
 5364/    1EA2 : 4841                   	SWAP		d1					; align for final add
 5365/    1EA4 : D283                   	ADD.l		d3,d1					; add FAC2_H x FAC1_H, result
 5366/    1EA6 : 6B08                   	BMI.s		LAB_MUF3				; branch if normalisation not needed
 5367/    1EA8 :                        
 5368/    1EA8 : D281                   	ADD.l		d1,d1					; shift mantissa
 5369/    1EAA : 532B 0594              	SUBQ.b	#1,FAC1_e(a3)			; adjust exponent
 5370/    1EAE : 670A                   	BEQ.s		LAB_MUUF				; branch if underflow
 5371/    1EB0 :                        
 5372/    1EB0 :                        LAB_MUF3
 5373/    1EB0 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 5374/    1EB4 :                        LAB_MUEX
 5375/    1EB4 : 4CDF 001F              	MOVEM.l	(sp)+,d0-d4				; restore registers
 5376/    1EB8 : 4E75                   	RTS
 5377/    1EBA :                        								; either zero or underflow result
 5378/    1EBA :                        LAB_MUUF
 5379/    1EBA : 7000                   	MOVEQ		#0,d0					; quick clear
 5380/    1EBC : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; clear mantissa
 5381/    1EC0 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; clear sign and exponent
 5382/    1EC4 : 60EE                   	BRA.s		LAB_MUEX				; restore regs & exit
 5383/    1EC6 :                        
 5384/    1EC6 :                        
 5385/    1EC6 :                        ;************************************************************************************
 5386/    1EC6 :                        ;
 5387/    1EC6 :                        ; do FAC2/FAC1, result in FAC1
 5388/    1EC6 :                        ; fast hardware divide version
 5389/    1EC6 :                        
 5390/    1EC6 :                        LAB_DIVIDE
 5391/    1EC6 : 2F07                   	MOVE.l	d7,-(sp)				; save d7
 5392/    1EC8 : 7000                   	MOVEQ		#0,d0					; clear FAC2 exponent
 5393/    1ECA : 2400                   	MOVE.l	d0,d2					; clear FAC1 exponent
 5394/    1ECC :                        
 5395/    1ECC : 142B 0594              	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
 5396/    1ED0 : 6700 E676              	BEQ		LAB_DZER				; if zero go do /0 error
 5397/    1ED4 :                        
 5398/    1ED4 : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 5399/    1ED8 : 6766                   	BEQ.s		LAB_DIV0				; if zero return zero
 5400/    1EDA :                        
 5401/    1EDA : 9042                   	SUB.w		d2,d0					; get result exponent by subtracting
 5402/    1EDC : D07C 0080              	ADD.w		#$80,d0				; correct 16 bit exponent result
 5403/    1EE0 :                        
 5404/    1EE0 : 176B 059E 0595         	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare is result sign
 5405/    1EE6 :                        
 5406/    1EE6 :                        ; now to do 32/32 bit mantissa divide
 5407/    1EE6 :                        
 5408/    1EE6 : 422B 059F              	CLR.b		flag(a3)				; clear 'flag' byte
 5409/    1EEA : 262B 0590              	MOVE.l	FAC1_m(a3),d3			; get FAC1 mantissa
 5410/    1EEE : 282B 0598              	MOVE.l	FAC2_m(a3),d4			; get FAC2 mantissa
 5411/    1EF2 : B883                   	CMP.l		d3,d4					; compare FAC2 with FAC1 mantissa
 5412/    1EF4 : 6744                   	BEQ.s		LAB_MAN1				; set mantissa result = 1 if equal
 5413/    1EF6 :                        
 5414/    1EF6 : 6506                   	BCS.s		AC1gtAC2				; branch if FAC1 > FAC2
 5415/    1EF8 :                        
 5416/    1EF8 : 9883                   	SUB.l		d3,d4					; subtract FAC1 from FAC2, result now must be <1
 5417/    1EFA : 562B 059F              	ADDQ.b	#3,flag(a3)				; FAC2>FAC1 so set 'flag' byte
 5418/    1EFE :                        AC1gtAC2
 5419/    1EFE : 6146                   	BSR.s		LAB_32_16				; do 32/16 divide
 5420/    1F00 : 4841                   	SWAP		d1					; move 16 bit result to high word
 5421/    1F02 : 2802                   	MOVE.l	d2,d4					; copy remainder longword
 5422/    1F04 : 6142                   	BSR.s		LAB_3216				; do 32/16 divide again (skip copy d4 to d2)
 5423/    1F06 : 84C5                   	DIVU.w	d5,d2					; now divide remainder to make guard word
 5424/    1F08 : 1E2B 059F              	MOVE.b	flag(a3),d7				; now normalise, get flag byte back
 5425/    1F0C : 6708                   	BEQ.s		LAB_DIVX				; skip add if null
 5426/    1F0E :                        
 5427/    1F0E :                        ; else result was >1 so we need to add 1 to result mantissa and adjust exponent
 5428/    1F0E :                        
 5429/    1F0E : E20F                   	LSR.b		#1,d7					; shift 1 into eXtend
 5430/    1F10 : E291                   	ROXR.l	#1,d1					; shift extend result >>
 5431/    1F12 : E252                   	ROXR.w	#1,d2					; shift extend guard word >>
 5432/    1F14 : 5200                   	ADDQ.b	#1,d0					; adjust exponent
 5433/    1F16 :                        
 5434/    1F16 :                        ; now round result to 32 bits
 5435/    1F16 :                        
 5436/    1F16 :                        LAB_DIVX
 5437/    1F16 : D442                   	ADD.w		d2,d2					; guard bit into eXtend bit
 5438/    1F18 : 6408                   	BCC.s		L_DIVRND				; branch if guard=0
 5439/    1F1A :                        
 5440/    1F1A : 5281                   	ADDQ.l	#1,d1					; add guard to mantissa
 5441/    1F1C : 6404                   	BCC.s		L_DIVRND				; branch if no overflow
 5442/    1F1E :                        
 5443/    1F1E :                        LAB_SET1
 5444/    1F1E : E291                   	ROXR.l	#1,d1					; shift extend result >>
 5445/    1F20 : 5240                   	ADDQ.w	#1,d0					; adjust exponent
 5446/    1F22 :                        
 5447/    1F22 :                        								; test for over/under flow
 5448/    1F22 :                        L_DIVRND
 5449/    1F22 : 3600                   	MOVE.w	d0,d3					; copy exponent
 5450/    1F24 : 6B1A                   	BMI.s		LAB_DIV0				; if -ve return zero
 5451/    1F26 :                        
 5452/    1F26 : 0243 FF00              	ANDI.w	#$FF00,d3				; mask word high byte
 5453/    1F2A : 6600 E630              	BNE		LAB_OFER				; branch if overflow
 5454/    1F2E :                        
 5455/    1F2E :                        								; move result into FAC1
 5456/    1F2E :                        LAB_XDIV
 5457/    1F2E : 2E1F                   	MOVE.l	(sp)+,d7				; restore d7
 5458/    1F30 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save result exponent
 5459/    1F34 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
 5460/    1F38 : 4E75                   	RTS
 5461/    1F3A :                        
 5462/    1F3A :                        ; FAC1 mantissa = FAC2 mantissa so set result mantissa
 5463/    1F3A :                        
 5464/    1F3A :                        LAB_MAN1
 5465/    1F3A : 7201                   	MOVEQ		#1,d1					; set bit
 5466/    1F3C : E2A9                   	LSR.l		d1,d1					; bit into eXtend
 5467/    1F3E : 60DE                   	BRA.s		LAB_SET1				; set mantissa, adjust exponent and exit
 5468/    1F40 :                        
 5469/    1F40 :                        ; result is zero
 5470/    1F40 :                        
 5471/    1F40 :                        LAB_DIV0
 5472/    1F40 : 7000                   	MOVEQ		#0,d0					; zero exponent & sign
 5473/    1F42 : 2200                   	MOVE.l	d0,d1					; zero mantissa
 5474/    1F44 : 60E8                   	BRA		LAB_XDIV				; exit divide
 5475/    1F46 :                        
 5476/    1F46 :                        ; divide 16 bits into 32, AB/Ex
 5477/    1F46 :                        ;
 5478/    1F46 :                        ; d4			AAAA	BBBB				; 32 bit numerator
 5479/    1F46 :                        ; d3			EEEE	xxxx				; 16 bit denominator
 5480/    1F46 :                        ;
 5481/    1F46 :                        ; returns -
 5482/    1F46 :                        ;
 5483/    1F46 :                        ; d1			xxxx	DDDD				; 16 bit result
 5484/    1F46 :                        ; d2				HHHH	IIII			; 32 bit remainder
 5485/    1F46 :                        
 5486/    1F46 :                        LAB_32_16
 5487/    1F46 : 2404                   	MOVE.l	d4,d2					; copy FAC2 mantissa		(AB)
 5488/    1F48 :                        LAB_3216
 5489/    1F48 : 2A03                   	MOVE.l	d3,d5					; copy FAC1 mantissa		(EF)
 5490/    1F4A : 4245                   	CLR.w		d5					; clear low word d1		(Ex)
 5491/    1F4C : 4845                   	SWAP		d5					; swap high word to low word	(xE)
 5492/    1F4E :                        
 5493/    1F4E :                        ; d3			EEEE	FFFF				; denominator copy
 5494/    1F4E :                        ; d5		0000	EEEE					; denominator high word
 5495/    1F4E :                        ; d2			AAAA	BBBB				; numerator copy
 5496/    1F4E :                        ; d4			AAAA	BBBB				; numerator
 5497/    1F4E :                        
 5498/    1F4E : 88C5                   	DIVU.w	d5,d4					; do FAC2/FAC1 high word	(AB/E)
 5499/    1F50 : 6802                   	BVC.s		LAB_LT_1				; if no overflow DIV was ok
 5500/    1F52 :                        
 5501/    1F52 : 78FF                   	MOVEQ		#-1,d4				; else set default value
 5502/    1F54 :                        
 5503/    1F54 :                        ; done the divide, now check the result, we have ...
 5504/    1F54 :                        
 5505/    1F54 :                        ; d3			EEEE	FFFF				; denominator copy
 5506/    1F54 :                        ; d5		0000	EEEE					; denominator high word
 5507/    1F54 :                        ; d2			AAAA	BBBB				; numerator copy
 5508/    1F54 :                        ; d4			MMMM	DDDD				; result MOD and DIV
 5509/    1F54 :                        
 5510/    1F54 :                        LAB_LT_1
 5511/    1F54 : 3C04                   	MOVE.w	d4,d6					; copy 16 bit result
 5512/    1F56 : 3204                   	MOVE.w	d4,d1					; copy 16 bit result again
 5513/    1F58 :                        
 5514/    1F58 :                        ; we now have ..
 5515/    1F58 :                        ; d3			EEEE	FFFF				; denominator copy
 5516/    1F58 :                        ; d5		0000	EEEE					; denominator high word
 5517/    1F58 :                        ; d6			xxxx  DDDD				; result DIV copy
 5518/    1F58 :                        ; d1			xxxx  DDDD				; result DIV copy
 5519/    1F58 :                        ; d2			AAAA	BBBB				; numerator copy
 5520/    1F58 :                        ; d4			MMMM	DDDD				; result MOD and DIV
 5521/    1F58 :                        
 5522/    1F58 :                        ; now multiply out 32 bit denominator by 16 bit result
 5523/    1F58 :                        ; QRS = AB*D
 5524/    1F58 :                        
 5525/    1F58 : CCC3                   	MULU.w	d3,d6					; FFFF	; DDDD =       rrrr  SSSS
 5526/    1F5A : C8C5                   	MULU.w	d5,d4					; EEEE	; DDDD = QQQQ  rrrr
 5527/    1F5C :                        
 5528/    1F5C :                        ; we now have ..
 5529/    1F5C :                        ; d3			EEEE	FFFF				; denominator copy
 5530/    1F5C :                        ; d5		0000	EEEE					; denominator high word
 5531/    1F5C :                        ; d6				rrrr  SSSS			; 48 bit result partial low
 5532/    1F5C :                        ; d1			xxxx  DDDD				; result DIV copy
 5533/    1F5C :                        ; d2			AAAA	BBBB				; numerator copy
 5534/    1F5C :                        ; d4			QQQQ	rrrr				; 48 bit result partial
 5535/    1F5C :                        
 5536/    1F5C : 3E06                   	MOVE.w	d6,d7					; copy low word of low multiply
 5537/    1F5E :                        
 5538/    1F5E :                        ; d7				xxxx	SSSS			; 48 bit result partial low
 5539/    1F5E :                        
 5540/    1F5E : 4246                   	CLR.w		d6					; clear low word of low multiply
 5541/    1F60 : 4846                   	SWAP		d6					; high word of low multiply to low word
 5542/    1F62 :                        
 5543/    1F62 :                        ; d6			0000	rrrr				; high word of 48 bit result partial low
 5544/    1F62 :                        
 5545/    1F62 : D886                   	ADD.l		d6,d4
 5546/    1F64 :                        
 5547/    1F64 :                        ; d4			QQQQ	RRRR				; 48 bit result partial high longword
 5548/    1F64 :                        
 5549/    1F64 : 7C00                   	MOVEQ		#0,d6					; clear to extend numerator to 48 bits
 5550/    1F66 :                        
 5551/    1F66 :                        ; now do GHI = AB0 - QRS (which is the remainder)
 5552/    1F66 :                        
 5553/    1F66 : 9C47                   	SUB.w		d7,d6					; low word subtract
 5554/    1F68 :                        
 5555/    1F68 :                        ; d6				xxxx	IIII			; remainder low word
 5556/    1F68 :                        
 5557/    1F68 : 9584                   	SUBX.l	d4,d2					; high longword subtract
 5558/    1F6A :                        
 5559/    1F6A :                        ; d2			GGGG	HHHH				; remainder high longword
 5560/    1F6A :                        
 5561/    1F6A :                        ; now if we got the divide correct then the remainder high longword will be +ve
 5562/    1F6A :                        
 5563/    1F6A : 6A08                   	BPL.s		L_DDIV				; branch if result is ok (<needed)
 5564/    1F6C :                        
 5565/    1F6C :                        ; remainder was -ve so DDDD is too big
 5566/    1F6C :                        
 5567/    1F6C :                        LAB_REMM
 5568/    1F6C : 5341                   	SUBQ.w	#1,d1					; adjust DDDD
 5569/    1F6E :                        
 5570/    1F6E :                        ; d3				xxxx	FFFF			; denominator copy
 5571/    1F6E :                        ; d6				xxxx	IIII			; remainder low word
 5572/    1F6E :                        
 5573/    1F6E : DC43                   	ADD.w		d3,d6					; add EF*1 low remainder low word
 5574/    1F70 :                        
 5575/    1F70 :                        ; d5			0000	EEEE				; denominator high word
 5576/    1F70 :                        ; d2			GGGG	HHHH				; remainder high longword
 5577/    1F70 :                        
 5578/    1F70 : D585                   	ADDX.l	d5,d2					; add extend EF*1 to remainder high longword
 5579/    1F72 : 6BF8                   	BMI.s		LAB_REMM				; loop if result still too big
 5580/    1F74 :                        
 5581/    1F74 :                        ; all done and result correct or <
 5582/    1F74 :                        
 5583/    1F74 :                        L_DDIV
 5584/    1F74 : 4842                   	SWAP		d2					; remainder mid word to high word
 5585/    1F76 :                        
 5586/    1F76 :                        ; d2			HHHH	GGGG				; (high word /should/ be $0000)
 5587/    1F76 :                        
 5588/    1F76 : 3406                   	MOVE.w	d6,d2					; remainder in high word
 5589/    1F78 :                        
 5590/    1F78 :                        ; d2				HHHH	IIII			; now is 32 bit remainder
 5591/    1F78 :                        ; d1			xxxx	DDDD				; 16 bit result
 5592/    1F78 :                        
 5593/    1F78 : 4E75                   	RTS
 5594/    1F7A :                        
 5595/    1F7A :                        
 5596/    1F7A :                        ;************************************************************************************
 5597/    1F7A :                        ;
 5598/    1F7A :                        ; unpack memory (a0) into FAC1
 5599/    1F7A :                        
 5600/    1F7A :                        LAB_UFAC
 5601/    1F7A : 2010                   	MOVE.l	(a0),d0				; get packed value
 5602/    1F7C : 4840                   	SWAP		d0					; exponent and sign into least significant word
 5603/    1F7E : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; save exponent and sign
 5604/    1F82 : 6708                   	BEQ.s		LAB_NB1T				; branch if exponent (and the rest) zero
 5605/    1F84 :                        
 5606/    1F84 : 807C 0080              	OR.w		#$80,d0				; set MSb
 5607/    1F88 : 4840                   	SWAP		d0					; word order back to normal
 5608/    1F8A : E180                   	ASL.l		#8,d0					; shift exponent & clear guard byte
 5609/    1F8C :                        LAB_NB1T
 5610/    1F8C : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; move into FAC1
 5611/    1F90 :                        
 5612/    1F90 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5613/    1F94 : 4E75                   	RTS
 5614/    1F96 :                        
 5615/    1F96 :                        
 5616/    1F96 :                        ;************************************************************************************
 5617/    1F96 :                        ;
 5618/    1F96 :                        ; set numeric variable, pack FAC1 into Lvarpl
 5619/    1F96 :                        
 5620/    1F96 :                        LAB_PFAC
 5621/    1F96 : 2F08                   	MOVE.l	a0,-(sp)				; save pointer
 5622/    1F98 : 206B 0472              	MOVEA.l	Lvarpl(a3),a0			; get destination pointer
 5623/    1F9C : 082B 0006 05B5         	BTST		#6,Dtypef(a3)			; test data type
 5624/    1FA2 : 670C                   	BEQ.s		LAB_277C				; branch if floating
 5625/    1FA4 :                        
 5626/    1FA4 : 6100 00C6              	BSR		LAB_2831				; convert FAC1 floating to fixed
 5627/    1FA8 :                        								; result in d0 and Itemp
 5628/    1FA8 : 2080                   	MOVE.l	d0,(a0)				; save in var
 5629/    1FAA : 205F                   	MOVE.l	(sp)+,a0				; restore pointer
 5630/    1FAC : 4E75                   	RTS
 5631/    1FAE :                        
 5632/    1FAE :                        
 5633/    1FAE :                        ;************************************************************************************
 5634/    1FAE :                        ;
 5635/    1FAE :                        ; normalise round and pack FAC1 into (a0)
 5636/    1FAE :                        
 5637/    1FAE :                        LAB_2778
 5638/    1FAE : 2F08                   	MOVE.l	a0,-(sp)				; save pointer
 5639/    1FB0 :                        LAB_277C
 5640/    1FB0 : 6100 FD60              	BSR		LAB_24D5				; normalise FAC1
 5641/    1FB4 : 612C                   	BSR.s		LAB_27BA				; round FAC1
 5642/    1FB6 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
 5643/    1FBA : E098                   	ROR.l		#8,d0					; align 24/32 bit mantissa
 5644/    1FBC : 4840                   	SWAP		d0					; exponent/sign into 0-15
 5645/    1FBE : C07C 007F              	AND.w		#$7F,d0				; clear exponent and sign bit
 5646/    1FC2 : 022B 0080 0595         	ANDI.b	#$80,FAC1_s(a3)			; clear non sign bits in sign
 5647/    1FC8 : 806B 0594              	OR.w		FAC1_e(a3),d0			; OR in exponent and sign
 5648/    1FCC : 4840                   	SWAP		d0					; move exponent and sign back to 16-31
 5649/    1FCE : 2080                   	MOVE.l	d0,(a0)				; store in destination
 5650/    1FD0 : 205F                   	MOVE.l	(sp)+,a0				; restore pointer
 5651/    1FD2 : 4E75                   	RTS
 5652/    1FD4 :                        
 5653/    1FD4 :                        
 5654/    1FD4 :                        ;************************************************************************************
 5655/    1FD4 :                        ;
 5656/    1FD4 :                        ; copy FAC2 to FAC1
 5657/    1FD4 :                        
 5658/    1FD4 :                        LAB_279B
 5659/    1FD4 : 376B 059C 0594         	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy exponent & sign
 5660/    1FDA : 276B 0598 0590         	MOVE.l	FAC2_m(a3),FAC1_m(a3)		; copy mantissa
 5661/    1FE0 : 4E75                   	RTS
 5662/    1FE2 :                        
 5663/    1FE2 :                        
 5664/    1FE2 :                        ;************************************************************************************
 5665/    1FE2 :                        ;
 5666/    1FE2 :                        ; round FAC1
 5667/    1FE2 :                        
 5668/    1FE2 :                        LAB_27BA
 5669/    1FE2 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5670/    1FE6 : 6720                   	BEQ.s		LAB_27C4				; branch if zero
 5671/    1FE8 :                        
 5672/    1FE8 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1
 5673/    1FEC : D0BC 0000 0080         	ADD.l		#$80,d0				; round to 24 bit
 5674/    1FF2 : 640A                   	BCC.s		LAB_27C3				; branch if no overflow
 5675/    1FF4 :                        
 5676/    1FF4 : E290                   	ROXR.l	#1,d0					; shift FAC1 mantissa
 5677/    1FF6 : 522B 0594              	ADDQ.b	#1,FAC1_e(a3)			; correct exponent
 5678/    1FFA : 6500 E560              	BCS		LAB_OFER				; if carry do overflow error & warm start
 5679/    1FFE :                        
 5680/    1FFE :                        LAB_27C3
 5681/    1FFE : C03C 0000              	AND.b		#$00,d0				; clear guard byte
 5682/    2002 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save back to FAC1
 5683/    2006 : 4E75                   	RTS
 5684/    2008 :                        
 5685/    2008 :                        LAB_27C4
 5686/    2008 : 1740 0595              	MOVE.b	d0,FAC1_s(a3)			; make zero always +ve
 5687/    200C :                        RTS_017
 5688/    200C : 4E75                   	RTS
 5689/    200E :                        
 5690/    200E :                        
 5691/    200E :                        ;************************************************************************************
 5692/    200E :                        ;
 5693/    200E :                        ; get FAC1 sign
 5694/    200E :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5695/    200E :                        
 5696/    200E :                        LAB_27CA
 5697/    200E : 7000                   	MOVEQ		#0,d0					; clear d0
 5698/    2010 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5699/    2014 : 67F6                   	BEQ.s		RTS_017				; exit if zero (already correct SGN(0)=0)
 5700/    2016 :                        
 5701/    2016 :                        
 5702/    2016 :                        ;************************************************************************************
 5703/    2016 :                        ;
 5704/    2016 :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5705/    2016 :                        ; no = 0 check
 5706/    2016 :                        
 5707/    2016 :                        LAB_27CE
 5708/    2016 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; else get FAC1 sign (b7)
 5709/    201A :                        
 5710/    201A :                        
 5711/    201A :                        ;************************************************************************************
 5712/    201A :                        ;
 5713/    201A :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5714/    201A :                        ; no = 0 check, sign in d0
 5715/    201A :                        
 5716/    201A :                        LAB_27D0
 5717/    201A : 4880                   	EXT.w		d0					; make word
 5718/    201C : 48C0                   	EXT.l		d0					; make longword
 5719/    201E : E080                   	ASR.l		#8,d0					; move sign bit through byte to carry
 5720/    2020 : 65EA                   	BCS.s		RTS_017				; exit if carry set
 5721/    2022 :                        
 5722/    2022 : 7001                   	MOVEQ		#1,d0					; set result for +ve sign
 5723/    2024 : 4E75                   	RTS
 5724/    2026 :                        
 5725/    2026 :                        
 5726/    2026 :                        ;************************************************************************************
 5727/    2026 :                        ;
 5728/    2026 :                        ; perform SGN()
 5729/    2026 :                        
 5730/    2026 :                        LAB_SGN
 5731/    2026 : 61E6                   	BSR.s		LAB_27CA				; get FAC1 sign
 5732/    2028 :                        								; return d0=-1/-ve d0=+1/+ve
 5733/    2028 :                        
 5734/    2028 :                        
 5735/    2028 :                        ;************************************************************************************
 5736/    2028 :                        ;
 5737/    2028 :                        ; save d0 as integer longword
 5738/    2028 :                        
 5739/    2028 :                        LAB_27DB
 5740/    2028 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
 5741/    202C : 377C A000 0594         	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent & sign
 5742/    2032 : D080                   	ADD.l		d0,d0					; top bit into carry
 5743/    2034 : 6000 FCD0              	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
 5744/    2038 :                        
 5745/    2038 :                        
 5746/    2038 :                        ;************************************************************************************
 5747/    2038 :                        ;
 5748/    2038 :                        ; perform ABS()
 5749/    2038 :                        
 5750/    2038 :                        LAB_ABS
 5751/    2038 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear FAC1 sign
 5752/    203E : 4E75                   	RTS
 5753/    2040 :                        
 5754/    2040 :                        
 5755/    2040 :                        ;************************************************************************************
 5756/    2040 :                        ;
 5757/    2040 :                        ; compare FAC1 with FAC2
 5758/    2040 :                        ; returns d0=+1 Cb=0 if FAC1 > FAC2
 5759/    2040 :                        ; returns d0= 0 Cb=0 if FAC1 = FAC2
 5760/    2040 :                        ; returns d0=-1 Cb=1 if FAC1 < FAC2
 5761/    2040 :                        
 5762/    2040 :                        LAB_27FA
 5763/    2040 : 122B 059C              	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
 5764/    2044 : 67C8                   	BEQ.s		LAB_27CA				; branch if FAC2 exponent=0 & get FAC1 sign
 5765/    2046 :                        								; d0=-1,C=1/-ve d0=+1,C=0/+ve
 5766/    2046 :                        
 5767/    2046 : 102B 059E              	MOVE.b	FAC_sc(a3),d0			; get FAC sign compare
 5768/    204A : 6BCA                   	BMI.s		LAB_27CE				; if signs <> do return d0=-1,C=1/-ve
 5769/    204C :                        								; d0=+1,C=0/+ve & return
 5770/    204C :                        
 5771/    204C : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 5772/    2050 : B22B 0594              	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
 5773/    2054 : 660A                   	BNE.s		LAB_2828				; branch if different
 5774/    2056 :                        
 5775/    2056 : 222B 0598              	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
 5776/    205A : B2AB 0590              	CMP.l		FAC1_m(a3),d1			; compare mantissas
 5777/    205E : 6708                   	BEQ.s		LAB_282F				; exit if mantissas equal
 5778/    2060 :                        
 5779/    2060 :                        ; gets here if number <> FAC1
 5780/    2060 :                        
 5781/    2060 :                        LAB_2828
 5782/    2060 : 65B8                   	BCS.s		LAB_27D0				; if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
 5783/    2062 :                        								; C=0/+ve
 5784/    2062 :                        
 5785/    2062 : 0A00 0080              	EORI.b	#$80,d0				; else toggle FAC1 sign
 5786/    2066 :                        LAB_282E
 5787/    2066 : 60B2                   	BRA.s		LAB_27D0				; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5788/    2068 :                        
 5789/    2068 :                        LAB_282F
 5790/    2068 : 7000                   	MOVEQ		#0,d0					; clear result
 5791/    206A : 4E75                   	RTS
 5792/    206C :                        
 5793/    206C :                        
 5794/    206C :                        ;************************************************************************************
 5795/    206C :                        ;
 5796/    206C :                        ; convert FAC1 floating to fixed
 5797/    206C :                        ; result in d0 and Itemp, sets flags correctly
 5798/    206C :                        
 5799/    206C :                        LAB_2831
 5800/    206C : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; copy mantissa
 5801/    2070 : 6732                   	BEQ.s		LAB_284J				; branch if mantissa = 0
 5802/    2072 :                        
 5803/    2072 : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 5804/    2074 : 123C 00A0              	MOVE.b		#$A0,d1				; set for no floating bits
 5805/    2078 : 922B 0594              	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent
 5806/    207C : 6500 E4DE              	BCS		LAB_OFER				; do overflow if too big
 5807/    2080 :                        
 5808/    2080 : 660E                   	BNE.s		LAB_284G				; branch if exponent was not $A0
 5809/    2082 :                        
 5810/    2082 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign
 5811/    2086 : 6A1A                   	BPL.s		LAB_284H				; branch if FAC1 +ve
 5812/    2088 :                        
 5813/    2088 : 4480                   	NEG.l		d0
 5814/    208A : 6916                   	BVS.s		LAB_284H				; branch if was $80000000
 5815/    208C :                        
 5816/    208C : 6000 E4CE              	BRA		LAB_OFER				; do overflow if too big
 5817/    2090 :                        
 5818/    2090 :                        LAB_284G
 5819/    2090 : B23C 0020              	CMP.b		#$20,d1				; compare with minimum result for integer
 5820/    2094 : 6502                   	BCS.s		LAB_284L				; if < minimum just do shift
 5821/    2096 :                        
 5822/    2096 : 7000                   	MOVEQ		#0,d0					; else return zero
 5823/    2098 :                        LAB_284L
 5824/    2098 : E2A8                   	LSR.l		d1,d0					; shift integer
 5825/    209A :                        
 5826/    209A : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
 5827/    209E : 6A02                   	BPL.s		LAB_284H				; branch if FAC1 +ve
 5828/    20A0 :                        
 5829/    20A0 : 4480                   	NEG.l		d0					; negate integer value
 5830/    20A2 :                        LAB_284H
 5831/    20A2 : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 5832/    20A4 :                        LAB_284J
 5833/    20A4 : 2740 042A              	MOVE.l	d0,Itemp(a3)			; save result to Itemp
 5834/    20A8 : 4E75                   	RTS
 5835/    20AA :                        
 5836/    20AA :                        
 5837/    20AA :                        ;************************************************************************************
 5838/    20AA :                        ;
 5839/    20AA :                        ; perform INT()
 5840/    20AA :                        
 5841/    20AA :                        LAB_INT
 5842/    20AA : 103C 00A0              	MOVE.b		#$A0,d0				; set for no floating bits
 5843/    20AE : 902B 0594              	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
 5844/    20B2 : 6310                   	BLS.s		LAB_IRTS				; exit if exponent >= $A0
 5845/    20B4 :                        								; (too big for fraction part!)
 5846/    20B4 :                        
 5847/    20B4 : B03C 0020              	CMP.b		#$20,d0				; compare with minimum result for integer
 5848/    20B8 : 6400 0262              	BCC		LAB_POZE				; if >= minimum go return 0
 5849/    20BC :                        								; (too small for integer part!)
 5850/    20BC :                        
 5851/    20BC : 72FF                   	MOVEQ		#-1,d1				; set integer mask
 5852/    20BE : E1A1                   	ASL.l		d0,d1					; shift mask [8+2*d0]
 5853/    20C0 : C3AB 0590              	AND.l		d1,FAC1_m(a3)			; mask mantissa
 5854/    20C4 :                        LAB_IRTS
 5855/    20C4 : 4E75                   	RTS
 5856/    20C6 :                        
 5857/    20C6 :                        
 5858/    20C6 :                        ;************************************************************************************
 5859/    20C6 :                        ;
 5860/    20C6 :                        ; print " in line [LINE #]"
 5861/    20C6 :                        
 5862/    20C6 :                        LAB_2953
 5863/    20C6 : 41FA 1800              	LEA		LAB_LMSG(pc),a0			; point to " in line " message
 5864/    20CA : 6100 ED1C              	BSR		LAB_18C3				; print null terminated string
 5865/    20CE :                        
 5866/    20CE :                        								; Print Basic line #
 5867/    20CE : 202B 0452              	MOVE.l	Clinel(a3),d0			; get current line
 5868/    20D2 :                        
 5869/    20D2 :                        
 5870/    20D2 :                        ;************************************************************************************
 5871/    20D2 :                        ;
 5872/    20D2 :                        ; print d0 as unsigned integer
 5873/    20D2 :                        
 5874/    20D2 :                        LAB_295E
 5875/    20D2 : 43FA 0DEE              	LEA		Bin2dec(pc),a1			; get table address
 5876/    20D6 : 7200                   	MOVEQ		#0,d1					; table index
 5877/    20D8 : 41EB 05CC              	LEA		Usdss(a3),a0			; output string start
 5878/    20DC : 2401                   	MOVE.l	d1,d2					; output string index
 5879/    20DE :                        LAB_2967
 5880/    20DE : 2631 1000              	MOVE.l	(a1,d1.w),d3			; get table value
 5881/    20E2 : 6714                   	BEQ.s		LAB_2969				; exit if end marker
 5882/    20E4 :                        
 5883/    20E4 : 782F                   	MOVEQ		#'0'-1,d4				; set character to "0"-1
 5884/    20E6 :                        LAB_2968
 5885/    20E6 : 5244                   	ADDQ.w	#1,d4					; next numeric character
 5886/    20E8 : 9083                   	SUB.l		d3,d0					; subtract table value
 5887/    20EA : 6AFA                   	BPL.s		LAB_2968				; not overdone so loop
 5888/    20EC :                        
 5889/    20EC : D083                   	ADD.l		d3,d0					; correct value
 5890/    20EE : 1184 2000              	MOVE.b	d4,(a0,d2.w)			; character out to string
 5891/    20F2 : 5841                   	ADDQ.w	#4,d1					; increment table pointer
 5892/    20F4 : 5242                   	ADDQ.w	#1,d2					; increment output string pointer
 5893/    20F6 : 60E6                   	BRA.s		LAB_2967				; loop
 5894/    20F8 :                        
 5895/    20F8 :                        LAB_2969
 5896/    20F8 : D03C 0030              	ADD.b		#'0',d0				; make last character
 5897/    20FC : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; character out to string
 5898/    2100 : 5348                   	SUBQ.w	#1,a0					; decrement a0 (allow simple loop)
 5899/    2102 :                        
 5900/    2102 :                        								; now find non zero start of string
 5901/    2102 :                        LAB_296A
 5902/    2102 : 5248                   	ADDQ.w	#1,a0					; increment a0 (this will never carry to b16)
 5903/    2104 : 43EB 05D5              	LEA		BHsend-1(a3),a1			; get string end
 5904/    2108 : B1C9                   	CMPA.l	a1,a0					; are we at end
 5905/    210A : 6700 ECDC              	BEQ		LAB_18C3				; if so print null terminated string and RETURN
 5906/    210E :                        
 5907/    210E : 0C10 0030              	CMPI.b	#'0',(a0)				; is character "0" ?
 5908/    2112 : 67EE                   	BEQ.s		LAB_296A				; loop if so
 5909/    2114 :                        
 5910/    2114 : 6000 ECD2              	BRA		LAB_18C3				; print null terminated string from memory & RET
 5911/    2118 :                        
 5912/    2118 :                        
 5913/    2118 :                        ;************************************************************************************
 5914/    2118 :                        ;
 5915/    2118 :                        ; convert FAC1 to ASCII string result in (a0)
 5916/    2118 :                        ; STR$() function enters here
 5917/    2118 :                        
 5918/    2118 :                        ; now outputs 7 significant digits
 5919/    2118 :                        
 5920/    2118 :                        ; d0 is character out
 5921/    2118 :                        ; d1 is save index
 5922/    2118 :                        ; d2 is gash
 5923/    2118 :                        
 5924/    2118 :                        ; a0 is output string pointer
 5925/    2118 :                        
 5926/    2118 :                        LAB_2970
 5927/    2118 : 43EB 05C6              	LEA		Decss(a3),a1			; set output string start
 5928/    211C :                        
 5929/    211C : 7420                   	MOVEQ		#' ',d2				; character = " ", assume +ve
 5930/    211E : 08AB 0007 0595         	BCLR.b	#7,FAC1_s(a3)			; test and clear FAC1 sign (b7)
 5931/    2124 : 6702                   	BEQ.s		LAB_2978				; branch if +ve
 5932/    2126 :                        
 5933/    2126 : 742D                   	MOVEQ		#'-',d2				; else character = "-"
 5934/    2128 :                        LAB_2978
 5935/    2128 : 1282                   	MOVE.b	d2,(a1)				; save the sign character
 5936/    212A : 142B 0594              	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
 5937/    212E : 6608                   	BNE.s		LAB_2989				; branch if FAC1<>0
 5938/    2130 :                        
 5939/    2130 :                        								; exponent was $00 so FAC1 is 0
 5940/    2130 : 7030                   	MOVEQ		#'0',d0				; set character = "0"
 5941/    2132 : 7201                   	MOVEQ		#1,d1					; set output string index
 5942/    2134 : 6000 01A8              	BRA		LAB_2A89				; save last character, [EOT] & exit
 5943/    2138 :                        
 5944/    2138 :                        								; FAC1 is some non zero value
 5945/    2138 :                        LAB_2989
 5946/    2138 : 177C 0000 05AC         	MOVE.b	#0,numexp(a3)			; clear number exponent count
 5947/    213E : B43C 0081              	CMP.b		#$81,d2				; compare FAC1 exponent with $81 (>1.00000)
 5948/    2142 :                        
 5949/    2142 : 6448                   	BCC.s		LAB_299C				; branch if FAC1=>1
 5950/    2144 :                        
 5951/    2144 :                        								; else FAC1 < 1
 5952/    2144 : 277C 9896 8000 0598    	MOVE.l	#$98968000,FAC2_m(a3)		; 10000000 mantissa
 5953/    214C : 377C 9800 059C         	MOVE.w	#$9800,FAC2_e(a3)			; 10000000 exponent & sign
 5954/    2152 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make FAC1 sign sign compare
 5955/    2158 : 6100 FCE0              	BSR		LAB_MULTIPLY			; do FAC2*FAC1
 5956/    215C :                        
 5957/    215C : 177C 00F9 05AC         	MOVE.b	#$F9,numexp(a3)			; set number exponent count (-7)
 5958/    2162 : 6028                   	BRA.s		LAB_299C				; go test for fit
 5959/    2164 :                        
 5960/    2164 :                        LAB_29B9
 5961/    2164 : 376B 0594 059C         	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
 5962/    216A : 276B 0590 0598         	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
 5963/    2170 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; save FAC1_s as sign compare
 5964/    2176 :                        
 5965/    2176 : 277C CCCC CCCD 0590    	MOVE.l	#$CCCCCCCD,FAC1_m(a3)		; 1/10 mantissa
 5966/    217E : 377C 7D00 0594         	MOVE.w	#$7D00,FAC1_e(a3)			; 1/10 exponent & sign
 5967/    2184 : 6100 FCB4              	BSR		LAB_MULTIPLY			; do FAC2*FAC1, effectively divide by 10 but
 5968/    2188 :                        								; faster
 5969/    2188 :                        
 5970/    2188 : 522B 05AC              	ADDQ.b	#1,numexp(a3)			; increment number exponent count
 5971/    218C :                        LAB_299C
 5972/    218C : 277C 9896 7F70 0598    	MOVE.l	#$98967F70,FAC2_m(a3)		; 9999999.4375 mantissa
 5973/    2194 : 377C 9800 059C         	MOVE.w	#$9800,FAC2_e(a3)			; 9999999.4375 exponent & sign
 5974/    219A :                        								; (max before scientific notation)
 5975/    219A : 6100 0150              	BSR		LAB_27F0				; fast compare FAC1 with FAC2
 5976/    219E :                        								; returns d0=+1 C=0 if FAC1 > FAC2
 5977/    219E :                        								; returns d0= 0 C=0 if FAC1 = FAC2
 5978/    219E :                        								; returns d0=-1 C=1 if FAC1 < FAC2
 5979/    219E : 62C4                   	BHI.s		LAB_29B9				; go do /10 if FAC1 > 9999999.4375
 5980/    21A0 :                        
 5981/    21A0 : 6750                   	BEQ.s		LAB_29C3				; branch if FAC1 = 9999999.4375
 5982/    21A2 :                        
 5983/    21A2 :                        								; FAC1 < 9999999.4375
 5984/    21A2 : 277C F423 F800 0598    	MOVE.l	#$F423F800,FAC2_m(a3)		; set mantissa for 999999.5
 5985/    21AA : 377C 9400 059C         	MOVE.w	#$9400,FAC2_e(a3)			; set exponent for 999999.5
 5986/    21B0 :                        
 5987/    21B0 : 41EB 0590              	LEA		FAC1_m(a3),a0			; set pointer for x10
 5988/    21B4 :                        LAB_29A7
 5989/    21B4 : 6100 0136              	BSR		LAB_27F0				; fast compare FAC1 with FAC2
 5990/    21B8 :                        								; returns d0=+1 C=0 if FAC1 > FAC2
 5991/    21B8 :                        								; returns d0= 0 C=0 if FAC1 = FAC2
 5992/    21B8 :                        								; returns d0=-1 C=1 if FAC1 < FAC2
 5993/    21B8 : 6220                   	BHI.s		LAB_29C0				; branch if FAC1 > 99999.9375,no decimal places
 5994/    21BA :                        
 5995/    21BA :                        								; FAC1 <= 999999.5 so do x 10
 5996/    21BA : 2010                   	MOVE.l	(a0),d0				; get FAC1 mantissa
 5997/    21BC : 1228 0004              	MOVE.b	4(a0),d1				; get FAC1 exponent
 5998/    21C0 : 2400                   	MOVE.l	d0,d2					; copy it
 5999/    21C2 : E488                   	LSR.l		#2,d0					; /4
 6000/    21C4 : D082                   	ADD.l		d2,d0					; add FAC1 (x1.125)
 6001/    21C6 : 6404                   	BCC.s		LAB_29B7				; branch if no carry
 6002/    21C8 :                        
 6003/    21C8 : E290                   	ROXR.l	#1,d0					; shift carry back in
 6004/    21CA : 5201                   	ADDQ.b	#1,d1					; increment exponent (never overflows)
 6005/    21CC :                        LAB_29B7
 6006/    21CC : 5601                   	ADDQ.b	#3,d1					; correct exponent ( 8 x 1.125 = 10 )
 6007/    21CE :                        								; (never overflows)
 6008/    21CE : 2080                   	MOVE.l	d0,(a0)				; save new mantissa
 6009/    21D0 : 1141 0004              	MOVE.b	d1,4(a0)				; save new exponent
 6010/    21D4 : 532B 05AC              	SUBQ.b	#1,numexp(a3)			; decrement number exponent count
 6011/    21D8 : 60DA                   	BRA.s		LAB_29A7				; go test again
 6012/    21DA :                        
 6013/    21DA :                        								; now we have just the digits to do
 6014/    21DA :                        LAB_29C0
 6015/    21DA : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 0.5
 6016/    21E2 : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for 0.5
 6017/    21E8 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
 6018/    21EE : 6100 FAA6              	BSR		LAB_ADD				; add the 0.5 to FAC1 (round FAC1)
 6019/    21F2 :                        
 6020/    21F2 :                        LAB_29C3
 6021/    21F2 : 6100 FE78              	BSR		LAB_2831				; convert FAC1 floating to fixed
 6022/    21F6 :                        								; result in d0 and Itemp
 6023/    21F6 : 7401                   	MOVEQ		#$01,d2				; set default digits before dp = 1
 6024/    21F8 : 102B 05AC              	MOVE.b	numexp(a3),d0			; get number exponent count
 6025/    21FC : D03C 0008              	ADD.b		#8,d0					; allow 7 digits before point
 6026/    2200 : 6B0C                   	BMI.s		LAB_29D9				; if -ve then 1 digit before dp
 6027/    2202 :                        
 6028/    2202 : B03C 0009              	CMP.b		#$09,d0				; d0>=9 if n>=1E7
 6029/    2206 : 6406                   	BCC.s		LAB_29D9				; branch if >= $09
 6030/    2208 :                        
 6031/    2208 :                        								; < $08
 6032/    2208 : 5300                   	SUBQ.b	#1,d0					; take 1 from digit count
 6033/    220A : 1400                   	MOVE.b	d0,d2					; copy byte
 6034/    220C : 7002                   	MOVEQ		#$02,d0				; set exponent adjust
 6035/    220E :                        LAB_29D9
 6036/    220E : 7200                   	MOVEQ		#0,d1					; set output string index
 6037/    2210 : 5500                   	SUBQ.b	#2,d0					; -2
 6038/    2212 : 1740 05AD              	MOVE.b	d0,expcnt(a3)			; save exponent adjust
 6039/    2216 : 1742 05AC              	MOVE.b	d2,numexp(a3)			; save digits before dp count
 6040/    221A : 1002                   	MOVE.b	d2,d0					; copy digits before dp count
 6041/    221C : 6702                   	BEQ.s		LAB_29E4				; branch if no digits before dp
 6042/    221E :                        
 6043/    221E : 6A14                   	BPL.s		LAB_29F7				; branch if digits before dp
 6044/    2220 :                        
 6045/    2220 :                        LAB_29E4
 6046/    2220 : 5281                   	ADDQ.l	#1,d1					; increment index
 6047/    2222 : 13BC 002E 1000         	MOVE.b	#'.',(a1,d1.w)			; save to output string
 6048/    2228 :                        
 6049/    2228 : 4A02                   	TST.b		d2					; test digits before dp count
 6050/    222A : 6708                   	BEQ.s		LAB_29F7				; branch if no digits before dp
 6051/    222C :                        
 6052/    222C : 5281                   	ADDQ.l	#1,d1					; increment index
 6053/    222E : 13BC 0030 1000         	MOVE.b	#'0',(a1,d1.w)			; save to output string
 6054/    2234 :                        LAB_29F7
 6055/    2234 : 7400                   	MOVEQ		#0,d2					; clear index (point to 1,000,000)
 6056/    2236 : 7080                   	MOVEQ		#$80-$100,d0			; set output character
 6057/    2238 :                        LAB_29FB
 6058/    2238 : 41FA 1122              	LEA		LAB_2A9A(pc),a0			; get base of table
 6059/    223C : 2630 2000              	MOVE.l	(a0,d2.w),d3			; get table value
 6060/    2240 :                        LAB_29FD
 6061/    2240 : 5200                   	ADDQ.b	#1,d0					; increment output character
 6062/    2242 : D7AB 042A              	ADD.l		d3,Itemp(a3)			; add to (now fixed) mantissa
 6063/    2246 : 0800 0007              	BTST		#7,d0					; set test sense (z flag only)
 6064/    224A : 6504                   	BCS.s		LAB_2A18				; did carry so has wrapped past zero
 6065/    224C :                        
 6066/    224C : 67F2                   	BEQ.s		LAB_29FD				; no wrap and +ve test so try again
 6067/    224E :                        
 6068/    224E : 6002                   	BRA.s		LAB_2A1A				; found this digit
 6069/    2250 :                        
 6070/    2250 :                        LAB_2A18
 6071/    2250 : 66EE                   	BNE.s		LAB_29FD				; wrap and -ve test so try again
 6072/    2252 :                        
 6073/    2252 :                        LAB_2A1A
 6074/    2252 : 6406                   	BCC.s		LAB_2A21				; branch if +ve test result
 6075/    2254 :                        
 6076/    2254 : 4400                   	NEG.b		d0					; negate the digit number
 6077/    2256 : D03C 000B              	ADD.b		#$0B,d0				; and subtract from 11 decimal
 6078/    225A :                        LAB_2A21
 6079/    225A : D03C 002F              	ADD.b		#$2F,d0				; add "0"-1 to result
 6080/    225E : 5842                   	ADDQ.w	#4,d2					; increment index to next less power of ten
 6081/    2260 : 5241                   	ADDQ.w	#1,d1					; increment output string index
 6082/    2262 : 1600                   	MOVE.b	d0,d3					; copy character to d3
 6083/    2264 : C63C 007F              	AND.b		#$7F,d3				; mask out top bit
 6084/    2268 : 1383 1000              	MOVE.b	d3,(a1,d1.w)			; save to output string
 6085/    226C : 042B 0001 05AC         	SUB.b		#1,numexp(a3)			; decrement # of characters before the dp
 6086/    2272 : 6608                   	BNE.s		LAB_2A3B				; branch if still characters to do
 6087/    2274 :                        
 6088/    2274 :                        								; else output the point
 6089/    2274 : 5281                   	ADDQ.l	#1,d1					; increment index
 6090/    2276 : 13BC 002E 1000         	MOVE.b	#'.',(a1,d1.w)			; save to output string
 6091/    227C :                        LAB_2A3B
 6092/    227C : C03C 0080              	AND.b		#$80,d0				; mask test sense bit
 6093/    2280 : 0A00 0080              	EORI.b	#$80,d0				; invert it
 6094/    2284 : B43C 001C              	CMP.b		#LAB_2A9B-LAB_2A9A,d2		; compare table index with max+4
 6095/    2288 : 66AE                   	BNE.s		LAB_29FB				; loop if not max
 6096/    228A :                        
 6097/    228A :                        								; now remove trailing zeroes
 6098/    228A :                        LAB_2A4B
 6099/    228A : 1031 1000              	MOVE.b	(a1,d1.w),d0			; get character from output string
 6100/    228E : 5381                   	SUBQ.l	#1,d1					; decrement output string index
 6101/    2290 : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 6102/    2294 : 67F4                   	BEQ.s		LAB_2A4B				; loop until non "0" character found
 6103/    2296 :                        
 6104/    2296 : B03C 002E              	CMP.b		#'.',d0				; compare with "."
 6105/    229A : 6702                   	BEQ.s		LAB_2A58				; branch if was dp
 6106/    229C :                        
 6107/    229C :                        								; else restore last character
 6108/    229C : 5281                   	ADDQ.l	#1,d1					; increment output string index
 6109/    229E :                        LAB_2A58
 6110/    229E : 13BC 002B 1002         	MOVE.b	#'+',2(a1,d1.w)			; save character "+" to output string
 6111/    22A4 : 4A2B 05AD              	TST.b		expcnt(a3)				; test exponent count
 6112/    22A8 : 6738                   	BEQ.s		LAB_2A8C				; if zero go set null terminator & exit
 6113/    22AA :                        
 6114/    22AA :                        								; exponent isn't zero so write exponent
 6115/    22AA : 6A0A                   	BPL.s		LAB_2A68				; branch if exponent count +ve
 6116/    22AC :                        
 6117/    22AC : 13BC 002D 1002         	MOVE.b	#'-',2(a1,d1.w)			; save character "-" to output string
 6118/    22B2 : 442B 05AD              	NEG.b		expcnt(a3)				; convert -ve to +ve
 6119/    22B6 :                        LAB_2A68
 6120/    22B6 : 13BC 0045 1001         	MOVE.b	#'E',1(a1,d1.w)			; save character "E" to output string
 6121/    22BC : 142B 05AD              	MOVE.b	expcnt(a3),d2			; get exponent count
 6122/    22C0 : 702F                   	MOVEQ		#$2F,d0				; one less than "0" character
 6123/    22C2 :                        LAB_2A74
 6124/    22C2 : 5200                   	ADDQ.b	#1,d0					; increment 10's character
 6125/    22C4 : 943C 000A              	SUB.b		#$0A,d2				; subtract 10 from exponent count
 6126/    22C8 : 64F8                   	BCC.s		LAB_2A74				; loop while still >= 0
 6127/    22CA :                        
 6128/    22CA : D43C 003A              	ADD.b		#$3A,d2				; add character ":", $30+$0A, result is 10-value
 6129/    22CE : 1380 1003              	MOVE.b	d0,3(a1,d1.w)			; save 10's character to output string
 6130/    22D2 : 1382 1004              	MOVE.b	d2,4(a1,d1.w)			; save 1's character to output string
 6131/    22D6 : 13BC 0000 1005         	MOVE.b	#0,5(a1,d1.w)			; save null terminator after last character
 6132/    22DC : 600A                   	BRA.s		LAB_2A91				; go set string pointer (a0) and exit
 6133/    22DE :                        
 6134/    22DE :                        LAB_2A89
 6135/    22DE : 1380 1000              	MOVE.b	d0,(a1,d1.w)			; save last character to output string
 6136/    22E2 :                        LAB_2A8C
 6137/    22E2 : 13BC 0000 1001         	MOVE.b	#0,1(a1,d1.w)			; save null terminator after last character
 6138/    22E8 :                        LAB_2A91
 6139/    22E8 : 2049                   	MOVEA.l	a1,a0					; set result string pointer (a0)
 6140/    22EA : 4E75                   	RTS
 6141/    22EC :                        
 6142/    22EC :                        
 6143/    22EC :                        ;************************************************************************************
 6144/    22EC :                        ;
 6145/    22EC :                        ; fast compare FAC1 with FAC2
 6146/    22EC :                        ; assumes both are +ve and FAC2>0
 6147/    22EC :                        ; returns d0=+1 C=0 if FAC1 > FAC2
 6148/    22EC :                        ; returns d0= 0 C=0 if FAC1 = FAC2
 6149/    22EC :                        ; returns d0=-1 C=1 if FAC1 < FAC2
 6150/    22EC :                        
 6151/    22EC :                        LAB_27F0
 6152/    22EC : 7000                   	MOVEQ		#0,d0					; set for FAC1 = FAC2
 6153/    22EE : 122B 059C              	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
 6154/    22F2 : B22B 0594              	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
 6155/    22F6 : 660A                   	BNE.s		LAB_27F1				; branch if different
 6156/    22F8 :                        
 6157/    22F8 : 222B 0598              	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
 6158/    22FC : B2AB 0590              	CMP.l		FAC1_m(a3),d1			; compare mantissas
 6159/    2300 : 6708                   	BEQ.s		LAB_27F3				; exit if mantissas equal
 6160/    2302 :                        
 6161/    2302 :                        LAB_27F1
 6162/    2302 : 6504                   	BCS.s		LAB_27F2				; if FAC1 > FAC2 return d0=+1,C=0
 6163/    2304 :                        
 6164/    2304 : 5380                   	SUBQ.l	#1,d0					; else FAC1 < FAC2 return d0=-1,C=1
 6165/    2306 : 4E75                   	RTS
 6166/    2308 :                        
 6167/    2308 :                        LAB_27F2
 6168/    2308 : 5280                   	ADDQ.l	#1,d0
 6169/    230A :                        LAB_27F3
 6170/    230A : 4E75                   	RTS
 6171/    230C :                        
 6172/    230C :                        
 6173/    230C :                        ;************************************************************************************
 6174/    230C :                        ;
 6175/    230C :                        ; make FAC1 = 1
 6176/    230C :                        
 6177/    230C :                        LAB_POON
 6178/    230C : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; 1 mantissa
 6179/    2314 : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; 1 exonent & sign
 6180/    231A : 4E75                   	RTS
 6181/    231C :                        
 6182/    231C :                        
 6183/    231C :                        ;************************************************************************************
 6184/    231C :                        ;
 6185/    231C :                        ; make FAC1 = 0
 6186/    231C :                        
 6187/    231C :                        LAB_POZE
 6188/    231C : 7000                   	MOVEQ		#0,d0					; clear longword
 6189/    231E : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
 6190/    2322 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; 0 exonent & sign
 6191/    2326 : 4E75                   	RTS
 6192/    2328 :                        
 6193/    2328 :                        
 6194/    2328 :                        ;************************************************************************************
 6195/    2328 :                        ;
 6196/    2328 :                        ; perform power function
 6197/    2328 :                        ; the number is in FAC2, the power is in FAC1
 6198/    2328 :                        ; no longer trashes Itemp
 6199/    2328 :                        
 6200/    2328 :                        LAB_POWER
 6201/    2328 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test power
 6202/    232C : 67DE                   	BEQ.s		LAB_POON				; if zero go return 1
 6203/    232E :                        
 6204/    232E : 4A2B 059C              	TST.b		FAC2_e(a3)				; test number
 6205/    2332 : 67E8                   	BEQ.s		LAB_POZE				; if zero go return 0
 6206/    2334 :                        
 6207/    2334 : 1F2B 059D              	MOVE.b	FAC2_s(a3),-(sp)			; save number sign
 6208/    2338 : 6A20                   	BPL.s		LAB_POWP				; power of positive number
 6209/    233A :                        
 6210/    233A : 7200                   	MOVEQ		#0,d1					; clear d1
 6211/    233C : 1741 059D              	MOVE.b	d1,FAC2_s(a3)			; make sign +ve
 6212/    2340 :                        
 6213/    2340 :                        								; number sign was -ve and can only be raised to
 6214/    2340 :                        								; an integer power which gives an x +j0 result,
 6215/    2340 :                        								; else do 'function call' error
 6216/    2340 : 122B 0594              	MOVE.b	FAC1_e(a3),d1			; get power exponent
 6217/    2344 : 927C 0080              	SUB.w		#$80,d1				; normalise to .5
 6218/    2348 : 6300 E216              	BLS		LAB_FCER				; if 0<power<1 then do 'function call' error
 6219/    234C :                        
 6220/    234C :                        								; now shift all the integer bits out
 6221/    234C : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get power mantissa
 6222/    2350 : E3A0                   	ASL.l		d1,d0					; shift mantissa
 6223/    2352 : 6600 E20C              	BNE		LAB_FCER				; if power<>INT(power) then do 'function call'
 6224/    2356 :                        								; error
 6225/    2356 :                        
 6226/    2356 : 6502                   	BCS.s		LAB_POWP				; if integer value odd then leave result -ve
 6227/    2358 :                        
 6228/    2358 : 1E80                   	MOVE.b	d0,(sp)				; save result sign +ve
 6229/    235A :                        LAB_POWP
 6230/    235A : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; save power mantissa
 6231/    235E : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; save power sign & exponent
 6232/    2362 :                        
 6233/    2362 : 6100 FC70              	BSR		LAB_279B				; copy number to FAC1
 6234/    2366 : 6100 F9E0              	BSR		LAB_LOG				; find log of number
 6235/    236A :                        
 6236/    236A : 301F                   	MOVE.w	(sp)+,d0				; get power sign & exponent
 6237/    236C : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; get power mantissa
 6238/    2370 : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save sign & exponent to FAC2
 6239/    2374 : 1740 059E              	MOVE.b	d0,FAC_sc(a3)			; save sign as sign compare
 6240/    2378 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 6241/    237C : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
 6242/    2380 :                        
 6243/    2380 : 6100 FAB8              	BSR		LAB_MULTIPLY			; multiply by power
 6244/    2384 : 6158                   	BSR.s		LAB_EXP				; find exponential
 6245/    2386 : 175F 0595              	MOVE.b	(sp)+,FAC1_s(a3)			; restore number sign
 6246/    238A : 4E75                   	RTS
 6247/    238C :                        
 6248/    238C :                        
 6249/    238C :                        ;************************************************************************************
 6250/    238C :                        ;
 6251/    238C :                        ; do - FAC1
 6252/    238C :                        
 6253/    238C :                        LAB_GTHAN
 6254/    238C : 4A2B 0594              	TST.b		FAC1_e(a3)				; test for non zero FAC1
 6255/    2390 : 6706                   	BEQ.s		RTS_020				; branch if null
 6256/    2392 :                        
 6257/    2392 : 0A2B 0080 0595         	EORI.b	#$80,FAC1_s(a3)			; (else) toggle FAC1 sign bit
 6258/    2398 :                        RTS_020
 6259/    2398 : 4E75                   	RTS
 6260/    239A :                        
 6261/    239A :                        
 6262/    239A :                        ;************************************************************************************
 6263/    239A :                        ;
 6264/    239A :                        								; return +1
 6265/    239A :                        LAB_EX1
 6266/    239A : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; +1 mantissa
 6267/    23A2 : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; +1 sign & exponent
 6268/    23A8 : 4E75                   	RTS
 6269/    23AA :                        								; do over/under flow
 6270/    23AA :                        LAB_EXOU
 6271/    23AA : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 6272/    23AE : 6A00 E1AC              	BPL		LAB_OFER				; was +ve so do overflow error
 6273/    23B2 :                        
 6274/    23B2 :                        								; else underflow so return zero
 6275/    23B2 : 7000                   	MOVEQ		#0,d0					; clear longword
 6276/    23B4 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
 6277/    23B8 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; 0 sign & exponent
 6278/    23BC : 4E75                   	RTS
 6279/    23BE :                        								; fraction was zero so do 2^n
 6280/    23BE :                        LAB_EXOF
 6281/    23BE : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; +n mantissa
 6282/    23C6 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear sign
 6283/    23CC : 4A2B 05B4              	TST.b		cosout(a3)				; test sign flag
 6284/    23D0 : 6A02                   	BPL.s		LAB_EXOL				; branch if +ve
 6285/    23D2 :                        
 6286/    23D2 : 4481                   	NEG.l		d1					; else do 1/2^n
 6287/    23D4 :                        LAB_EXOL
 6288/    23D4 : D23C 0081              	ADD.b		#$81,d1				; adjust exponent
 6289/    23D8 : 1741 0594              	MOVE.b	d1,FAC1_e(a3)			; save exponent
 6290/    23DC : 4E75                   	RTS
 6291/    23DE :                        
 6292/    23DE :                        ; perform EXP()	(x^e)
 6293/    23DE :                        ; valid input range is -88 to +88
 6294/    23DE :                        
 6295/    23DE :                        LAB_EXP
 6296/    23DE : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent
 6297/    23E2 : 67B6                   	BEQ.s		LAB_EX1				; return 1 for zero in
 6298/    23E4 :                        
 6299/    23E4 : B03C 0064              	CMP.b		#$64,d0				; compare exponent with min
 6300/    23E8 : 65B0                   	BCS.s		LAB_EX1				; if smaller just return 1
 6301/    23EA :                        
 6302/    23EA :                        ;	MOVEM.l	d1-d6/a0,-(sp)			; save the registers
 6303/    23EA : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; flag +ve number
 6304/    23F0 : 222B 0590              	MOVE.l	FAC1_m(a3),d1			; get mantissa
 6305/    23F4 : B03C 0087              	CMP.b		#$87,d0				; compare exponent with max
 6306/    23F8 : 62B0                   	BHI.s		LAB_EXOU				; go do over/under flow if greater
 6307/    23FA :                        
 6308/    23FA : 6608                   	BNE.s		LAB_EXCM				; branch if less
 6309/    23FC :                        
 6310/    23FC :                        								; else is 2^7
 6311/    23FC : B2BC B00F 33C7         	CMP.l		#$B00F33C7,d1			; compare mantissa with n*2^7 max
 6312/    2402 : 64A6                   	BCC.s		LAB_EXOU				; if => go over/underflow
 6313/    2404 :                        
 6314/    2404 :                        LAB_EXCM
 6315/    2404 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 6316/    2408 : 6A0C                   	BPL.s		LAB_EXPS				; branch if arg +ve
 6317/    240A :                        
 6318/    240A : 177C 00FF 05B4         	MOVE.b	#$FF,cosout(a3)			; flag -ve number
 6319/    2410 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; take absolute value
 6320/    2416 :                        LAB_EXPS
 6321/    2416 :                        								; now do n/LOG(2)
 6322/    2416 : 277C B8AA 3B29 0598    	MOVE.l	#$B8AA3B29,FAC2_m(a3)		; 1/LOG(2) mantissa
 6323/    241E : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; 1/LOG(2) exponent & sign
 6324/    2424 : 177C 0000 059E         	MOVE.b	#0,FAC_sc(a3)			; we know they're both +ve
 6325/    242A : 6100 FA0E              	BSR		LAB_MULTIPLY			; effectively divide by log(2)
 6326/    242E :                        
 6327/    242E :                        								; max here is +/- 127
 6328/    242E :                        								; now separate integer and fraction
 6329/    242E : 177C 0000 05D9         	MOVE.b	#0,tpower(a3)			; clear exponent add byte
 6330/    2434 : 1A2B 0594              	MOVE.b	FAC1_e(a3),d5			; get exponent
 6331/    2438 : 9A3C 0080              	SUB.b		#$80,d5				; normalise
 6332/    243C : 6324                   	BLS.s		LAB_ESML				; branch if < 1 (d5 is 0 or -ve)
 6333/    243E :                        
 6334/    243E :                        								; result is > 1
 6335/    243E : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6336/    2442 : 2200                   	MOVE.l	d0,d1					; copy it
 6337/    2444 : 2C05                   	MOVE.l	d5,d6					; copy normalised exponent
 6338/    2446 :                        
 6339/    2446 : 4446                   	NEG.w		d6					; make -ve
 6340/    2448 : DC7C 0020              	ADD.w		#32,d6				; is now 32-d6
 6341/    244C : ECA9                   	LSR.l		d6,d1					; just integer bits
 6342/    244E : 1741 05D9              	MOVE.b	d1,tpower(a3)			; set exponent add byte
 6343/    2452 :                        
 6344/    2452 : EBA8                   	LSL.l		d5,d0					; shift out integer bits
 6345/    2454 : 6700 FF68              	BEQ		LAB_EXOF				; fraction is zero so do 2^n
 6346/    2458 :                        
 6347/    2458 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; fraction to FAC1
 6348/    245C : 377C 8000 0594         	MOVE.w	#$8000,FAC1_e(a3)			; set exponent & sign
 6349/    2462 :                        
 6350/    2462 :                        								; multiple was < 1
 6351/    2462 :                        LAB_ESML
 6352/    2462 : 277C B172 17F8 0598    	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
 6353/    246A : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
 6354/    2470 : 177C 0000 059E         	MOVE.b	#0,FAC_sc(a3)			; clear sign compare
 6355/    2476 : 6100 F9C2              	BSR		LAB_MULTIPLY			; multiply by log(2)
 6356/    247A :                        
 6357/    247A : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6358/    247E : 1A2B 0594              	MOVE.b	FAC1_e(a3),d5			; get exponent
 6359/    2482 : 9A7C 0082              	SUB.w		#$82,d5				; normalise and -2 (result is -1 to -30)
 6360/    2486 : 4445                   	NEG.w		d5					; make +ve
 6361/    2488 : EAA8                   	LSR.l		d5,d0					; shift for 2 integer bits
 6362/    248A :                        
 6363/    248A :                        ; d0 = arg
 6364/    248A :                        ; d6 = x, d1 = y
 6365/    248A :                        ; d2 = x1, d3 = y1
 6366/    248A :                        ; d4 = shift count
 6367/    248A :                        ; d5 = loop count
 6368/    248A :                        								; now do cordic set-up
 6369/    248A : 7200                   	MOVEQ		#0,d1					; y = 0
 6370/    248C : 2C3C 26A3 D110         	MOVE.l	#KFCTSEED,d6			; x = 1 with jkh inverse factored out
 6371/    2492 : 41FA 0D2C              	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic arctan table
 6372/    2496 : 7800                   	MOVEQ		#0,d4					; clear shift count
 6373/    2498 :                         
 6374/    2498 :                        								; cordic loop, shifts 4 and 13 (and 39
 6375/    2498 :                        								; if it went that far) need to be repeated
 6376/    2498 : 7A03                   	MOVEQ		#3,d5					; 4 loops
 6377/    249A : 6136                   	BSR.s		LAB_EXCC				; do loops 1 through 4
 6378/    249C : 5948                   	SUBQ.w	#4,a0					; do table entry again
 6379/    249E : 5384                   	SUBQ.l	#1,d4					; do shift count again
 6380/    24A0 : 7A09                   	MOVEQ		#9,d5					; 10 loops
 6381/    24A2 : 612E                   	BSR.s		LAB_EXCC				; do loops 4 (again) through 13
 6382/    24A4 : 5948                   	SUBQ.w	#4,a0					; do table entry again
 6383/    24A6 : 5384                   	SUBQ.l	#1,d4					; do shift count again
 6384/    24A8 : 7A12                   	MOVEQ		#18,d5				; 19 loops
 6385/    24AA : 6126                   	BSR.s		LAB_EXCC				; do loops 13 (again) through 31
 6386/    24AC :                         
 6387/    24AC :                        								; now get the result
 6388/    24AC : 4A2B 05B4              	TST.b		cosout(a3)				; test sign flag
 6389/    24B0 : 6A06                   	BPL.s		LAB_EXPL				; branch if +ve
 6390/    24B2 :                        
 6391/    24B2 : 4481                   	NEG.l		d1					; do -y
 6392/    24B4 : 442B 05D9              	NEG.b		tpower(a3)				; do -exp
 6393/    24B8 :                        LAB_EXPL
 6394/    24B8 : 7083                   	MOVEQ		#$83-$100,d0			; set exponent
 6395/    24BA : DC81                   	ADD.l		d1,d6					; y = y +/- x
 6396/    24BC : 6B06                   	BMI.s		LAB_EXRN				; branch if result normal
 6397/    24BE :                        
 6398/    24BE :                        LAB_EXNN
 6399/    24BE : 5380                   	SUBQ.l	#1,d0					; decrement exponent
 6400/    24C0 : DC86                   	ADD.l		d6,d6					; shift mantissa
 6401/    24C2 : 6AFA                   	BPL.s		LAB_EXNN				; loop if not normal
 6402/    24C4 :                        
 6403/    24C4 :                        LAB_EXRN
 6404/    24C4 : 2746 0590              	MOVE.l	d6,FAC1_m(a3)			; save exponent result
 6405/    24C8 : D02B 05D9              	ADD.b		tpower(a3),d0			; add integer part
 6406/    24CC : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save exponent
 6407/    24D0 :                        ;	MOVEM.l	(sp)+,d1-d6/a0			; restore registers
 6408/    24D0 : 4E75                   	RTS
 6409/    24D2 :                         
 6410/    24D2 :                        								; cordic loop
 6411/    24D2 :                        LAB_EXCC
 6412/    24D2 : 5284                   	ADDQ.l	#1,d4					; increment shift count
 6413/    24D4 : 2406                   	MOVE.l	d6,d2					; x1 = x
 6414/    24D6 : E8A2                   	ASR.l		d4,d2					; x1 >> n
 6415/    24D8 : 2601                   	MOVE.l	d1,d3					; y1 = y
 6416/    24DA : E8A3                   	ASR.l		d4,d3					; y1 >> n
 6417/    24DC : 4A80                   	TST.l		d0					; test arg
 6418/    24DE : 6B0C                   	BMI.s		LAB_EXAD				; branch if -ve
 6419/    24E0 :                        
 6420/    24E0 : D282                   	ADD.l		d2,d1					; y = y + x1
 6421/    24E2 : DC83                   	ADD.l		d3,d6					; x = x + y1
 6422/    24E4 : 9098                   	SUB.l		(a0)+,d0				; arg = arg - atnh(a0)
 6423/    24E6 : 51CD FFEA              	DBF		d5,LAB_EXCC				; decrement and loop if not done
 6424/    24EA :                        
 6425/    24EA : 4E75                   	RTS
 6426/    24EC :                        
 6427/    24EC :                        LAB_EXAD
 6428/    24EC : 9282                   	SUB.l		d2,d1					; y = y - x1
 6429/    24EE : 9C83                   	SUB.l		d3,d6					; x = x + y1
 6430/    24F0 : D098                   	ADD.l		(a0)+,d0				; arg = arg + atnh(a0)
 6431/    24F2 : 51CD FFDE              	DBF		d5,LAB_EXCC				; decrement and loop if not done
 6432/    24F6 :                        
 6433/    24F6 : 4E75                   	RTS
 6434/    24F8 :                        
 6435/    24F8 :                        
 6436/    24F8 :                        ;************************************************************************************
 6437/    24F8 :                        ;
 6438/    24F8 :                        ; RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
 6439/    24F8 :                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
 6440/    24F8 :                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
 6441/    24F8 :                        
 6442/    24F8 :                        ; Entropy = 7.997442 bits per byte
 6443/    24F8 :                        ; Optimum compression would reduce these 65536 bytes by 0 percent
 6444/    24F8 :                        
 6445/    24F8 :                        ; Chi square distribution for 65536 samples is 232.01, and
 6446/    24F8 :                        ; randomly would exceed this value 75.00 percent of the time
 6447/    24F8 :                        
 6448/    24F8 :                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
 6449/    24F8 :                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
 6450/    24F8 :                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
 6451/    24F8 :                        
 6452/    24F8 :                        LAB_RND
 6453/    24F8 : 4A2B 0594              	TST.b		FAC1_e(a3)				; get FAC1 exponent
 6454/    24FC : 6708                   	BEQ.s		NextPRN				; do next random number if zero
 6455/    24FE :                        
 6456/    24FE :                        								; else get seed into random number store
 6457/    24FE : 41EB 05A0              	LEA		PRNlword(a3),a0			; set PRNG pointer
 6458/    2502 : 6100 FAAA              	BSR		LAB_2778				; pack FAC1 into (a0)
 6459/    2506 :                        NextPRN
 6460/    2506 : 72AF                   	MOVEQ		#$AF-$100,d1			; set EOR value
 6461/    2508 : 7412                   	MOVEQ		#18,d2				; do this 19 times
 6462/    250A : 202B 05A0              	MOVE.l	PRNlword(a3),d0			; get current
 6463/    250E :                        Ninc0
 6464/    250E : D080                   	ADD.l		d0,d0					; shift left 1 bit
 6465/    2510 : 6402                   	BCC.s		Ninc1					; branch if bit 32 not set
 6466/    2512 :                        
 6467/    2512 : B300                   	EOR.b		d1,d0					; do Galois LFSR feedback
 6468/    2514 :                        Ninc1
 6469/    2514 : 51CA FFF8              	DBF		d2,Ninc0				; loop
 6470/    2518 :                        
 6471/    2518 : 2740 05A0              	MOVE.l	d0,PRNlword(a3)			; save back to seed word
 6472/    251C : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; copy to FAC1 mantissa
 6473/    2520 : 377C 8000 0594         	MOVE.w	#$8000,FAC1_e(a3)			; set the exponent and clear the sign
 6474/    2526 : 6000 F7EA              	BRA		LAB_24D5				; normalise FAC1 & return
 6475/    252A :                        
 6476/    252A :                        
 6477/    252A :                        ;************************************************************************************
 6478/    252A :                        ;
 6479/    252A :                        ; cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
 6480/    252A :                        ; x = angle in radians
 6481/    252A :                        
 6482/    252A :                        LAB_TAN
 6483/    252A : 6138                   	BSR.s		LAB_SIN				; go do SIN/COS cordic compute
 6484/    252C : 376B 0594 059C         	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
 6485/    2532 : 276B 0590 0598         	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
 6486/    2538 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; get COS(x) mantissa
 6487/    253C : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; get COS(x) exponent
 6488/    2540 : 6700 E01A              	BEQ		LAB_OFER				; do overflow if COS = 0
 6489/    2544 :                        
 6490/    2544 : 6100 F7CC              	BSR		LAB_24D5				; normalise FAC1
 6491/    2548 : 6000 F97C              	BRA		LAB_DIVIDE				; do FAC2/FAC1 and return, FAC_sc set by SIN
 6492/    254C :                        								; COS calculation
 6493/    254C :                        
 6494/    254C :                        
 6495/    254C :                        ;************************************************************************************
 6496/    254C :                        ;
 6497/    254C :                        ; cordic SIN(x), COS(x) routine
 6498/    254C :                        ; x = angle in radians
 6499/    254C :                        
 6500/    254C :                        LAB_COS
 6501/    254C : 277C C90F DAA3 0598    	MOVE.l	#$C90FDAA3,FAC2_m(a3)		; pi/2 mantissa (LSB is rounded up so
 6502/    2554 :                        								; COS(PI/2)=0)
 6503/    2554 : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; pi/2 exponent and sign
 6504/    255A : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
 6505/    2560 : 6100 F734              	BSR		LAB_ADD				; add FAC2 to FAC1, adjust for COS(x)
 6506/    2564 :                        
 6507/    2564 :                        
 6508/    2564 :                        ;************************************************************************************
 6509/    2564 :                        ;
 6510/    2564 :                        ; SIN/COS cordic calculator
 6511/    2564 :                        
 6512/    2564 :                        LAB_SIN
 6513/    2564 : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; set needed result
 6514/    256A :                        
 6515/    256A : 277C A2F9 836F 0598    	MOVE.l	#$A2F9836F,FAC2_m(a3)		; 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
 6516/    2572 : 377C 7F00 059C         	MOVE.w	#$7F00,FAC2_e(a3)			; 1/pi exponent & sign
 6517/    2578 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
 6518/    257E : 6100 F8BA              	BSR		LAB_MULTIPLY			; multiply by 1/pi
 6519/    2582 :                        
 6520/    2582 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 6521/    2586 : 671C                   	BEQ.s		LAB_SCZE				; branch if zero
 6522/    2588 :                        
 6523/    2588 : 41FA 0B36              	LEA		TAB_SNCO(pc),a0			; get pointer to constants table
 6524/    258C : 2C2B 0590              	MOVE.l	FAC1_m(a3),d6			; get FAC1 mantissa
 6525/    2590 : 5300                   	SUBQ.b	#1,d0					; 2 radians in 360 degrees so /2
 6526/    2592 : 6710                   	BEQ.s		LAB_SCZE				; branch if zero
 6527/    2594 :                        
 6528/    2594 : 903C 0080              	SUB.b		#$80,d0				; normalise exponent
 6529/    2598 : 6B18                   	BMI.s		LAB_SCL0				; branch if < 1
 6530/    259A :                        
 6531/    259A :                        								; X is > 1
 6532/    259A : B03C 0020              	CMP.b		#$20,d0				; is it >= 2^32
 6533/    259E : 6404                   	BCC.s		LAB_SCZE				; may as well do zero
 6534/    25A0 :                        
 6535/    25A0 : E1AE                   	LSL.l		d0,d6					; shift out integer part bits
 6536/    25A2 : 6618                   	BNE.s		LAB_CORD				; if fraction go test quadrant and adjust
 6537/    25A4 :                        
 6538/    25A4 :                        								; else no fraction so do zero
 6539/    25A4 :                        LAB_SCZE
 6540/    25A4 : 7481                   	MOVEQ		#$81-$100,d2			; set exponent for 1.0
 6541/    25A6 : 7600                   	MOVEQ		#0,d3					; set exponent for 0.0
 6542/    25A8 : 203C 8000 0000         	MOVE.l	#$80000000,d0			; mantissa for 1.0
 6543/    25AE : 2203                   	MOVE.l	d3,d1					; mantissa for 0.0
 6544/    25B0 : 6062                   	BRA.s		outloop				; go output it
 6545/    25B2 :                        
 6546/    25B2 :                        								; x is < 1
 6547/    25B2 :                        LAB_SCL0
 6548/    25B2 : 4400                   	NEG.b		d0					; make +ve
 6549/    25B4 : B03C 001E              	CMP.b		#$1E,d0				; is it <= 2^-30
 6550/    25B8 : 64EA                   	BCC.s		LAB_SCZE				; may as well do zero
 6551/    25BA :                        
 6552/    25BA : E0AE                   	LSR.l		d0,d6					; shift out <= 2^-32 bits
 6553/    25BC :                        
 6554/    25BC :                        ; cordic calculator, argument in d6
 6555/    25BC :                        ; table pointer in a0, returns in d0-d3
 6556/    25BC :                        
 6557/    25BC :                        LAB_CORD
 6558/    25BC : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; copy as sign compare for TAN
 6559/    25C2 : DC86                   	ADD.l		d6,d6					; shift 0.5 bit into carry
 6560/    25C4 : 6406                   	BCC.s		LAB_LTPF				; branch if less than 0.5
 6561/    25C6 :                        
 6562/    25C6 : 0A2B 00FF 0595         	EORI.b	#$FF,FAC1_s(a3)			; toggle result sign
 6563/    25CC :                        LAB_LTPF
 6564/    25CC : DC86                   	ADD.l		d6,d6					; shift 0.25 bit into carry
 6565/    25CE : 640C                   	BCC.s		LAB_LTPT				; branch if less than 0.25
 6566/    25D0 :                        
 6567/    25D0 : 0A2B 00FF 05B4         	EORI.b	#$FF,cosout(a3)			; toggle needed result
 6568/    25D6 : 0A2B 00FF 059E         	EORI.b	#$FF,FAC_sc(a3)			; toggle sign compare for TAN
 6569/    25DC :                        
 6570/    25DC :                        LAB_LTPT
 6571/    25DC : E48E                   	LSR.l		#2,d6					; shift the bits back (clear integer bits)
 6572/    25DE : 67C4                   	BEQ.s		LAB_SCZE				; no fraction so go do zero
 6573/    25E0 :                        
 6574/    25E0 :                        								; set start values
 6575/    25E0 : 7A01                   	MOVEQ		#1,d5					; set bit count
 6576/    25E2 : 2028 FFFC              	MOVE.l	-4(a0),d0				; get multiply constant (1st itteration d0)
 6577/    25E6 : 2200                   	MOVE.l	d0,d1					; 1st itteration d1
 6578/    25E8 : 9C98                   	SUB.l		(a0)+,d6				; 1st always +ve so do 1st step
 6579/    25EA : 6008                   	BRA.s		mainloop				; jump into routine
 6580/    25EC :                        
 6581/    25EC :                        subloop
 6582/    25EC : 9C98                   	SUB.l		(a0)+,d6				; z = z - arctan(i)/2pi
 6583/    25EE : 9083                   	SUB.l		d3,d0					; x = x - y1
 6584/    25F0 : D282                   	ADD.l		d2,d1					; y = y + x1
 6585/    25F2 : 6012                   	BRA.s		nexta					; back to main loop
 6586/    25F4 :                        
 6587/    25F4 :                        mainloop
 6588/    25F4 : 2400                   	MOVE.l	d0,d2					; x1 = x
 6589/    25F6 : EAA2                   	ASR.l		d5,d2					; / (2 ^ i)
 6590/    25F8 : 2601                   	MOVE.l	d1,d3					; y1 = y
 6591/    25FA : EAA3                   	ASR.l		d5,d3					; / (2 ^ i)
 6592/    25FC : 4A86                   	TST.l		d6					; test sign (is 2^0 bit)
 6593/    25FE : 6AEC                   	BPL.s		subloop				; go do subtract if > 1
 6594/    2600 :                        
 6595/    2600 : DC98                   	ADD.l		(a0)+,d6				; z = z + arctan(i)/2pi
 6596/    2602 : D083                   	ADD.l		d3,d0					; x = x + y1
 6597/    2604 : 9282                   	SUB.l		d2,d1					; y = y + x1
 6598/    2606 :                        nexta
 6599/    2606 : 5285                   	ADDQ.l	#1,d5					; i = i + 1
 6600/    2608 : BABC 0000 001E         	CMP.l		#$1E,d5				; check end condition
 6601/    260E : 66E4                   	BNE.s		mainloop				; loop if not all done
 6602/    2610 :                        
 6603/    2610 :                        								; now untangle output value
 6604/    2610 : 7481                   	MOVEQ		#$81-$100,d2			; set exponent for 0 to .99 rec.
 6605/    2612 : 2602                   	MOVE.l	d2,d3					; copy it for cos output
 6606/    2614 :                        outloop
 6607/    2614 : 4A2B 05B4              	TST.b		cosout(a3)				; did we want cos output?
 6608/    2618 : 6B04                   	BMI.s		subexit				; if so skip
 6609/    261A :                        
 6610/    261A : C141                   	EXG		d0,d1					; swap SIN and COS mantissas
 6611/    261C : C543                   	EXG		d2,d3					; swap SIN and COS exponents
 6612/    261E :                        subexit
 6613/    261E : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; set result mantissa
 6614/    2622 : 1742 0594              	MOVE.b	d2,FAC1_e(a3)			; set result exponent
 6615/    2626 : 6000 F6EA              	BRA		LAB_24D5				; normalise FAC1 & return
 6616/    262A :                        
 6617/    262A :                        
 6618/    262A :                        
 6619/    262A :                        ;************************************************************************************
 6620/    262A :                        ;
 6621/    262A :                        ; perform ATN()
 6622/    262A :                        
 6623/    262A :                        LAB_ATN
 6624/    262A : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 6625/    262E : 6700 00AC              	BEQ		RTS_021				; ATN(0) = 0 so skip calculation
 6626/    2632 :                        
 6627/    2632 : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; set result needed
 6628/    2638 : B03C 0081              	CMP.b		#$81,d0				; compare exponent with 1
 6629/    263C : 6528                   	BCS.s		LAB_ATLE				; branch if n<1
 6630/    263E :                        
 6631/    263E : 6608                   	BNE.s		LAB_ATGO				; branch if n>1
 6632/    2640 :                        
 6633/    2640 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6634/    2644 : D080                   	ADD.l		d0,d0					; shift left
 6635/    2646 : 671E                   	BEQ.s		LAB_ATLE				; branch if n=1
 6636/    2648 :                        
 6637/    2648 :                        LAB_ATGO
 6638/    2648 : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
 6639/    2650 : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
 6640/    2656 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
 6641/    265C : 6100 F868              	BSR		LAB_DIVIDE				; do 1/n
 6642/    2660 : 177C 00FF 05B4         	MOVE.b	#$FF,cosout(a3)			; set inverse result needed
 6643/    2666 :                        LAB_ATLE
 6644/    2666 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
 6645/    266A : 123C 0082              	MOVE.b		#$82,d1				; set to correct exponent
 6646/    266E : 922B 0594              	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent (always <= 1)
 6647/    2672 : E2A8                   	LSR.l		d1,d0					; shift in two integer part bits
 6648/    2674 : 41FA 0ACA              	LEA		TAB_ATNC(pc),a0			; get pointer to arctan table
 6649/    2678 : 7C00                   	MOVEQ		#0,d6					; Z = 0
 6650/    267A : 223C 4000 0000         	MOVE.l	#1<<30,d1				; y = 1
 6651/    2680 : 7A1D                   	MOVEQ		#29,d5				; loop 30 times
 6652/    2682 : 7801                   	MOVEQ		#1,d4					; shift counter
 6653/    2684 : 6006                   	BRA.s		LAB_ATCD				; enter loop
 6654/    2686 :                        
 6655/    2686 :                        LAB_ATNP
 6656/    2686 : E8A2                   	ASR.l		d4,d2					; x1 / 2^i
 6657/    2688 : D282                   	ADD.l		d2,d1					; y = y + x1
 6658/    268A : DC90                   	ADD.l		(a0),d6				; z = z + atn(i)
 6659/    268C :                        LAB_ATCD
 6660/    268C : 2400                   	MOVE.l	d0,d2					; x1 = x
 6661/    268E : 2601                   	MOVE.l	d1,d3					; y1 = y
 6662/    2690 : E8A3                   	ASR.l		d4,d3					; y1 / 2^i
 6663/    2692 :                        LAB_CATN
 6664/    2692 : 9083                   	SUB.l		d3,d0					; x = x - y1
 6665/    2694 : 6AF0                   	BPL.s		LAB_ATNP				; branch if x >= 0
 6666/    2696 :                        
 6667/    2696 : 2002                   	MOVE.l	d2,d0					; else get x back
 6668/    2698 : 5848                   	ADDQ.w	#4,a0					; increment pointer
 6669/    269A : 5284                   	ADDQ.l	#1,d4					; increment i
 6670/    269C : E283                   	ASR.l		#1,d3					; y1 / 2^i
 6671/    269E : 51CD FFF2              	DBF		d5,LAB_CATN				; decrement and loop if not done
 6672/    26A2 :                        
 6673/    26A2 : 177C 0082 0594         	MOVE.b	#$82,FAC1_e(a3)			; set new exponent
 6674/    26A8 : 2746 0590              	MOVE.l	d6,FAC1_m(a3)			; save mantissa
 6675/    26AC : 6100 F664              	BSR		LAB_24D5				; normalise FAC1
 6676/    26B0 :                        
 6677/    26B0 : 4A2B 05B4              	TST.b		cosout(a3)				; was it > 1 ?
 6678/    26B4 : 6A26                   	BPL.s		RTS_021				; branch if not
 6679/    26B6 :                        
 6680/    26B6 : 1E2B 0595              	MOVE.b	FAC1_s(a3),d7			; get sign
 6681/    26BA : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear sign
 6682/    26C0 : 277C C90F DAA2 0598    	MOVE.l	#$C90FDAA2,FAC2_m(a3)		; set -(pi/2)
 6683/    26C8 : 377C 8180 059C         	MOVE.w	#$8180,FAC2_e(a3)			; set exponent and sign
 6684/    26CE : 177C 00FF 059E         	MOVE.b	#$FF,FAC_sc(a3)			; set sign compare
 6685/    26D4 : 6100 F5C0              	BSR		LAB_ADD				; perform addition, FAC2 to FAC1
 6686/    26D8 : 1747 0595              	MOVE.b	d7,FAC1_s(a3)			; restore sign
 6687/    26DC :                        RTS_021
 6688/    26DC : 4E75                   	RTS
 6689/    26DE :                        
 6690/    26DE :                        
 6691/    26DE :                        ;************************************************************************************
 6692/    26DE :                        ;
 6693/    26DE :                        ; perform BITSET
 6694/    26DE :                        
 6695/    26DE :                        LAB_BITSET
 6696/    26DE : 6100 F496              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6697/    26E2 :                        								; first parameter in a0, second in d0
 6698/    26E2 : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6699/    26E6 : 6400 DE78              	BCC		LAB_FCER				; branch if > 7
 6700/    26EA :                        
 6701/    26EA : 01D0                   	BSET		d0,(a0)				; set bit
 6702/    26EC : 4E75                   	RTS
 6703/    26EE :                        
 6704/    26EE :                        
 6705/    26EE :                        ;************************************************************************************
 6706/    26EE :                        ;
 6707/    26EE :                        ; perform BITCLR
 6708/    26EE :                        
 6709/    26EE :                        LAB_BITCLR
 6710/    26EE : 6100 F486              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6711/    26F2 :                        								; first parameter in a0, second in d0
 6712/    26F2 : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6713/    26F6 : 6400 DE68              	BCC		LAB_FCER				; branch if > 7
 6714/    26FA :                        
 6715/    26FA : 0190                   	BCLR		d0,(a0)				; clear bit
 6716/    26FC : 4E75                   	RTS
 6717/    26FE :                        
 6718/    26FE :                        
 6719/    26FE :                        ;************************************************************************************
 6720/    26FE :                        ;
 6721/    26FE :                        ; perform BITTST()
 6722/    26FE :                        
 6723/    26FE :                        LAB_BTST
 6724/    26FE : 101D                   	MOVE.b	(a5)+,d0				; increment BASIC pointer
 6725/    2700 : 6100 F474              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6726/    2704 :                        								; first parameter in a0, second in d0
 6727/    2704 : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6728/    2708 : 6400 DE56              	BCC		LAB_FCER				; branch if > 7
 6729/    270C :                        
 6730/    270C : 2200                   	MOVE.l	d0,d1					; copy bit # to test
 6731/    270E : 6100 EAA4              	BSR		LAB_GBYT				; get next BASIC byte
 6732/    2712 : B03C 0029              	CMP.b		#')',d0				; is next character ")"
 6733/    2716 : 6600 DE54              	BNE		LAB_SNER				; if not ")" go do syntax error, then warm start
 6734/    271A :                        
 6735/    271A : 6100 EA96              	BSR		LAB_IGBY				; update execute pointer (to character past ")")
 6736/    271E : 7000                   	MOVEQ		#0,d0					; set the result as zero
 6737/    2720 : 0310                   	BTST		d1,(a0)				; test bit
 6738/    2722 : 6700 F904              	BEQ		LAB_27DB				; branch if zero (already correct)
 6739/    2726 :                        
 6740/    2726 : 70FF                   	MOVEQ		#-1,d0				; set for -1 result
 6741/    2728 : 6000 F8FE              	BRA		LAB_27DB				; go do SGN tail
 6742/    272C :                        
 6743/    272C :                        
 6744/    272C :                        ;************************************************************************************
 6745/    272C :                        ;
 6746/    272C :                        ; perform USING$()
 6747/    272C :                        
 6748/    272C : =$0                    fsd		EQU	 0						;   (sp) format string descriptor pointer
 6749/    272C : =$4                    fsti	EQU	 4						;  4(sp) format string this index
 6750/    272C : =$6                    fsli	EQU	 6						;  6(sp) format string last index
 6751/    272C : =$8                    fsdpi	EQU	 8						;  8(sp) format string decimal point index
 6752/    272C : =$A                    fsdc	EQU	10						; 10(sp) format string decimal characters
 6753/    272C : =$8                    fend	EQU	12-4						;  x(sp) end-4, fsd is popped by itself
 6754/    272C :                        
 6755/    272C : ='#'                   ofchr	EQU	'#'						; the overflow character
 6756/    272C :                        
 6757/    272C :                        LAB_USINGS
 6758/    272C : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string
 6759/    2730 : 6A00 DDE6              	BPL		LAB_FOER				; if not string type go do format error
 6760/    2734 :                        
 6761/    2734 : 246B 0590              	MOVEA.l	FAC1_m(a3),a2			; get the format string descriptor pointer
 6762/    2738 : 3E2A 0004              	MOVE.w	4(a2),d7				; get the format string length
 6763/    273C : 6700 DDDA              	BEQ		LAB_FOER				; if null string go do format error
 6764/    2740 :                        
 6765/    2740 :                        ; clear the format string values
 6766/    2740 :                        
 6767/    2740 : 7000                   	MOVEQ		#0,d0					; clear d0
 6768/    2742 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string decimal characters
 6769/    2744 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string decimal point index
 6770/    2746 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string last index
 6771/    2748 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string this index
 6772/    274A : 2F0A                   	MOVE.l	a2,-(sp)				; save the format string descriptor pointer
 6773/    274C :                        
 6774/    274C :                        ; make a null return string for the first string add
 6775/    274C :                        
 6776/    274C : 7200                   	MOVEQ		#0,d1					; make a null string
 6777/    274E : 2041                   	MOVEA.l	d1,a0					; with a null pointer
 6778/    2750 : 6100 F0BE              	BSR		LAB_RTST				; push a string on the descriptor stack
 6779/    2754 :                        								; a0 = pointer, d1 = length
 6780/    2754 :                        
 6781/    2754 :                        ; do the USING$() function next value
 6782/    2754 :                        
 6783/    2754 : 101D                   	MOVE.b	(a5)+,d0				; get the next BASIC byte
 6784/    2756 :                        LAB_U002
 6785/    2756 : B03C 002C              	CMP.b		#',',d0				; compare with comma
 6786/    275A : 6600 DE10              	BNE		LAB_SNER				; if not "," go do syntax error
 6787/    275E :                        
 6788/    275E : 6100 028E              	BSR		LAB_ProcFo				; process the format string
 6789/    2762 : 4A02                   	TST.b		d2					; test the special characters flag
 6790/    2764 : 6700 DDB2              	BEQ		LAB_FOER				; if no special characters go do format error
 6791/    2768 :                        
 6792/    2768 : 6100 E8E8              	BSR		LAB_EVEX				; evaluate the expression
 6793/    276C : 4A2B 05B5              	TST.b		Dtypef(a3)				; test the data type
 6794/    2770 : 6B00 DDCE              	BMI		LAB_TMER				; if string type go do type missmatch error
 6795/    2774 :                        
 6796/    2774 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 6797/    2778 : 6732                   	BEQ.s		LAB_U004				; if FAC1 = 0 skip the rounding
 6798/    277A :                        
 6799/    277A : 322F 000A              	MOVE.w	fsdc(sp),d1				; get the format string decimal character count
 6800/    277E : B27C 0008              	CMP.w		#8,d1					; compare the fraction digit count with 8
 6801/    2782 : 6428                   	BCC.s		LAB_U004				; if >= 8 skip the rounding
 6802/    2784 :                        
 6803/    2784 : 3001                   	MOVE.w	d1,d0					; else copy the fraction digit count
 6804/    2786 : D241                   	ADD.w		d1,d1					;	; 2
 6805/    2788 : D240                   	ADD.w		d0,d1					;	; 3
 6806/    278A : D241                   	ADD.w		d1,d1					;	; 6
 6807/    278C : 41FA 0844              	LEA		LAB_P_10(pc),a0			; get the rounding table base
 6808/    2790 : 2770 1002 0598         	MOVE.l	2(a0,d1.w),FAC2_m(a3)		; get the rounding mantissa
 6809/    2796 : 3030 1000              	MOVE.w	(a0,d1.w),d0			; get the rounding exponent
 6810/    279A : 907C 0100              	SUB.w		#$100,d0				; effectively divide the mantissa by 2
 6811/    279E : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save the rounding exponent
 6812/    27A2 : 177C 0000 059E         	MOVE.b	#$00,FAC_sc(a3)			; clear the sign compare
 6813/    27A8 : 6100 F4EC              	BSR		LAB_ADD				; round the value to n places
 6814/    27AC :                        LAB_U004
 6815/    27AC : 6100 F96A              	BSR		LAB_2970				; convert FAC1 to string - not on stack
 6816/    27B0 :                        
 6817/    27B0 : 6100 01FE              	BSR		LAB_DupFmt				; duplicate the processed format string section
 6818/    27B4 :                        								; returns length in d1, pointer in a0
 6819/    27B4 :                        
 6820/    27B4 :                        ; process the number string, length in d6, decimal point index in d2
 6821/    27B4 :                        
 6822/    27B4 : 45EB 05C6              	LEA		Decss(a3),a2			; set the number string start
 6823/    27B8 : 7C00                   	MOVEQ		#0,d6					; clear the number string index
 6824/    27BA : 782E                   	MOVEQ		#'.',d4				; set the decimal point character
 6825/    27BC :                        LAB_U005
 6826/    27BC : 3406                   	MOVE.w	d6,d2					; save the index to flag the decimal point
 6827/    27BE :                        LAB_U006
 6828/    27BE : 5246                   	ADDQ.w	#1,d6					; increment the number string index
 6829/    27C0 : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get a number string character
 6830/    27C4 : 677A                   	BEQ.s		LAB_U010				; if null then number complete
 6831/    27C6 :                        
 6832/    27C6 : B03C 0045              	CMP.b		#'E',d0				; compare the character with an "E"
 6833/    27CA : 6706                   	BEQ.s		LAB_U008				; was sx[.x]Esxx so go handle sci notation
 6834/    27CC :                        
 6835/    27CC : B004                   	CMP.b		d4,d0					; compare the character with "."
 6836/    27CE : 66EE                   	BNE.s		LAB_U006				; if not decimal point go get the next digit
 6837/    27D0 :                        
 6838/    27D0 : 60EA                   	BRA.s		LAB_U005				; go save the index and get the next digit
 6839/    27D2 :                        
 6840/    27D2 :                        ; have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
 6841/    27D2 :                        
 6842/    27D2 :                        LAB_U008
 6843/    27D2 : 3606                   	MOVE.w	d6,d3					; copy the index to the "E"
 6844/    27D4 : 5343                   	SUBQ.w	#1,d3					; -1 gives the last digit index
 6845/    27D6 :                        
 6846/    27D6 : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent sign
 6847/    27D8 : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get the exponent sign character
 6848/    27DC : B03C 002D              	CMP.b		#'-',d0				; compare the exponent sign with "-"
 6849/    27E0 : 6600 DD7E              	BNE		LAB_FCER				; if it wasn't sx[.x]E-xx go do function
 6850/    27E4 :                        								; call error
 6851/    27E4 :                        
 6852/    27E4 :                        ; found an sx[.x]E-xx number so check the exponent magnitude
 6853/    27E4 :                        
 6854/    27E4 : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent 10s
 6855/    27E6 : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get the exponent 10s character
 6856/    27EA : B03C 0030              	CMP.b		#'0',d0				; compare the exponent 10s with "0"
 6857/    27EE : 6704                   	BEQ.s		LAB_U009				; if it was sx[.x]E-0x go get the exponent
 6858/    27F0 :                        								; 1s character
 6859/    27F0 :                        
 6860/    27F0 : 700A                   	MOVEQ		#10,d0				; else start writing at index 10
 6861/    27F2 : 6008                   	BRA.s		LAB_U00A				; go copy the digits
 6862/    27F4 :                        
 6863/    27F4 :                        ; found an sx[.x]E-0x number so get the exponent magnitude
 6864/    27F4 :                        
 6865/    27F4 :                        LAB_U009
 6866/    27F4 : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent 1s
 6867/    27F6 : 700F                   	MOVEQ		#$0F,d0				; set the mask for the exponent 1s digit
 6868/    27F8 : C032 6000              	AND.b		(a2,d6.w),d0			; get and convert the exponent 1s digit
 6869/    27FC :                        LAB_U00A
 6870/    27FC : 3403                   	MOVE.w	d3,d2					; copy the number last digit index
 6871/    27FE : 0C42 0001              	CMPI.w	#1,d2					; is the number of the form sxE-0x
 6872/    2802 : 6602                   	BNE.s		LAB_U00B				; if it is sx.xE-0x skip the increment
 6873/    2804 :                        
 6874/    2804 :                        								; else make room for the decimal point
 6875/    2804 : 5242                   	ADDQ.w	#1,d2					; add 1 to the write index
 6876/    2806 :                        LAB_U00B
 6877/    2806 : D440                   	ADD.w		d0,d2					; add the exponent 1s to the write index
 6878/    2808 : 700A                   	MOVEQ		#10,d0				; set the maximum write index
 6879/    280A : 9042                   	SUB.w		d2,d0					; compare the index with the maximum
 6880/    280C : 6E0C                   	BGT.s		LAB_U00C				; if the index < the maximum continue
 6881/    280E :                        
 6882/    280E : D440                   	ADD.w		d0,d2					; else set the index to the maximum
 6883/    2810 : D640                   	ADD.w		d0,d3					; adjust the read index
 6884/    2812 : 0C43 0001              	CMPI.w	#1,d3					; compare the adjusted index with 1
 6885/    2816 : 6E02                   	BGT.s		LAB_U00C				; if > 1 continue
 6886/    2818 :                        
 6887/    2818 : 7600                   	MOVEQ		#0,d3					; else allow for the decimal point
 6888/    281A :                        LAB_U00C
 6889/    281A : 3C02                   	MOVE.w		d2,d6					; copy the write index as the number
 6890/    281C :                        								; string length
 6891/    281C : 7000                   	MOVEQ		#0,d0					; clear d0 to null terminate the number
 6892/    281E :                        								; string
 6893/    281E :                        LAB_U00D
 6894/    281E : 1580 2000              	MOVE.b	d0,(a2,d2.w)			; save the character to the number string
 6895/    2822 : 5342                   	SUBQ.w	#1,d2					; decrement the number write index
 6896/    2824 : 0C42 0001              	CMPI.w	#1,d2					; compare the number write index with 1
 6897/    2828 : 6712                   	BEQ.s		LAB_U00F				; if at the decimal point go save it
 6898/    282A :                        
 6899/    282A :                        								; else write a digit to the number string
 6900/    282A : 7030                   	MOVEQ		#'0',d0				; default to "0"
 6901/    282C : 4A43                   	TST.w		d3					; test the number read index
 6902/    282E : 67EE                   	BEQ.s		LAB_U00D				; if zero just go save the "0"
 6903/    2830 :                        
 6904/    2830 :                        LAB_U00E
 6905/    2830 : 1032 3000              	MOVE.b	(a2,d3.w),d0			; read the next number digit
 6906/    2834 : 5343                   	SUBQ.w	#1,d3					; decrement the read index
 6907/    2836 : B004                   	CMP.b		d4,d0					; compare the digit with "."
 6908/    2838 : 66E4                   	BNE.s		LAB_U00D				; if not "." go save the digit
 6909/    283A :                        
 6910/    283A : 60F4                   	BRA.s		LAB_U00E				; else go get the next digit
 6911/    283C :                        
 6912/    283C :                        LAB_U00F
 6913/    283C : 1584 2000              	MOVE.b	d4,(a2,d2.w)			; save the decimal point
 6914/    2840 :                        LAB_U010
 6915/    2840 : 4A42                   	TST.w		d2					; test the number string decimal point index
 6916/    2842 : 6602                   	BNE.s		LAB_U014				; if dp present skip the reset
 6917/    2844 :                        
 6918/    2844 : 3406                   	MOVE.w	d6,d2					; make the decimal point index = the length
 6919/    2846 :                        
 6920/    2846 :                        ; copy the fractional digit characters from the number string
 6921/    2846 :                        
 6922/    2846 :                        LAB_U014
 6923/    2846 : 3602                   	MOVE.w	d2,d3					; copy the number string decimal point index
 6924/    2848 : 5243                   	ADDQ.w	#1,d3					; increment the number string index
 6925/    284A : 382F 0008              	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
 6926/    284E :                        LAB_U018
 6927/    284E : 5244                   	ADDQ.w	#1,d4					; increment the new format string index
 6928/    2850 : B244                   	CMP.w		d4,d1					; compare it with the new format string length
 6929/    2852 : 6322                   	BLS.s		LAB_U022				; if done the fraction digits go do integer
 6930/    2854 :                        
 6931/    2854 : 1030 4000              	MOVE.b	(a0,d4.w),d0			; get a new format string character
 6932/    2858 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 6933/    285C : 6706                   	BEQ.s		LAB_U01C				; if "%" go copy a number character
 6934/    285E :                        
 6935/    285E : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 6936/    2862 : 66EA                   	BNE.s		LAB_U018				; if not "#" go do the next new format character
 6937/    2864 :                        
 6938/    2864 :                        LAB_U01C
 6939/    2864 : 7030                   	MOVEQ		#'0',d0				; default to "0" character
 6940/    2866 : BC43                   	CMP.w		d3,d6					; compare the number string index with length
 6941/    2868 : 6306                   	BLS.s		LAB_U020				; if there skip the character get
 6942/    286A :                        
 6943/    286A : 1032 3000              	MOVE.b	(a2,d3.w),d0			; get a character from the number string
 6944/    286E : 5243                   	ADDQ.w	#1,d3					; increment the number string index
 6945/    2870 :                        LAB_U020
 6946/    2870 : 1180 4000              	MOVE.b	d0,(a0,d4.w)			; save the number character to the new format
 6947/    2874 :                        								; string
 6948/    2874 : 60D8                   	BRA.s		LAB_U018				; go do the next new format character
 6949/    2876 :                        
 6950/    2876 :                        ; now copy the integer digit characters from the number string
 6951/    2876 :                        
 6952/    2876 :                        LAB_U022
 6953/    2876 : 7C00                   	MOVEQ		#0,d6					; clear the sign done flag
 6954/    2878 : 7A00                   	MOVEQ		#0,d5					; clear the sign present flag
 6955/    287A : 5342                   	SUBQ.w	#1,d2					; decrement the number string index
 6956/    287C : 6608                   	BNE.s		LAB_U026				; if not now at sign continue
 6957/    287E :                        
 6958/    287E : 7401                   	MOVEQ		#1,d2					; increment the number string index
 6959/    2880 : 15BC 0030 2000         	MOVE.b	#'0',(a2,d2.w)			; replace the point with a zero
 6960/    2886 :                        LAB_U026
 6961/    2886 : 382F 0008              	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
 6962/    288A : B244                   	CMP.w		d4,d1					; compare it with the new format string length
 6963/    288C : 6402                   	BCC.s		LAB_U02A				; if within the string go use the index
 6964/    288E :                        
 6965/    288E : 3801                   	MOVE.w	d1,d4					; else set the index to the end of the string
 6966/    2890 :                        LAB_U02A
 6967/    2890 : 5344                   	SUBQ.w	#1,d4					; decrement the new format string index
 6968/    2892 : 6B62                   	BMI.s		LAB_U03E				; if all done go test for any overflow
 6969/    2894 :                        
 6970/    2894 : 1030 4000              	MOVE.b	(a0,d4.w),d0			; else get a new format string character
 6971/    2898 :                        
 6972/    2898 : 7E30                   	MOVEQ		#'0',d7				; default to "0" character
 6973/    289A : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 6974/    289E : 6708                   	BEQ.s		LAB_U02B				; if "%" go copy a number character
 6975/    28A0 :                        
 6976/    28A0 : 7E20                   	MOVEQ		#' ',d7				; default to " " character
 6977/    28A2 : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 6978/    28A6 : 6606                   	BNE.s		LAB_U02C				; if not "#" go try ","
 6979/    28A8 :                        
 6980/    28A8 :                        LAB_U02B
 6981/    28A8 : 4A42                   	TST.w		d2					; test the number string index
 6982/    28AA : 6634                   	BNE.s		LAB_U036				; if not at the sign go get a number character
 6983/    28AC :                        
 6984/    28AC : 6042                   	BRA.s		LAB_U03C				; else go save the default character
 6985/    28AE :                        
 6986/    28AE :                        LAB_U02C
 6987/    28AE : B03C 002C              	CMP.b		#',',d0				; compare it with ","
 6988/    28B2 : 6610                   	BNE.s		LAB_U030				; if not "," go try the sign characters
 6989/    28B4 :                        
 6990/    28B4 : 4A42                   	TST.w		d2					; test the number string index
 6991/    28B6 : 6608                   	BNE.s		LAB_U02E				; if not at the sign keep the ","
 6992/    28B8 :                        
 6993/    28B8 : 0C30 0025 40FF         	CMP.b		#'%',-1(a0,d4.w)			; else compare the next format string character
 6994/    28BE :                        								; with "%"
 6995/    28BE : 6630                   	BNE.s		LAB_U03C				; if not "%" keep the default character
 6996/    28C0 :                        
 6997/    28C0 :                        LAB_U02E
 6998/    28C0 : 1E00                   	MOVE.b	d0,d7					; else use the "," character
 6999/    28C2 : 602C                   	BRA.s		LAB_U03C				; go save the character to the string
 7000/    28C4 :                        
 7001/    28C4 :                        LAB_U030
 7002/    28C4 : B03C 002D              	CMP.b		#'-',d0				; compare it with "-"
 7003/    28C8 : 6710                   	BEQ.s		LAB_U034				; if "-" go do the sign character
 7004/    28CA :                        
 7005/    28CA : B03C 002B              	CMP.b		#'+',d0				; compare it with "+"
 7006/    28CE : 66C0                   	BNE.s		LAB_U02A				; if not "+" go do the next new format character
 7007/    28D0 :                        
 7008/    28D0 : 0C12 002D              	CMP.b		#'-',(a2)				; compare the sign character with "-"
 7009/    28D4 : 6704                   	BEQ.s		LAB_U034				; if "-" don't change the sign character
 7010/    28D6 :                        
 7011/    28D6 : 14BC 002B              	MOVE.b	#'+',(a2)				; else make the sign character "+"
 7012/    28DA :                        LAB_U034
 7013/    28DA : 1A00                   	MOVE.b	d0,d5					; set the sign present flag
 7014/    28DC : 4A42                   	TST.w		d2					; test the number string index
 7015/    28DE : 6708                   	BEQ.s		LAB_U038				; if at the sign keep the default character
 7016/    28E0 :                        
 7017/    28E0 :                        LAB_U036
 7018/    28E0 : 1E32 2000              	MOVE.b	(a2,d2.w),d7			; else get a character from the number string
 7019/    28E4 : 5342                   	SUBQ.w	#1,d2					; decrement the number string index
 7020/    28E6 : 6008                   	BRA.s		LAB_U03C				; go save the character
 7021/    28E8 :                        
 7022/    28E8 :                        LAB_U038
 7023/    28E8 : 4A06                   	TST.b		d6					; test the sign done flag
 7024/    28EA : 6604                   	BNE.s		LAB_U03C				; if the sign has been done go use the space
 7025/    28EC :                        								; character
 7026/    28EC :                        
 7027/    28EC : 1E12                   	MOVE.b	(a2),d7				; else get the sign character
 7028/    28EE : 1C07                   	MOVE.b	d7,d6					; flag that the sign has been done
 7029/    28F0 :                        LAB_U03C
 7030/    28F0 : 1187 4000              	MOVE.b	d7,(a0,d4.w)			; save the number character to the new format
 7031/    28F4 :                        								; string
 7032/    28F4 : 609A                   	BRA.s		LAB_U02A				; go do the next new format character
 7033/    28F6 :                        
 7034/    28F6 :                        ; test for overflow conditions
 7035/    28F6 :                        
 7036/    28F6 :                        LAB_U03E
 7037/    28F6 : 4A42                   	TST.w		d2					; test the number string index
 7038/    28F8 : 6614                   	BNE.s		LAB_U040				; if all the digits aren't done go output
 7039/    28FA :                        								; an overflow indication
 7040/    28FA :                        
 7041/    28FA :                        ; test for sign overflows
 7042/    28FA :                        
 7043/    28FA : 4A05                   	TST.b		d5					; test the sign present flag
 7044/    28FC : 6754                   	BEQ.s		LAB_U04A				; if no sign present go add the string
 7045/    28FE :                        
 7046/    28FE :                        ; there was a sign in the format string
 7047/    28FE :                        
 7048/    28FE : 4A06                   	TST.b		d6					; test the sign done flag
 7049/    2900 : 6650                   	BNE.s		LAB_U04A				; if the sign is done go add the string
 7050/    2902 :                        
 7051/    2902 :                        ; the sign isn't done so see if it was mandatory
 7052/    2902 :                        
 7053/    2902 : 0C05 002B              	CMPI.b	#'+',d5				; compare the sign with "+"
 7054/    2906 : 6706                   	BEQ.s		LAB_U040				; if it was "+" go output an overflow
 7055/    2908 :                        								; indication
 7056/    2908 :                        
 7057/    2908 :                        ; the sign wasn't mandatory but the number may have been negative
 7058/    2908 :                        
 7059/    2908 : 0C12 002D              	CMP.b		#'-',(a2)				; compare the sign character with "-"
 7060/    290C : 6644                   	BNE.s		LAB_U04A				; if it wasn't "-" go add the string
 7061/    290E :                        
 7062/    290E :                        ; else the sign was "-" and a sign hasn't been output so ..
 7063/    290E :                        
 7064/    290E :                        ; the number overflowed the format string so replace all the special format characters
 7065/    290E :                        ; with the overflow character
 7066/    290E :                        
 7067/    290E :                        LAB_U040
 7068/    290E : 7A23                   	MOVEQ		#ofchr,d5				; set the overflow character
 7069/    2910 : 3E01                   	MOVE.w	d1,d7					; copy the new format string length
 7070/    2912 : 5347                   	SUBQ.w	#1,d7					; adjust for the loop type
 7071/    2914 : 3C2F 0004              	MOVE.w	fsti(sp),d6				; copy the new format string last index
 7072/    2918 : 5346                   	SUBQ.w	#1,d6					; -1 gives the last character of this string
 7073/    291A : 6E02                   	BGT.s		LAB_U044				; if not zero continue
 7074/    291C :                        
 7075/    291C : 3C07                   	MOVE.w	d7,d6					; else set the format string index to the end
 7076/    291E :                        LAB_U044
 7077/    291E : 1031 6000              	MOVE.b	(a1,d6.w),d0			; get a character from the format string
 7078/    2922 : 0C00 0023              	CMPI.b	#'#',d0				; compare it with "#" special format character
 7079/    2926 : 671E                   	BEQ.s		LAB_U046				; if "#" go use the overflow character
 7080/    2928 :                        
 7081/    2928 : 0C00 0025              	CMPI.b	#'%',d0				; compare it with "%" special format character
 7082/    292C : 6718                   	BEQ.s		LAB_U046				; if "%" go use the overflow character
 7083/    292E :                        
 7084/    292E : 0C00 002C              	CMPI.b	#',',d0				; compare it with "," special format character
 7085/    2932 : 6712                   	BEQ.s		LAB_U046				; if "," go use the overflow character
 7086/    2934 :                        
 7087/    2934 : 0C00 002B              	CMPI.b	#'+',d0				; compare it with "+" special format character
 7088/    2938 : 670C                   	BEQ.s		LAB_U046				; if "+" go use the overflow character
 7089/    293A :                        
 7090/    293A : 0C00 002D              	CMPI.b	#'-',d0				; compare it with "-" special format character
 7091/    293E : 6706                   	BEQ.s		LAB_U046				; if "-" go use the overflow character
 7092/    2940 :                        
 7093/    2940 : 0C00 002E              	CMPI.b	#'.',d0				; compare it with "." special format character
 7094/    2944 : 6602                   	BNE.s		LAB_U048				; if not "." skip the using overflow character
 7095/    2946 :                        
 7096/    2946 :                        LAB_U046
 7097/    2946 : 1005                   	MOVE.b	d5,d0					; use the overflow character
 7098/    2948 :                        LAB_U048
 7099/    2948 : 1180 7000              	MOVE.b	d0,(a0,d7.w)			; save the character to the new format string
 7100/    294C : 5346                   	SUBQ.w	#1,d6					; decrement the format string index
 7101/    294E : 51CF FFCE              	DBF		d7,LAB_U044				; decrement the count and loop if not all done
 7102/    2952 :                        
 7103/    2952 :                        ; add the new string to the previous string
 7104/    2952 :                        
 7105/    2952 :                        LAB_U04A
 7106/    2952 : 41EC 0006              	LEA		6(a4),a0				; get the descriptor pointer for string 1
 7107/    2956 : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
 7108/    295A : 6100 F004              	BSR		LAB_224E				; concatenate the strings
 7109/    295E :                        
 7110/    295E :                        ; now check for any tail on the format string
 7111/    295E :                        
 7112/    295E : 302F 0004              	MOVE.w	fsti(sp),d0				; get this index
 7113/    2962 : 6720                   	BEQ.s		LAB_U04C				; if at start of string skip the output
 7114/    2964 :                        
 7115/    2964 : 3F40 0006              	MOVE.w	d0,fsli(sp)				; save this index to the last index
 7116/    2968 : 6100 0084              	BSR		LAB_ProcFo				; now process the format string
 7117/    296C : 4A02                   	TST.b		d2					; test the special characters flag
 7118/    296E : 6614                   	BNE.s		LAB_U04C				; if special characters present skip the output
 7119/    2970 :                        
 7120/    2970 :                        ; else output the new string part
 7121/    2970 :                        
 7122/    2970 : 613E                   	BSR.s		LAB_DupFmt				; duplicate the processed format string section
 7123/    2972 : 3F6F 0004 0006         	MOVE.w	fsti(sp),fsli(sp)			; copy this index to the last index
 7124/    2978 :                        
 7125/    2978 :                        ; add the new string to the previous string
 7126/    2978 :                        
 7127/    2978 : 41EC 0006              	LEA		6(a4),a0				; get the descriptor pointer for string 1
 7128/    297C : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
 7129/    2980 : 6100 EFDE              	BSR		LAB_224E				; concatenate the strings
 7130/    2984 :                        
 7131/    2984 :                        ; check for another value or end of function
 7132/    2984 :                        
 7133/    2984 :                        LAB_U04C
 7134/    2984 : 101D                   	MOVE.b	(a5)+,d0				; get the next BASIC byte
 7135/    2986 : B03C 0029              	CMP.b		#')',d0				; compare with close bracket
 7136/    298A : 6600 FDCA              	BNE		LAB_U002				; if not ")" go do next value
 7137/    298E :                        
 7138/    298E :                        ; pop the result string off the descriptor stack
 7139/    298E :                        
 7140/    298E : 204C                   	MOVEA.l	a4,a0					; copy the result string descriptor pointer
 7141/    2990 : 222B 0446              	MOVE.l	Sstorl(a3),d1			; save the bottom of string space
 7142/    2994 : 6100 F02C              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 7143/    2998 :                        								; d0 = length, a0 = pointer
 7144/    2998 : 2741 0446              	MOVE.l	d1,Sstorl(a3)			; restore the bottom of string space
 7145/    299C : 2248                   	MOVEA.l	a0,a1					; copy the string result pointer
 7146/    299E : 3200                   	MOVE.w	d0,d1					; copy the string result length
 7147/    29A0 :                        
 7148/    29A0 :                        ; pop the format string off the descriptor stack
 7149/    29A0 :                        
 7150/    29A0 : 205F                   	MOVEA.l	(sp)+,a0				; pull the format string descriptor pointer
 7151/    29A2 : 6100 F01E              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 7152/    29A6 :                        								; d0 = length, a0 = pointer
 7153/    29A6 :                        
 7154/    29A6 : 4FEF 0008              	LEA		fend(sp),sp				; dump the saved values
 7155/    29AA :                        
 7156/    29AA :                        ; push the result string back on the descriptor stack and return
 7157/    29AA :                        
 7158/    29AA : 2049                   	MOVEA.l	a1,a0					; copy the result string pointer back
 7159/    29AC : 6000 EE62              	BRA		LAB_RTST				; push a string on the descriptor stack and
 7160/    29B0 :                        								; return. a0 = pointer, d1 = length
 7161/    29B0 :                        
 7162/    29B0 :                        
 7163/    29B0 :                        ;************************************************************************************
 7164/    29B0 :                        ;
 7165/    29B0 :                        ; duplicate the processed format string section
 7166/    29B0 :                        
 7167/    29B0 :                        								; make a string as long as the format string
 7168/    29B0 :                        LAB_DupFmt
 7169/    29B0 : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 7170/    29B4 : 3E29 0004              	MOVE.w	4(a1),d7				; get the format string length
 7171/    29B8 : 342F 000A              	MOVE.w	4+fsli(sp),d2			; get the format string last index
 7172/    29BC : 3C2F 0008              	MOVE.w	4+fsti(sp),d6			; get the format string this index
 7173/    29C0 : 3206                   	MOVE.w	d6,d1					; copy the format string this index
 7174/    29C2 : 9242                   	SUB.w		d2,d1					; subtract the format string last index
 7175/    29C4 : 6202                   	BHI.s		LAB_D002				; if > 0 skip the correction
 7176/    29C6 :                        
 7177/    29C6 : D247                   	ADD.w		d7,d1					; else add the format string length as the
 7178/    29C8 :                        								; correction
 7179/    29C8 :                        LAB_D002
 7180/    29C8 : 6100 EE60              	BSR		LAB_2115				; make string space d1 bytes long
 7181/    29CC :                        								; return a0/Sutill = pointer, others unchanged
 7182/    29CC :                        
 7183/    29CC :                        ; push the new string on the descriptor stack
 7184/    29CC :                        
 7185/    29CC : 6100 EE42              	BSR		LAB_RTST				; push a string on the descriptor stack and
 7186/    29D0 :                        								; return. a0 = pointer, d1 = length
 7187/    29D0 :                        
 7188/    29D0 :                        ; copy the characters from the format string
 7189/    29D0 :                        
 7190/    29D0 : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 7191/    29D4 : 2251                   	MOVEA.l	(a1),a1				; get the format string pointer
 7192/    29D6 : 7800                   	MOVEQ		#0,d4					; clear the new string index
 7193/    29D8 :                        LAB_D00A
 7194/    29D8 : 11B1 2000 4000         	MOVE.b	(a1,d2.w),(a0,d4.w)		; get a character from the format string and
 7195/    29DE :                        								; save it to the new string
 7196/    29DE : 5244                   	ADDQ.w	#1,d4					; increment the new string index
 7197/    29E0 : 5242                   	ADDQ.w	#1,d2					; increment the format string index
 7198/    29E2 : BE42                   	CMP.w		d2,d7					; compare the format index with the length
 7199/    29E4 : 6602                   	BNE.s		LAB_D00E				; if not there skip the reset
 7200/    29E6 :                        
 7201/    29E6 : 7400                   	MOVEQ		#0,d2					; else reset the format string index
 7202/    29E8 :                        LAB_D00E
 7203/    29E8 : BC42                   	CMP.w		d2,d6					; compare the index with this index
 7204/    29EA : 66EC                   	BNE.s		LAB_D00A				; if not equal go do the next character
 7205/    29EC :                        
 7206/    29EC : 4E75                   	RTS
 7207/    29EE :                        
 7208/    29EE :                        
 7209/    29EE :                        ;************************************************************************************
 7210/    29EE :                        ;
 7211/    29EE :                        ; process the format string
 7212/    29EE :                        
 7213/    29EE :                        LAB_ProcFo
 7214/    29EE : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 7215/    29F2 : 3E29 0004              	MOVE.w	4(a1),d7				; get the format string length
 7216/    29F6 : 2251                   	MOVEA.l	(a1),a1				; get the format string pointer
 7217/    29F8 : 3C2F 000A              	MOVE.w	4+fsli(sp),d6			; get the format string last index
 7218/    29FC :                        
 7219/    29FC : 3F47 000C              	MOVE.w	d7,4+fsdpi(sp)			; set the format string decimal point index
 7220/    2A00 :                        ;##	MOVE.w	#-1,4+fsdpi(sp)			; set the format string decimal point index
 7221/    2A00 : 7A00                   	MOVEQ		#0,d5					; no decimal point
 7222/    2A02 : 7600                   	MOVEQ		#0,d3					; no decimal characters
 7223/    2A04 : 7400                   	MOVEQ		#0,d2					; no special characters
 7224/    2A06 :                        LAB_P004
 7225/    2A06 : 1031 6000              	MOVE.b	(a1,d6.w),d0			; get a format string byte
 7226/    2A0A :                        
 7227/    2A0A : B03C 002C              	CMP.b		#',',d0				; compare it with ","
 7228/    2A0E : 6742                   	BEQ.s		LAB_P01A				; if "," go do the next format string byte
 7229/    2A10 :                        
 7230/    2A10 : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 7231/    2A14 : 6706                   	BEQ.s		LAB_P008				; if "#" go flag special characters
 7232/    2A16 :                        
 7233/    2A16 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 7234/    2A1A : 6608                   	BNE.s		LAB_P00C				; if not "%" go try "+"
 7235/    2A1C :                        
 7236/    2A1C :                        LAB_P008
 7237/    2A1C : 4A85                   	TST.l		d5					; test the decimal point flag
 7238/    2A1E : 6A10                   	BPL.s		LAB_P00E				; if no point skip counting decimal characters
 7239/    2A20 :                        
 7240/    2A20 : 5243                   	ADDQ.w	#1,d3					; else increment the decimal character count
 7241/    2A22 : 602E                   	BRA.s		LAB_P01A				; go do the next character
 7242/    2A24 :                        
 7243/    2A24 :                        LAB_P00C
 7244/    2A24 : B03C 002B              	CMP.b		#'+',d0				; compare it with "+"
 7245/    2A28 : 6706                   	BEQ.s		LAB_P00E				; if "+" go flag special characters
 7246/    2A2A :                        
 7247/    2A2A : B03C 002D              	CMP.b		#'-',d0				; compare it with "-"
 7248/    2A2E : 6604                   	BNE.s		LAB_P010				; if not "-" go check decimal point
 7249/    2A30 :                        
 7250/    2A30 :                        LAB_P00E
 7251/    2A30 : 8400                   	OR.b		d0,d2					; flag special characters
 7252/    2A32 : 601E                   	BRA.s		LAB_P01A				; go do the next character
 7253/    2A34 :                        
 7254/    2A34 :                        LAB_P010
 7255/    2A34 : B03C 002E              	CMP.b		#'.',d0				; compare it with "."
 7256/    2A38 : 6614                   	BNE.s		LAB_P018				; if not "." go check next
 7257/    2A3A :                        
 7258/    2A3A :                        ; "." a decimal point
 7259/    2A3A :                        
 7260/    2A3A : 4A85                   	TST.l		d5					; if there is already a decimal point
 7261/    2A3C : 6B14                   	BMI.s		LAB_P01A				; go do the next character
 7262/    2A3E :                        
 7263/    2A3E : 3006                   	MOVE.w	d6,d0					; copy the decimal point index
 7264/    2A40 : 906F 000A              	SUB.w		4+fsli(sp),d0			; calculate it from the scan start
 7265/    2A44 : 3F40 000C              	MOVE.w	d0,4+fsdpi(sp)			; save the decimal point index
 7266/    2A48 : 7AFF                   	MOVEQ		#-1,d5				; flag decimal point
 7267/    2A4A : 8400                   	OR.b		d0,d2					; flag special characters
 7268/    2A4C : 6004                   	BRA.s		LAB_P01A				; go do the next character
 7269/    2A4E :                        
 7270/    2A4E :                        ; was not a special character
 7271/    2A4E :                        
 7272/    2A4E :                        LAB_P018
 7273/    2A4E : 4A02                   	TST.b		d2					; test if there have been special characters
 7274/    2A50 : 6608                   	BNE.s		LAB_P01E				; if so exit the format string process
 7275/    2A52 :                        
 7276/    2A52 :                        LAB_P01A
 7277/    2A52 : 5246                   	ADDQ.w	#1,d6					; increment the format string index
 7278/    2A54 : BE46                   	CMP.w		d6,d7					; compare it with the format string length
 7279/    2A56 : 62AE                   	BHI.s		LAB_P004				; if length > index go get the next character
 7280/    2A58 :                        
 7281/    2A58 : 7C00                   	MOVEQ		#0,d6					; length = index so reset the format string
 7282/    2A5A :                        								; index
 7283/    2A5A :                        LAB_P01E
 7284/    2A5A : 3F46 0008              	MOVE.w	d6,4+fsti(sp)			; save the format string this index
 7285/    2A5E : 3F43 000E              	MOVE.w	d3,4+fsdc(sp)			; save the format string decimal characters
 7286/    2A62 :                        
 7287/    2A62 : 4E75                   	RTS
 7288/    2A64 :                        
 7289/    2A64 :                        
 7290/    2A64 :                        ;************************************************************************************
 7291/    2A64 :                        ;
 7292/    2A64 :                        ; perform BIN$()
 7293/    2A64 :                        ; # of leading 0s is in d1, the number is in d0
 7294/    2A64 :                        
 7295/    2A64 :                        LAB_BINS
 7296/    2A64 : B23C 0021              	CMP.b		#$21,d1				; max + 1
 7297/    2A68 : 6400 DAF6              	BCC		LAB_FCER				; exit if too big ( > or = )
 7298/    2A6C :                        
 7299/    2A6C : 741F                   	MOVEQ		#$1F,d2				; bit count-1
 7300/    2A6E : 41EB 05B6              	LEA		Binss(a3),a0			; point to string
 7301/    2A72 : 7830                   	MOVEQ		#$30,d4				; "0" character for ADDX
 7302/    2A74 :                        NextB1
 7303/    2A74 : 7600                   	MOVEQ		#0,d3					; clear byte
 7304/    2A76 : E288                   	LSR.l		#1,d0					; shift bit into Xb
 7305/    2A78 : D704                   	ADDX.b	d4,d3					; add carry and character to zero
 7306/    2A7A : 1183 2000              	MOVE.b	d3,(a0,d2.w)			; save character to string
 7307/    2A7E : 51CA FFF4              	DBF		d2,NextB1				; decrement and loop if not done
 7308/    2A82 :                        
 7309/    2A82 :                        ; this is the exit code and is also used by HEX$()
 7310/    2A82 :                        
 7311/    2A82 :                        EndBHS
 7312/    2A82 : 177C 0000 05D6         	MOVE.b	#0,BHsend(a3)			; null terminate the string
 7313/    2A88 : 4A01                   	TST.b		d1					; test # of characters
 7314/    2A8A : 670E                   	BEQ.s		NextB2				; go truncate string
 7315/    2A8C :                        
 7316/    2A8C : 4481                   	NEG.l		d1					; make -ve
 7317/    2A8E : D2BC 0000 05D6         	ADD.l		#BHsend,d1				; effectively (end-length)
 7318/    2A94 : 41F3 1000              	LEA		0(a3,d1.w),a0			; effectively add (end-length) to pointer
 7319/    2A98 : 600E                   	BRA.s		BinPr					; go print string
 7320/    2A9A :                        
 7321/    2A9A :                        ; truncate string to remove leading "0"s
 7322/    2A9A :                        
 7323/    2A9A :                        NextB2
 7324/    2A9A : 1010                   	MOVE.b	(a0),d0				; get byte
 7325/    2A9C : 670A                   	BEQ.s		BinPr					; if null then end of string so add 1 and go
 7326/    2A9E :                        								; print it
 7327/    2A9E :                        
 7328/    2A9E : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 7329/    2AA2 : 660E                   	BNE.s		GoPr					; if not "0" then go print string from here
 7330/    2AA4 :                        
 7331/    2AA4 : 5248                   	ADDQ.w	#1,a0					; else increment pointer
 7332/    2AA6 : 60F2                   	BRA.s		NextB2				; loop always
 7333/    2AA8 :                        
 7334/    2AA8 :                        ; make fixed length output string - ignore overflows!
 7335/    2AA8 :                        
 7336/    2AA8 :                        BinPr
 7337/    2AA8 : 43EB 05D6              	LEA		BHsend(a3),a1			; get string end
 7338/    2AAC : B1C9                   	CMPA.l	a1,a0					; are we at the string end
 7339/    2AAE : 6602                   	BNE.s		GoPr					; branch if not
 7340/    2AB0 :                        
 7341/    2AB0 : 5348                   	SUBQ.w	#1,a0					; else need at least one zero
 7342/    2AB2 :                        GoPr
 7343/    2AB2 : 6000 ED16              	BRA		LAB_20AE				; print " terminated string to FAC1, stack & RET
 7344/    2AB6 :                        
 7345/    2AB6 :                        
 7346/    2AB6 :                        ;************************************************************************************
 7347/    2AB6 :                        ;
 7348/    2AB6 :                        ; perform HEX$()
 7349/    2AB6 :                        ; # of leading 0s is in d1, the number is in d0
 7350/    2AB6 :                        
 7351/    2AB6 :                        LAB_HEXS
 7352/    2AB6 : B23C 0009              	CMP.b		#$09,d1				; max + 1
 7353/    2ABA : 6400 DAA4              	BCC		LAB_FCER				; exit if too big ( > or = )
 7354/    2ABE :                        
 7355/    2ABE : 7407                   	MOVEQ		#$07,d2				; nibble count-1
 7356/    2AC0 : 41EB 05CE              	LEA		Hexss(a3),a0			; point to string
 7357/    2AC4 : 7830                   	MOVEQ		#$30,d4				; "0" character for ABCD
 7358/    2AC6 :                        NextH1
 7359/    2AC6 : 1600                   	MOVE.b	d0,d3					; copy lowest byte
 7360/    2AC8 : E898                   	ROR.l		#4,d0					; shift nibble into 0-3
 7361/    2ACA : C63C 000F              	AND.b		#$0F,d3				; just this nibble
 7362/    2ACE : 1A03                   	MOVE.b	d3,d5					; copy it
 7363/    2AD0 : DA3C 00F6              	ADD.b		#$F6,d5				; set extend bit
 7364/    2AD4 : C704                   	ABCD		d4,d3					; decimal add extend and character to zero
 7365/    2AD6 : 1183 2000              	MOVE.b	d3,(a0,d2.w)			; save character to string
 7366/    2ADA : 51CA FFEA              	DBF		d2,NextH1				; decrement and loop if not done
 7367/    2ADE :                        
 7368/    2ADE : 60A2                   	BRA.s		EndBHS				; go process string
 7369/    2AE0 :                        
 7370/    2AE0 :                        
 7371/    2AE0 :                        ;************************************************************************************
 7372/    2AE0 :                        ;
 7373/    2AE0 :                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
 7374/    2AE0 :                        
 7375/    2AE0 :                        VEC_CC
 7376/    2AE0 : 4A2B 05E8              	TST.b		ccflag(a3)				; check [CTRL-C] check flag
 7377/    2AE4 : 661E                   	BNE.s		RTS_022				; exit if [CTRL-C] check inhibited
 7378/    2AE6 :                        
 7379/    2AE6 : 4EAB 040C              	JSR		V_INPT(a3)				; scan input device
 7380/    2AEA : 640E                   	BCC.s		LAB_FBA0				; exit if buffer empty
 7381/    2AEC :                        
 7382/    2AEC : 1740 05E9              	MOVE.b	d0,ccbyte(a3)			; save received byte
 7383/    2AF0 : 177C 0020 05EA         	MOVE.b	#$20,ccnull(a3)			; set "life" timer for bytes countdown
 7384/    2AF6 : 6000 DEDE              	BRA		LAB_1636				; return to BASIC
 7385/    2AFA :                        
 7386/    2AFA :                        LAB_FBA0
 7387/    2AFA : 4A2B 05EA              	TST.b		ccnull(a3)				; get countdown byte
 7388/    2AFE : 6704                   	BEQ.s		RTS_022				; exit if finished
 7389/    2B00 :                        
 7390/    2B00 : 532B 05EA              	SUBQ.b	#1,ccnull(a3)			; else decrement countdown
 7391/    2B04 :                        RTS_022
 7392/    2B04 : 4E75                   	RTS
 7393/    2B06 :                        
 7394/    2B06 :                        
 7395/    2B06 :                        ;************************************************************************************
 7396/    2B06 :                        ;
 7397/    2B06 :                        ; get byte from input device, no waiting
 7398/    2B06 :                        ; returns with carry set if byte in A
 7399/    2B06 :                        
 7400/    2B06 :                        INGET
 7401/    2B06 : 4EAB 040C              	JSR		V_INPT(a3)				; call scan input device
 7402/    2B0A : 650A                   	BCS.s		LAB_FB95				; if byte go reset timer
 7403/    2B0C :                        
 7404/    2B0C : 102B 05EA              	MOVE.b	ccnull(a3),d0			; get countdown
 7405/    2B10 : 67F2                   	BEQ.s		RTS_022				; exit if empty
 7406/    2B12 :                        
 7407/    2B12 : 102B 05E9              	MOVE.b	ccbyte(a3),d0			; get last received byte
 7408/    2B16 :                        LAB_FB95
 7409/    2B16 : 177C 0000 05EA         	MOVE.b	#$00,ccnull(a3)			; clear timer because we got a byte
 7410/    2B1C : 003C 0001              	ORI.b		#1,CCR				; set carry, flag we got a byte
 7411/    2B20 : 4E75                   	RTS
 7412/    2B22 :                        
 7413/    2B22 :                        
 7414/    2B22 :                        ;************************************************************************************
 7415/    2B22 :                        ;
 7416/    2B22 :                        ; perform MAX()
 7417/    2B22 :                        
 7418/    2B22 :                        LAB_MAX
 7419/    2B22 : 6100 E530              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7420/    2B26 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7421/    2B2A : 6B00 DA14              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7422/    2B2E :                        
 7423/    2B2E :                        LAB_MAXN
 7424/    2B2E : 612E                   	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
 7425/    2B30 :                        								; pull FAC2 & compare with FAC1
 7426/    2B30 : 64FC                   	BCC.s		LAB_MAXN				; branch if no swap to do
 7427/    2B32 :                        
 7428/    2B32 : 6100 F4A0              	BSR		LAB_279B				; copy FAC2 to FAC1
 7429/    2B36 : 60F6                   	BRA.s		LAB_MAXN				; go do next
 7430/    2B38 :                        
 7431/    2B38 :                        
 7432/    2B38 :                        ;************************************************************************************
 7433/    2B38 :                        ;
 7434/    2B38 :                        ; perform MIN()
 7435/    2B38 :                        
 7436/    2B38 :                        LAB_MIN
 7437/    2B38 : 6100 E51A              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7438/    2B3C : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7439/    2B40 : 6B00 D9FE              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7440/    2B44 :                        
 7441/    2B44 :                        LAB_MINN
 7442/    2B44 : 6118                   	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
 7443/    2B46 :                        								; pull FAC2 & compare with FAC1
 7444/    2B46 : 63FC                   	BLS.s		LAB_MINN				; branch if no swap to do
 7445/    2B48 :                        
 7446/    2B48 : 6100 F48A              	BSR		LAB_279B				; copy FAC2 to FAC1
 7447/    2B4C : 60F6                   	BRA.s		LAB_MINN				; go do next (branch always)
 7448/    2B4E :                        
 7449/    2B4E :                        ; exit routine. don't bother returning to the loop code
 7450/    2B4E :                        ; check for correct exit, else so syntax error
 7451/    2B4E :                        
 7452/    2B4E :                        LAB_MMEC
 7453/    2B4E : B03C 0029              	CMP.b		#')',d0				; is it end of function?
 7454/    2B52 : 6600 DA18              	BNE		LAB_SNER				; if not do MAX MIN syntax error
 7455/    2B56 :                        
 7456/    2B56 : 4FEF 0004              	LEA		4(sp),sp				; dump return address (faster)
 7457/    2B5A : 6000 E656              	BRA		LAB_IGBY				; update BASIC execute pointer (to chr past ")")
 7458/    2B5E :                        								; and return
 7459/    2B5E :                        
 7460/    2B5E :                        ; check for next, evaluate & return or exit
 7461/    2B5E :                        ; this is the routine that does most of the work
 7462/    2B5E :                        
 7463/    2B5E :                        LAB_PHFA
 7464/    2B5E : 6100 E654              	BSR		LAB_GBYT				; get next BASIC byte
 7465/    2B62 : B03C 002C              	CMP.b		#',',d0				; is there more ?
 7466/    2B66 : 66E6                   	BNE.s		LAB_MMEC				; if not go do end check
 7467/    2B68 :                        
 7468/    2B68 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push exponent and sign
 7469/    2B6C : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push mantissa
 7470/    2B70 :                        
 7471/    2B70 : 6100 E4E2              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7472/    2B74 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7473/    2B78 : 6B00 D9C6              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7474/    2B7C :                        
 7475/    2B7C :                        
 7476/    2B7C :                        								; pop FAC2 (MAX/MIN expression so far)
 7477/    2B7C : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
 7478/    2B80 :                        
 7479/    2B80 : 301F                   	MOVE.w	(sp)+,d0				; pop exponent and sign
 7480/    2B82 : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save exponent and sign
 7481/    2B86 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; get FAC1 sign
 7482/    2B8C : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 7483/    2B90 : 6000 F4AE              	BRA		LAB_27FA				; compare FAC1 with FAC2 & return
 7484/    2B94 :                        								; returns d0=+1 Cb=0 if FAC1 > FAC2
 7485/    2B94 :                        								; returns d0= 0 Cb=0 if FAC1 = FAC2
 7486/    2B94 :                        								; returns d0=-1 Cb=1 if FAC1 < FAC2
 7487/    2B94 :                        
 7488/    2B94 :                        
 7489/    2B94 :                        ;************************************************************************************
 7490/    2B94 :                        ;
 7491/    2B94 :                        ; perform WIDTH
 7492/    2B94 :                        
 7493/    2B94 :                        LAB_WDTH
 7494/    2B94 : B03C 002C              	CMP.b		#',',d0				; is next byte ","
 7495/    2B98 : 672C                   	BEQ.s		LAB_TBSZ				; if so do tab size
 7496/    2B9A :                        
 7497/    2B9A : 6100 EF82              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 7498/    2B9E : 4A00                   	TST.b		d0					; test result
 7499/    2BA0 : 6712                   	BEQ.s		LAB_NSTT				; branch if set for infinite line
 7500/    2BA2 :                        
 7501/    2BA2 : B03C 0010              	CMP.b		#$10,d0				; else make min width = 16d
 7502/    2BA6 : 6500 D9B8              	BCS		LAB_FCER				; if less do function call error & exit
 7503/    2BAA :                        
 7504/    2BAA :                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
 7505/    2BAA :                        ; tab size greater than the line length.
 7506/    2BAA :                        
 7507/    2BAA : B02B 05E2              	CMP.b		TabSiz(a3),d0			; compare with tab size
 7508/    2BAE : 6404                   	BCC.s		LAB_NSTT				; branch if >= tab size
 7509/    2BB0 :                        
 7510/    2BB0 : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
 7511/    2BB4 :                        LAB_NSTT
 7512/    2BB4 : 1740 05E6              	MOVE.b	d0,TWidth(a3)			; set the terminal width
 7513/    2BB8 : 6100 E5FA              	BSR		LAB_GBYT				; get BASIC byte back
 7514/    2BBC : 672C                   	BEQ.s		WExit					; exit if no following
 7515/    2BBE :                        
 7516/    2BBE : B03C 002C              	CMP.b		#',',d0				; else is it ","
 7517/    2BC2 : 6600 D9A8              	BNE		LAB_SNER				; if not do syntax error
 7518/    2BC6 :                        
 7519/    2BC6 :                        LAB_TBSZ
 7520/    2BC6 : 6100 EF52              	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
 7521/    2BCA : 4A00                   	TST.b		d0					; test TAB size
 7522/    2BCC : 6B00 D992              	BMI		LAB_FCER				; if >127 do function call error & exit
 7523/    2BD0 :                        
 7524/    2BD0 : B03C 0001              	CMP.b		#1,d0					; compare with min-1
 7525/    2BD4 : 6500 D98A              	BCS		LAB_FCER				; if <=1 do function call error & exit
 7526/    2BD8 :                        
 7527/    2BD8 : 122B 05E6              	MOVE.b	TWidth(a3),d1			; set flags for width
 7528/    2BDC : 6708                   	BEQ.s		LAB_SVTB				; skip check if infinite line
 7529/    2BDE :                        
 7530/    2BDE : B02B 05E6              	CMP.b		TWidth(a3),d0			; compare TAB with width
 7531/    2BE2 : 6E00 D97C              	BGT		LAB_FCER				; branch if too big
 7532/    2BE6 :                        
 7533/    2BE6 :                        LAB_SVTB
 7534/    2BE6 : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; save TAB size
 7535/    2BEA :                        
 7536/    2BEA :                        ; calculate tab column limit from TAB size. The Iclim is set to the last tab
 7537/    2BEA :                        ; position on a line that still has at least one whole tab width between it
 7538/    2BEA :                        ; and the end of the line.
 7539/    2BEA :                        
 7540/    2BEA :                        WExit
 7541/    2BEA : 102B 05E6              	MOVE.b	TWidth(a3),d0			; get width
 7542/    2BEE : 670A                   	BEQ.s		LAB_WDLP				; branch if infinite line
 7543/    2BF0 :                        
 7544/    2BF0 : B02B 05E2              	CMP.b		TabSiz(a3),d0			; compare with tab size
 7545/    2BF4 : 6404                   	BCC.s		LAB_WDLP				; branch if >= tab size
 7546/    2BF6 :                        
 7547/    2BF6 : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
 7548/    2BFA :                        LAB_WDLP
 7549/    2BFA : 902B 05E2              	SUB.b		TabSiz(a3),d0			; subtract tab size
 7550/    2BFE : 64FA                   	BCC.s		LAB_WDLP				; loop while no borrow
 7551/    2C00 :                        
 7552/    2C00 : D02B 05E2              	ADD.b		TabSiz(a3),d0			; add tab size back
 7553/    2C04 : D02B 05E2              	ADD.b		TabSiz(a3),d0			; add tab size back again
 7554/    2C08 :                        
 7555/    2C08 : 4400                   	NEG.b		d0					; make -ve
 7556/    2C0A : D02B 05E6              	ADD.b		TWidth(a3),d0			; subtract remainder from width
 7557/    2C0E : 1740 05E7              	MOVE.b	d0,Iclim(a3)			; save tab column limit
 7558/    2C12 :                        RTS_023
 7559/    2C12 : 4E75                   	RTS
 7560/    2C14 :                        
 7561/    2C14 :                        
 7562/    2C14 :                        ;************************************************************************************
 7563/    2C14 :                        ;
 7564/    2C14 :                        ; perform SQR()
 7565/    2C14 :                        
 7566/    2C14 :                        ; d0 is number to find the root of
 7567/    2C14 :                        ; d1 is the root result
 7568/    2C14 :                        ; d2 is the remainder
 7569/    2C14 :                        ; d3 is a counter
 7570/    2C14 :                        ; d4 is temp
 7571/    2C14 :                        
 7572/    2C14 :                        LAB_SQR
 7573/    2C14 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign
 7574/    2C18 : 6B00 D946              	BMI		LAB_FCER				; if -ve do function call error
 7575/    2C1C :                        
 7576/    2C1C : 4A2B 0594              	TST.b		FAC1_e(a3)				; test exponent
 7577/    2C20 : 67F0                   	BEQ.s		RTS_023				; exit if zero
 7578/    2C22 :                        
 7579/    2C22 : 48E7 7800              	MOVEM.l	d1-d4,-(sp)				; save registers
 7580/    2C26 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; copy FAC1
 7581/    2C2A : 7400                   	MOVEQ		#0,d2					; clear remainder
 7582/    2C2C : 2202                   	MOVE.l	d2,d1					; clear root
 7583/    2C2E :                        
 7584/    2C2E : 761F                   	MOVEQ		#$1F,d3				; $1F for DBF, 64 pairs of bits to
 7585/    2C30 :                        								; do for a 32 bit result
 7586/    2C30 : 082B 0000 0594         	BTST		#0,FAC1_e(a3)			; test exponent odd/even
 7587/    2C36 : 6606                   	BNE.s		LAB_SQE2				; if odd only 1 shift first time
 7588/    2C38 :                        
 7589/    2C38 :                        LAB_SQE1
 7590/    2C38 : D080                   	ADD.l		d0,d0					; shift highest bit of number ..
 7591/    2C3A : D582                   	ADDX.l	d2,d2					; .. into remainder .. never overflows
 7592/    2C3C : D281                   	ADD.l		d1,d1					; root = root	; 2 .. never overflows
 7593/    2C3E :                        LAB_SQE2
 7594/    2C3E : D080                   	ADD.l		d0,d0					; shift highest bit of number ..
 7595/    2C40 : D582                   	ADDX.l	d2,d2					; .. into remainder .. never overflows
 7596/    2C42 :                        
 7597/    2C42 : 2801                   	MOVE.l	d1,d4					; copy root
 7598/    2C44 : D884                   	ADD.l		d4,d4					; 2n
 7599/    2C46 : 5284                   	ADDQ.l	#1,d4					; 2n+1
 7600/    2C48 :                        
 7601/    2C48 : B484                   	CMP.l		d4,d2					; compare 2n+1 to remainder
 7602/    2C4A : 6504                   	BCS.s		LAB_SQNS				; skip sub if remainder smaller
 7603/    2C4C :                        
 7604/    2C4C : 9484                   	SUB.l		d4,d2					; subtract temp from remainder
 7605/    2C4E : 5281                   	ADDQ.l	#1,d1					; increment root
 7606/    2C50 :                        LAB_SQNS
 7607/    2C50 : 51CB FFE6              	DBF		d3,LAB_SQE1				; loop if not all done
 7608/    2C54 :                        
 7609/    2C54 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
 7610/    2C58 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent (d0 is clear here)
 7611/    2C5C : 907C 0080              	SUB.w		#$80,d0				; normalise
 7612/    2C60 : E248                   	LSR.w		#1,d0					; /2
 7613/    2C62 : 6402                   	BCC.s		LAB_SQNA				; skip increment if carry clear
 7614/    2C64 :                        
 7615/    2C64 : 5240                   	ADDQ.w	#1,d0					; add bit zero back in (allow for half shift)
 7616/    2C66 :                        LAB_SQNA
 7617/    2C66 : D07C 0080              	ADD.w		#$80,d0				; re-bias to $80
 7618/    2C6A : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save it
 7619/    2C6E : 4CDF 001E              	MOVEM.l	(sp)+,d1-d4				; restore registers
 7620/    2C72 : 6000 F09E              	BRA		LAB_24D5				; normalise FAC1 & return
 7621/    2C76 :                        
 7622/    2C76 :                        
 7623/    2C76 :                        ;************************************************************************************
 7624/    2C76 :                        ;
 7625/    2C76 :                        ; perform VARPTR()
 7626/    2C76 :                        
 7627/    2C76 :                        LAB_VARPTR
 7628/    2C76 : 101D                   	MOVE.b	(a5)+,d0				; increment pointer
 7629/    2C78 :                        LAB_VARCALL
 7630/    2C78 : 6100 E74A              	BSR		LAB_GVAR				; get variable address in a0
 7631/    2C7C : 6100 E522              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 7632/    2C80 : 2008                   	MOVE.l	a0,d0					; copy the variable address
 7633/    2C82 : 6000 EA30              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 7634/    2C86 :                        
 7635/    2C86 :                        
 7636/    2C86 :                        ;************************************************************************************
 7637/    2C86 :                        ;
 7638/    2C86 :                        ; perform RAMBASE
 7639/    2C86 :                        
 7640/    2C86 :                        LAB_RAM
 7641/    2C86 : 41F8 0400              	LEA		ram_base,a0			; get start of EhBASIC RAM
 7642/    2C8A : 2008                   	MOVE.l	a0,d0					; copy it
 7643/    2C8C : 6000 EA26              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 7644/    2C90 :                        
 7645/    2C90 :                        
 7646/    2C90 :                        ;************************************************************************************
 7647/    2C90 :                        ;
 7648/    2C90 :                        ; perform PI
 7649/    2C90 :                        
 7650/    2C90 :                        LAB_PI
 7651/    2C90 : 277C C90F DAA2 0590    	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; pi mantissa (32 bit)
 7652/    2C98 : 377C 8200 0594         	MOVE.w	#$8200,FAC1_e(a3)			; pi exponent and sign
 7653/    2C9E : 4E75                   	RTS
 7654/    2CA0 :                        
 7655/    2CA0 :                        
 7656/    2CA0 :                        ;************************************************************************************
 7657/    2CA0 :                        ;
 7658/    2CA0 :                        ; perform TWOPI
 7659/    2CA0 :                        
 7660/    2CA0 :                        LAB_TWOPI
 7661/    2CA0 : 277C C90F DAA2 0590    	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; 2pi mantissa (32 bit)
 7662/    2CA8 : 377C 8300 0594         	MOVE.w	#$8300,FAC1_e(a3)			; 2pi exponent and sign
 7663/    2CAE : 4E75                   	RTS
 7664/    2CB0 :                        
 7665/    2CB0 :                        
 7666/    2CB0 :                        ;************************************************************************************
 7667/    2CB0 :                        ;
 7668/    2CB0 :                        ; get ASCII string equivalent into FAC1 as integer32 or float
 7669/    2CB0 :                        
 7670/    2CB0 :                        ; entry is with a5 pointing to the first character of the string
 7671/    2CB0 :                        ; exit with a5 pointing to the first character after the string
 7672/    2CB0 :                        
 7673/    2CB0 :                        ; d0 is character
 7674/    2CB0 :                        ; d1 is mantissa
 7675/    2CB0 :                        ; d2 is partial and table mantissa
 7676/    2CB0 :                        ; d3 is mantissa exponent (decimal & binary)
 7677/    2CB0 :                        ; d4 is decimal exponent
 7678/    2CB0 :                        
 7679/    2CB0 :                        ; get FAC1 from string
 7680/    2CB0 :                        ; this routine now handles hex and binary values from strings
 7681/    2CB0 :                        ; starting with "$" and "%" respectively
 7682/    2CB0 :                        
 7683/    2CB0 :                        LAB_2887
 7684/    2CB0 : 48E7 7C00              	MOVEM.l	d1-d5,-(sp)				; save registers
 7685/    2CB4 : 7200                   	MOVEQ		#$00,d1				; clear temp accumulator
 7686/    2CB6 : 2601                   	MOVE.l	d1,d3					; set mantissa decimal exponent count
 7687/    2CB8 : 2801                   	MOVE.l	d1,d4					; clear decimal exponent
 7688/    2CBA : 1741 0595              	MOVE.b	d1,FAC1_s(a3)			; clear sign byte
 7689/    2CBE : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; set float data type
 7690/    2CC2 : 1741 05AF              	MOVE.b	d1,expneg(a3)			; clear exponent sign
 7691/    2CC6 : 6100 E4EC              	BSR		LAB_GBYT				; get first byte back
 7692/    2CCA : 653C                   	BCS.s		LAB_28FE				; go get floating if 1st character numeric
 7693/    2CCC :                        
 7694/    2CCC : B03C 002D              	CMP.b		#'-',d0				; or is it -ve number
 7695/    2CD0 : 6608                   	BNE.s		LAB_289A				; branch if not
 7696/    2CD2 :                        
 7697/    2CD2 : 177C 00FF 0595         	MOVE.b	#$FF,FAC1_s(a3)			; set sign byte
 7698/    2CD8 : 6006                   	BRA.s		LAB_289C				; now go scan & check for hex/bin/int
 7699/    2CDA :                        
 7700/    2CDA :                        LAB_289A
 7701/    2CDA :                        								; first character wasn't numeric or -
 7702/    2CDA : B03C 002B              	CMP.b		#'+',d0				; compare with '+'
 7703/    2CDE : 6606                   	BNE.s		LAB_289D				; branch if not '+' (go check for '.'/hex/binary
 7704/    2CE0 :                        								; /integer)
 7705/    2CE0 :                        	
 7706/    2CE0 :                        LAB_289C
 7707/    2CE0 :                        								; was "+" or "-" to start, so get next character
 7708/    2CE0 : 6100 E4D0              	BSR		LAB_IGBY				; increment & scan memory
 7709/    2CE4 : 6522                   	BCS.s		LAB_28FE				; branch if numeric character
 7710/    2CE6 :                        
 7711/    2CE6 :                        LAB_289D
 7712/    2CE6 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7713/    2CEA : 6700 0092              	BEQ		LAB_2904				; branch if '.'
 7714/    2CEE :                        
 7715/    2CEE :                        								; code here for hex/binary/integer numbers
 7716/    2CEE : B03C 0024              	CMP.b		#'$',d0				; compare with '$'
 7717/    2CF2 : 6700 010A              	BEQ		LAB_CHEX				; branch if '$'
 7718/    2CF6 :                        
 7719/    2CF6 : B03C 0025              	CMP.b		#'%',d0				; else compare with '%'
 7720/    2CFA : 6700 0164              	BEQ		LAB_CBIN				; branch if '%'
 7721/    2CFE :                        
 7722/    2CFE : 6000 008C              	BRA		LAB_2Y01				; not #.$%& so return 0
 7723/    2D02 :                        
 7724/    2D02 :                        LAB_28FD
 7725/    2D02 : 6100 E4AE              	BSR		LAB_IGBY				; get next character
 7726/    2D06 : 646C                   	BCC.s		LAB_2902				; exit loop if not a digit
 7727/    2D08 :                        
 7728/    2D08 :                        LAB_28FE
 7729/    2D08 : 6100 01A8              	BSR		d1x10					; multiply d1 by 10 and add character
 7730/    2D0C : 64F4                   	BCC.s		LAB_28FD				; loop for more if no overflow
 7731/    2D0E :                        
 7732/    2D0E :                        LAB_28FF
 7733/    2D0E :                        								; overflowed mantissa, count 10s exponent
 7734/    2D0E : 5283                   	ADDQ.l	#1,d3					; increment mantissa decimal exponent count
 7735/    2D10 : 6100 E4A0              	BSR		LAB_IGBY				; get next character
 7736/    2D14 : 65F8                   	BCS.s		LAB_28FF				; loop while numeric character
 7737/    2D16 :                        
 7738/    2D16 :                        								; done overflow, now flush fraction or do E
 7739/    2D16 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7740/    2D1A : 6606                   	BNE.s		LAB_2901				; branch if not '.'
 7741/    2D1C :                        
 7742/    2D1C :                        LAB_2900
 7743/    2D1C :                        								; flush remaining fraction digits
 7744/    2D1C : 6100 E494              	BSR		LAB_IGBY				; get next character
 7745/    2D20 : 65FA                   	BCS		LAB_2900				; loop while numeric character
 7746/    2D22 :                        
 7747/    2D22 :                        LAB_2901
 7748/    2D22 :                        								; done number, only (possible) exponent remains
 7749/    2D22 : B03C 0045              	CMP.b		#'E',d0				; else compare with 'E'
 7750/    2D26 : 6664                   	BNE.s		LAB_2Y01				; if not 'E' all done, go evaluate
 7751/    2D28 :                        
 7752/    2D28 :                        								; process exponent
 7753/    2D28 : 6100 E488              	BSR		LAB_IGBY				; get next character
 7754/    2D2C : 6528                   	BCS.s		LAB_2X04				; branch if digit
 7755/    2D2E :                        
 7756/    2D2E : B03C 002D              	CMP.b		#'-',d0				; or is it -ve number
 7757/    2D32 : 6706                   	BEQ.s		LAB_2X01				; branch if so
 7758/    2D34 :                        
 7759/    2D34 : B03C 00B3              	CMP.b		#TK_MINUS,d0			; or is it -ve number
 7760/    2D38 : 6608                   	BNE.s		LAB_2X02				; branch if not
 7761/    2D3A :                        
 7762/    2D3A :                        LAB_2X01
 7763/    2D3A : 177C 00FF 05AF         	MOVE.b	#$FF,expneg(a3)			; set exponent sign
 7764/    2D40 : 600E                   	BRA.s		LAB_2X03				; now go scan & check exponent
 7765/    2D42 :                        
 7766/    2D42 :                        LAB_2X02
 7767/    2D42 : B03C 002B              	CMP.b		#'+',d0				; or is it +ve number
 7768/    2D46 : 6708                   	BEQ.s		LAB_2X03				; branch if so
 7769/    2D48 :                        
 7770/    2D48 : B03C 00B2              	CMP.b		#TK_PLUS,d0				; or is it +ve number
 7771/    2D4C : 6600 D81E              	BNE		LAB_SNER				; wasn't - + TK_MINUS TK_PLUS or # so do error
 7772/    2D50 :                        
 7773/    2D50 :                        LAB_2X03
 7774/    2D50 : 6100 E460              	BSR		LAB_IGBY				; get next character
 7775/    2D54 : 6436                   	BCC.s		LAB_2Y01				; if not digit all done, go evaluate
 7776/    2D56 :                        LAB_2X04
 7777/    2D56 : C8FC 000A              	MULU		#10,d4				; multiply decimal exponent by 10
 7778/    2D5A : C0BC 0000 00FF         	AND.l		#$FF,d0				; mask character
 7779/    2D60 : 903C 0030              	SUB.b		#'0',d0				; convert to value
 7780/    2D64 : D880                   	ADD.l		d0,d4					; add to decimal exponent
 7781/    2D66 : B83C 0030              	CMP.b		#48,d4				; compare with decimal exponent limit+10
 7782/    2D6A : 6FE4                   	BLE.s		LAB_2X03				; loop if no overflow/underflow
 7783/    2D6C :                        
 7784/    2D6C :                        LAB_2X05
 7785/    2D6C :                        								; exponent value has overflowed
 7786/    2D6C : 6100 E444              	BSR		LAB_IGBY				; get next character
 7787/    2D70 : 65FA                   	BCS.s		LAB_2X05				; loop while numeric digit
 7788/    2D72 :                        
 7789/    2D72 : 6018                   	BRA.s		LAB_2Y01				; all done, go evaluate
 7790/    2D74 :                        
 7791/    2D74 :                        LAB_2902
 7792/    2D74 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7793/    2D78 : 6704                   	BEQ.s		LAB_2904				; branch if was '.'
 7794/    2D7A :                        
 7795/    2D7A : 60A6                   	BRA.s		LAB_2901				; branch if not '.' (go check/do 'E')
 7796/    2D7C :                        
 7797/    2D7C :                        LAB_2903
 7798/    2D7C : 5383                   	SUBQ.l	#1,d3					; decrement mantissa decimal exponent
 7799/    2D7E :                        LAB_2904
 7800/    2D7E :                        								; was dp so get fraction part
 7801/    2D7E : 6100 E432              	BSR		LAB_IGBY				; get next character
 7802/    2D82 : 649E                   	BCC.s		LAB_2901				; exit loop if not a digit (go check/do 'E')
 7803/    2D84 :                        
 7804/    2D84 : 6100 012C              	BSR		d1x10					; multiply d1 by 10 and add character
 7805/    2D88 : 64F2                   	BCC.s		LAB_2903				; loop for more if no overflow
 7806/    2D8A :                        
 7807/    2D8A : 6090                   	BRA.s		LAB_2900				; else go flush remaining fraction part
 7808/    2D8C :                        
 7809/    2D8C :                        LAB_2Y01
 7810/    2D8C :                        								; now evaluate result
 7811/    2D8C : 4A2B 05AF              	TST.b		expneg(a3)				; test exponent sign
 7812/    2D90 : 6A02                   	BPL.s		LAB_2Y02				; branch if sign positive
 7813/    2D92 :                        
 7814/    2D92 : 4484                   	NEG.l		d4					; negate decimal exponent
 7815/    2D94 :                        LAB_2Y02
 7816/    2D94 : D883                   	ADD.l		d3,d4					; add mantissa decimal exponent
 7817/    2D96 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7818/    2D98 : 4A81                   	TST.l		d1					; test mantissa
 7819/    2D9A : 6752                   	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
 7820/    2D9C :                        
 7821/    2D9C : 6B08                   	BMI.s		LAB_2Y04				; branch if already mormalised
 7822/    2D9E :                        
 7823/    2D9E : 5383                   	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
 7824/    2DA0 :                        LAB_2Y03
 7825/    2DA0 : D281                   	ADD.l		d1,d1					; shift mantissa
 7826/    2DA2 : 5BCB FFFC              	DBMI		d3,LAB_2Y03				; decrement & loop if not normalised
 7827/    2DA6 :                        
 7828/    2DA6 :                        								; ensure not too big or small
 7829/    2DA6 :                        LAB_2Y04
 7830/    2DA6 : B8BC 0000 0026         	CMP.l		#38,d4				; compare decimal exponent with max exponent
 7831/    2DAC : 6E00 D7AE              	BGT		LAB_OFER				; if greater do overflow error and warm start
 7832/    2DB0 :                        
 7833/    2DB0 : B8BC FFFF FFDA         	CMP.l		#-38,d4				; compare decimal exponent with min exponent
 7834/    2DB6 : 6D34                   	BLT.s		LAB_ret0				; if less just return zero
 7835/    2DB8 :                        
 7836/    2DB8 : 4484                   	NEG.l		d4					; negate decimal exponent to go right way
 7837/    2DBA : C9FC 0006              	MULS		#6,d4					; 6 bytes per entry
 7838/    2DBE : 2F08                   	MOVE.l	a0,-(sp)				; save register
 7839/    2DC0 : 41FA 0210              	LEA		LAB_P_10(pc),a0			; point to table
 7840/    2DC4 : 1770 4000 059C         	MOVE.b	(a0,d4.w),FAC2_e(a3)		; copy exponent for multiply
 7841/    2DCA : 2770 4002 0598         	MOVE.l	2(a0,d4.w),FAC2_m(a3)		; copy table mantissa
 7842/    2DD0 : 205F                   	MOVE.l	(sp)+,a0				; restore register
 7843/    2DD2 :                        
 7844/    2DD2 : 0A03 0080              	EORI.b	#$80,d3				; normalise input exponent
 7845/    2DD6 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save input mantissa
 7846/    2DDA : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save input exponent
 7847/    2DDE : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; set sign as sign compare
 7848/    2DE4 :                        
 7849/    2DE4 : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7850/    2DE8 : 6000 F050              	BRA		LAB_MULTIPLY			; go multiply input by table
 7851/    2DEC :                        
 7852/    2DEC :                        LAB_ret0
 7853/    2DEC : 7200                   	MOVEQ		#0,d1					; clear mantissa
 7854/    2DEE :                        LAB_rtn0
 7855/    2DEE : 2601                   	MOVE.l	d1,d3					; clear exponent
 7856/    2DF0 : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save exponent
 7857/    2DF4 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 7858/    2DF8 : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7859/    2DFC : 4E75                   	RTS
 7860/    2DFE :                        
 7861/    2DFE :                        
 7862/    2DFE :                        ;************************************************************************************
 7863/    2DFE :                        ;
 7864/    2DFE :                        ; $ for hex add-on
 7865/    2DFE :                        
 7866/    2DFE :                        ; gets here if the first character was "$" for hex
 7867/    2DFE :                        ; get hex number
 7868/    2DFE :                        
 7869/    2DFE :                        LAB_CHEX
 7870/    2DFE : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
 7871/    2E04 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7872/    2E06 :                        LAB_CHXX
 7873/    2E06 : 6100 E3AA              	BSR		LAB_IGBY				; increment & scan memory
 7874/    2E0A : 6514                   	BCS.s		LAB_ISHN				; branch if numeric character
 7875/    2E0C :                        
 7876/    2E0C : 803C 0020              	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
 7877/    2E10 : 903C 0061              	SUB.b		#'a',d0				; subtract "a"
 7878/    2E14 : 652A                   	BCS.s		LAB_CHX3				; exit if <"a"
 7879/    2E16 :                        
 7880/    2E16 : B03C 0006              	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
 7881/    2E1A : 6424                   	BCC.s		LAB_CHX3				; exit if >"f"
 7882/    2E1C :                        
 7883/    2E1C : D03C 003A              	ADD.b		#$3A,d0				; convert to nibble+"0"
 7884/    2E20 :                        LAB_ISHN
 7885/    2E20 : 616C                   	BSR.s		d1x16					; multiply d1 by 16 and add the character
 7886/    2E22 : 64E2                   	BCC.s		LAB_CHXX				; loop for more if no overflow
 7887/    2E24 :                        
 7888/    2E24 :                        								; overflowed mantissa, count 16s exponent
 7889/    2E24 :                        LAB_CHX1
 7890/    2E24 : 5883                   	ADDQ.l	#4,d3					; increment mantissa exponent count
 7891/    2E26 : 6900 D734              	BVS		LAB_OFER				; do overflow error if overflowed
 7892/    2E2A :                        
 7893/    2E2A : 6100 E386              	BSR		LAB_IGBY				; get next character
 7894/    2E2E : 65F4                   	BCS.s		LAB_CHX1				; loop while numeric character
 7895/    2E30 :                        
 7896/    2E30 : 803C 0020              	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
 7897/    2E34 : 903C 0061              	SUB.b		#'a',d0				; subtract "a"
 7898/    2E38 : 6506                   	BCS.s		LAB_CHX3				; exit if <"a"
 7899/    2E3A :                        
 7900/    2E3A : B03C 0006              	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
 7901/    2E3E : 65E4                   	BCS.s		LAB_CHX1				; loop if <="f"
 7902/    2E40 :                        
 7903/    2E40 :                        								; now return value
 7904/    2E40 :                        LAB_CHX3
 7905/    2E40 : 4A81                   	TST.l		d1					; test mantissa
 7906/    2E42 : 67AA                   	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
 7907/    2E44 :                        
 7908/    2E44 : 6B08                   	BMI.s		LAB_exxf				; branch if already mormalised
 7909/    2E46 :                        
 7910/    2E46 : 5383                   	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
 7911/    2E48 :                        LAB_CHX2
 7912/    2E48 : D281                   	ADD.l		d1,d1					; shift mantissa
 7913/    2E4A : 5BCB FFFC              	DBMI		d3,LAB_CHX2				; decrement & loop if not normalised
 7914/    2E4E :                        
 7915/    2E4E :                        LAB_exxf
 7916/    2E4E : 0A03 0080              	EORI.b	#$80,d3				; normalise exponent
 7917/    2E52 : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save exponent
 7918/    2E56 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 7919/    2E5A : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7920/    2E5E :                        RTS_024
 7921/    2E5E : 4E75                   	RTS
 7922/    2E60 :                        
 7923/    2E60 :                        
 7924/    2E60 :                        ;************************************************************************************
 7925/    2E60 :                        ;
 7926/    2E60 :                        ; % for binary add-on
 7927/    2E60 :                        
 7928/    2E60 :                        ; gets here if the first character was "%" for binary
 7929/    2E60 :                        ; get binary number
 7930/    2E60 :                        
 7931/    2E60 :                        LAB_CBIN
 7932/    2E60 : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
 7933/    2E66 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7934/    2E68 :                        LAB_CBXN
 7935/    2E68 : 6100 E348              	BSR		LAB_IGBY				; increment & scan memory
 7936/    2E6C : 64D2                   	BCC.s		LAB_CHX3				; if not numeric character go return value
 7937/    2E6E :                        
 7938/    2E6E : B03C 0032              	CMP.b		#'2',d0				; compare with "2" (max+1)
 7939/    2E72 : 64CC                   	BCC.s		LAB_CHX3				; if >="2" go return value
 7940/    2E74 :                        
 7941/    2E74 : 2401                   	MOVE.l	d1,d2					; copy value
 7942/    2E76 : 6124                   	BSR.s		d1x02					; multiply d1 by 2 and add character
 7943/    2E78 : 64EE                   	BCC.s		LAB_CBXN				; loop for more if no overflow
 7944/    2E7A :                        
 7945/    2E7A :                        								; overflowed mantissa, count 2s exponent
 7946/    2E7A :                        LAB_CBX1
 7947/    2E7A : 5283                   	ADDQ.l	#1,d3					; increment mantissa exponent count
 7948/    2E7C : 6900 D6DE              	BVS		LAB_OFER				; do overflow error if overflowed
 7949/    2E80 :                        
 7950/    2E80 : 6100 E330              	BSR		LAB_IGBY				; get next character
 7951/    2E84 : 64BA                   	BCC.s		LAB_CHX3				; if not numeric character go return value
 7952/    2E86 :                        
 7953/    2E86 : B03C 0032              	CMP.b		#'2',d0				; compare with "2" (max+1)
 7954/    2E8A : 65EE                   	BCS.s		LAB_CBX1				; loop if <"2"
 7955/    2E8C :                        
 7956/    2E8C : 60B2                   	BRA.s		LAB_CHX3				; if not numeric character go return value
 7957/    2E8E :                        
 7958/    2E8E :                        ; half way decent times 16 and times 2 with overflow checks
 7959/    2E8E :                        
 7960/    2E8E :                        d1x16
 7961/    2E8E : 2401                   	MOVE.l	d1,d2					; copy value
 7962/    2E90 : D482                   	ADD.l		d2,d2					; times two
 7963/    2E92 : 65CA                   	BCS.s		RTS_024				; return if overflow
 7964/    2E94 :                        
 7965/    2E94 : D482                   	ADD.l		d2,d2					; times four
 7966/    2E96 : 65C6                   	BCS.s		RTS_024				; return if overflow
 7967/    2E98 :                        
 7968/    2E98 : D482                   	ADD.l		d2,d2					; times eight
 7969/    2E9A : 65C2                   	BCS.s		RTS_024				; return if overflow
 7970/    2E9C :                        
 7971/    2E9C :                        d1x02
 7972/    2E9C : D482                   	ADD.l		d2,d2					; times sixteen (ten/two)
 7973/    2E9E : 65BE                   	BCS.s		RTS_024				; return if overflow
 7974/    2EA0 :                        
 7975/    2EA0 :                        ; now add in new digit
 7976/    2EA0 :                        
 7977/    2EA0 : C0BC 0000 00FF         	AND.l		#$FF,d0				; mask character
 7978/    2EA6 : 903C 0030              	SUB.b		#'0',d0				; convert to value
 7979/    2EAA : D480                   	ADD.l		d0,d2					; add to result
 7980/    2EAC : 65B0                   	BCS.s		RTS_024				; return if overflow, it should never ever do
 7981/    2EAE :                        								; this
 7982/    2EAE :                        
 7983/    2EAE : 2202                   	MOVE.l	d2,d1					; copy result
 7984/    2EB0 : 4E75                   	RTS
 7985/    2EB2 :                        
 7986/    2EB2 :                        ; half way decent times 10 with overflow checks
 7987/    2EB2 :                        
 7988/    2EB2 :                        d1x10
 7989/    2EB2 : 2401                   	MOVE.l	d1,d2					; copy value
 7990/    2EB4 : D482                   	ADD.l		d2,d2					; times two
 7991/    2EB6 : 6508                   	BCS.s		RTS_025				; return if overflow
 7992/    2EB8 :                        
 7993/    2EB8 : D482                   	ADD.l		d2,d2					; times four
 7994/    2EBA : 6504                   	BCS.s		RTS_025				; return if overflow
 7995/    2EBC :                        
 7996/    2EBC : D481                   	ADD.l		d1,d2					; times five
 7997/    2EBE : 64DC                   	BCC.s		d1x02					; do times two and add in new digit if ok
 7998/    2EC0 :                        
 7999/    2EC0 :                        RTS_025
 8000/    2EC0 : 4E75                   	RTS
 8001/    2EC2 :                        
 8002/    2EC2 :                        
 8003/    2EC2 :                        ;************************************************************************************
 8004/    2EC2 :                        ;
 8005/    2EC2 :                        ; token values needed for BASIC
 8006/    2EC2 :                        
 8007/    2EC2 : =$80                   TK_END		EQU $80				; $80
 8008/    2EC2 : =$81                   TK_FOR		EQU TK_END+1			; $81
 8009/    2EC2 : =$82                   TK_NEXT		EQU TK_FOR+1			; $82
 8010/    2EC2 : =$83                   TK_DATA		EQU TK_NEXT+1			; $83
 8011/    2EC2 : =$84                   TK_INPUT		EQU TK_DATA+1			; $84
 8012/    2EC2 : =$85                   TK_DIM		EQU TK_INPUT+1			; $85
 8013/    2EC2 : =$86                   TK_READ		EQU TK_DIM+1			; $86
 8014/    2EC2 : =$87                   TK_LET		EQU TK_READ+1			; $87
 8015/    2EC2 : =$88                   TK_DEC		EQU TK_LET+1			; $88
 8016/    2EC2 : =$89                   TK_GOTO		EQU TK_DEC+1			; $89
 8017/    2EC2 : =$8A                   TK_RUN		EQU TK_GOTO+1			; $8A
 8018/    2EC2 : =$8B                   TK_IF			EQU TK_RUN+1			; $8B
 8019/    2EC2 : =$8C                   TK_RESTORE		EQU TK_IF+1				; $8C
 8020/    2EC2 : =$8D                   TK_GOSUB		EQU TK_RESTORE+1			; $8D
 8021/    2EC2 : =$8E                   TK_RETURN		EQU TK_GOSUB+1			; $8E
 8022/    2EC2 : =$8F                   TK_REM		EQU TK_RETURN+1			; $8F
 8023/    2EC2 : =$90                   TK_STOP		EQU TK_REM+1			; $90
 8024/    2EC2 : =$91                   TK_ON			EQU TK_STOP+1			; $91
 8025/    2EC2 : =$92                   TK_NULL		EQU TK_ON+1				; $92
 8026/    2EC2 : =$93                   TK_INC		EQU TK_NULL+1			; $93
 8027/    2EC2 : =$94                   TK_WAIT		EQU TK_INC+1			; $94
 8028/    2EC2 : =$95                   TK_LOAD		EQU TK_WAIT+1			; $95
 8029/    2EC2 : =$96                   TK_SAVE		EQU TK_LOAD+1			; $96
 8030/    2EC2 : =$97                   TK_DEF		EQU TK_SAVE+1			; $97
 8031/    2EC2 : =$98                   TK_POKE		EQU TK_DEF+1			; $98
 8032/    2EC2 : =$99                   TK_DOKE		EQU TK_POKE+1			; $99
 8033/    2EC2 : =$9A                   TK_LOKE		EQU TK_DOKE+1			; $9A
 8034/    2EC2 : =$9B                   TK_CALL		EQU TK_LOKE+1			; $9B
 8035/    2EC2 : =$9C                   TK_DO			EQU TK_CALL+1			; $9C
 8036/    2EC2 : =$9D                   TK_LOOP		EQU TK_DO+1				; $9D
 8037/    2EC2 : =$9E                   TK_PRINT		EQU TK_LOOP+1			; $9E
 8038/    2EC2 : =$9F                   TK_CONT		EQU TK_PRINT+1			; $9F
 8039/    2EC2 : =$A0                   TK_LIST		EQU TK_CONT+1			; $A0
 8040/    2EC2 : =$A1                   TK_CLEAR		EQU TK_LIST+1			; $A1
 8041/    2EC2 : =$A2                   TK_NEW		EQU TK_CLEAR+1			; $A2
 8042/    2EC2 : =$A3                   TK_WIDTH		EQU TK_NEW+1			; $A3
 8043/    2EC2 : =$A4                   TK_GET		EQU TK_WIDTH+1			; $A4
 8044/    2EC2 : =$A5                   TK_SWAP		EQU TK_GET+1			; $A5
 8045/    2EC2 : =$A6                   TK_BITSET		EQU TK_SWAP+1			; $A6
 8046/    2EC2 : =$A7                   TK_BITCLR		EQU TK_BITSET+1			; $A7
 8047/    2EC2 : =$A8                   TK_TAB		EQU TK_BITCLR+1			; $A8
 8048/    2EC2 : =$A9                   TK_ELSE		EQU TK_TAB+1			; $A9
 8049/    2EC2 : =$AA                   TK_TO			EQU TK_ELSE+1			; $AA
 8050/    2EC2 : =$AB                   TK_FN			EQU TK_TO+1				; $AB
 8051/    2EC2 : =$AC                   TK_SPC		EQU TK_FN+1				; $AC
 8052/    2EC2 : =$AD                   TK_THEN		EQU TK_SPC+1			; $AD
 8053/    2EC2 : =$AE                   TK_NOT		EQU TK_THEN+1			; $AE
 8054/    2EC2 : =$AF                   TK_STEP		EQU TK_NOT+1			; $AF
 8055/    2EC2 : =$B0                   TK_UNTIL		EQU TK_STEP+1			; $B0
 8056/    2EC2 : =$B1                   TK_WHILE		EQU TK_UNTIL+1			; $B1
 8057/    2EC2 : =$B2                   TK_PLUS		EQU TK_WHILE+1			; $B2
 8058/    2EC2 : =$B3                   TK_MINUS		EQU TK_PLUS+1			; $B3
 8059/    2EC2 : =$B4                   TK_MULT		EQU TK_MINUS+1			; $B4
 8060/    2EC2 : =$B5                   TK_DIV		EQU TK_MULT+1			; $B5
 8061/    2EC2 : =$B6                   TK_POWER		EQU TK_DIV+1			; $B6
 8062/    2EC2 : =$B7                   TK_AND		EQU TK_POWER+1			; $B7
 8063/    2EC2 : =$B8                   TK_EOR		EQU TK_AND+1			; $B8
 8064/    2EC2 : =$B9                   TK_OR			EQU TK_EOR+1			; $B9
 8065/    2EC2 : =$BA                   TK_RSHIFT		EQU TK_OR+1				; $BA
 8066/    2EC2 : =$BB                   TK_LSHIFT		EQU TK_RSHIFT+1			; $BB
 8067/    2EC2 : =$BC                   TK_GT			EQU TK_LSHIFT+1			; $BC
 8068/    2EC2 : =$BD                   TK_EQUAL		EQU TK_GT+1				; $BD
 8069/    2EC2 : =$BE                   TK_LT			EQU TK_EQUAL+1			; $BE
 8070/    2EC2 : =$BF                   TK_SGN		EQU TK_LT+1				; $BF
 8071/    2EC2 : =$C0                   TK_INT		EQU TK_SGN+1			; $C0
 8072/    2EC2 : =$C1                   TK_ABS		EQU TK_INT+1			; $C1
 8073/    2EC2 : =$C2                   TK_USR		EQU TK_ABS+1			; $C2
 8074/    2EC2 : =$C3                   TK_FRE		EQU TK_USR+1			; $C3
 8075/    2EC2 : =$C4                   TK_POS		EQU TK_FRE+1			; $C4
 8076/    2EC2 : =$C5                   TK_SQR		EQU TK_POS+1			; $C5
 8077/    2EC2 : =$C6                   TK_RND		EQU TK_SQR+1			; $C6
 8078/    2EC2 : =$C7                   TK_LOG		EQU TK_RND+1			; $C7
 8079/    2EC2 : =$C8                   TK_EXP		EQU TK_LOG+1			; $C8
 8080/    2EC2 : =$C9                   TK_COS		EQU TK_EXP+1			; $C9
 8081/    2EC2 : =$CA                   TK_SIN		EQU TK_COS+1			; $CA
 8082/    2EC2 : =$CB                   TK_TAN		EQU TK_SIN+1			; $CB
 8083/    2EC2 : =$CC                   TK_ATN		EQU TK_TAN+1			; $CC
 8084/    2EC2 : =$CD                   TK_PEEK		EQU TK_ATN+1			; $CD
 8085/    2EC2 : =$CE                   TK_DEEK		EQU TK_PEEK+1			; $CE
 8086/    2EC2 : =$CF                   TK_LEEK		EQU TK_DEEK+1			; $CF
 8087/    2EC2 : =$D0                   TK_LEN		EQU TK_LEEK+1			; $D0
 8088/    2EC2 : =$D1                   TK_STRS		EQU TK_LEN+1			; $D1
 8089/    2EC2 : =$D2                   TK_VAL		EQU TK_STRS+1			; $D2
 8090/    2EC2 : =$D3                   TK_ASC		EQU TK_VAL+1			; $D3
 8091/    2EC2 : =$D4                   TK_UCASES		EQU TK_ASC+1			; $D4
 8092/    2EC2 : =$D5                   TK_LCASES		EQU TK_UCASES+1			; $D5
 8093/    2EC2 : =$D6                   TK_CHRS		EQU TK_LCASES+1			; $D6
 8094/    2EC2 : =$D7                   TK_HEXS		EQU TK_CHRS+1			; $D7
 8095/    2EC2 : =$D8                   TK_BINS		EQU TK_HEXS+1			; $D8
 8096/    2EC2 : =$D9                   TK_BITTST		EQU TK_BINS+1			; $D9
 8097/    2EC2 : =$DA                   TK_MAX		EQU TK_BITTST+1			; $DA
 8098/    2EC2 : =$DB                   TK_MIN		EQU TK_MAX+1			; $DB
 8099/    2EC2 : =$DC                   TK_RAM		EQU TK_MIN+1			; $DC
 8100/    2EC2 : =$DD                   TK_PI			EQU TK_RAM+1			; $DD
 8101/    2EC2 : =$DE                   TK_TWOPI		EQU TK_PI+1				; $DE
 8102/    2EC2 : =$DF                   TK_VPTR		EQU TK_TWOPI+1			; $DF
 8103/    2EC2 : =$E0                   TK_SADD		EQU TK_VPTR+1			; $E0
 8104/    2EC2 : =$E1                   TK_LEFTS		EQU TK_SADD+1			; $E1
 8105/    2EC2 : =$E2                   TK_RIGHTS		EQU TK_LEFTS+1			; $E2
 8106/    2EC2 : =$E3                   TK_MIDS		EQU TK_RIGHTS+1			; $E3
 8107/    2EC2 : =$E4                   TK_USINGS		EQU TK_MIDS+1			; $E4
 8108/    2EC2 :                        
 8109/    2EC2 :                        
 8110/    2EC2 :                        ;************************************************************************************
 8111/    2EC2 :                        ;
 8112/    2EC2 :                        ; binary to unsigned decimal table
 8113/    2EC2 :                        
 8114/    2EC2 :                        Bin2dec
 8115/    2EC2 : 3B9A CA00              	dc.l	$3B9ACA00					; 1000000000
 8116/    2EC6 : 05F5 E100              	dc.l	$05F5E100					; 100000000
 8117/    2ECA : 0098 9680              	dc.l	$00989680					; 10000000
 8118/    2ECE : 000F 4240              	dc.l	$000F4240					; 1000000
 8119/    2ED2 : 0001 86A0              	dc.l	$000186A0					; 100000
 8120/    2ED6 : 0000 2710              	dc.l	$00002710					; 10000
 8121/    2EDA : 0000 03E8              	dc.l	$000003E8					; 1000
 8122/    2EDE : 0000 0064              	dc.l	$00000064					; 100
 8123/    2EE2 : 0000 000A              	dc.l	$0000000A					; 10
 8124/    2EE6 : 0000 0000              	dc.l	$00000000					; 0 end marker
 8125/    2EEA :                        
 8126/    2EEA :                        LAB_RSED
 8127/    2EEA : 332E 3232              	dc.l	$332E3232					; 858665522
 8128/    2EEE :                        
 8129/    2EEE :                        ; string to value exponent table
 8130/    2EEE :                        
 8131/    2EEE : FF00                   	dc.w	255<<8					; 10**38
 8132/    2EF0 : 9676 9951              	dc.l	$96769951
 8133/    2EF4 : FB00                   	dc.w	251<<8					; 10**37
 8134/    2EF6 : F0BD C21B              	dc.l	$F0BDC21B
 8135/    2EFA : F800                   	dc.w	248<<8					; 10**36
 8136/    2EFC : C097 CE7C              	dc.l	$C097CE7C
 8137/    2F00 : F500                   	dc.w	245<<8					; 10**35
 8138/    2F02 : 9A13 0B96              	dc.l	$9A130B96
 8139/    2F06 : F100                   	dc.w	241<<8					; 10**34
 8140/    2F08 : F684 DF57              	dc.l	$F684DF57
 8141/    2F0C : EE00                   	dc.w	238<<8					; 10**33
 8142/    2F0E : C537 1912              	dc.l	$C5371912
 8143/    2F12 : EB00                   	dc.w	235<<8					; 10**32
 8144/    2F14 : 9DC5 ADA8              	dc.l	$9DC5ADA8
 8145/    2F18 : E700                   	dc.w	231<<8					; 10**31
 8146/    2F1A : FC6F 7C40              	dc.l	$FC6F7C40
 8147/    2F1E : E400                   	dc.w	228<<8					; 10**30
 8148/    2F20 : C9F2 C9CD              	dc.l	$C9F2C9CD
 8149/    2F24 : E100                   	dc.w	225<<8					; 10**29
 8150/    2F26 : A18F 07D7              	dc.l	$A18F07D7
 8151/    2F2A : DE00                   	dc.w	222<<8					; 10**28
 8152/    2F2C : 813F 3979              	dc.l	$813F3979
 8153/    2F30 : DA00                   	dc.w	218<<8					; 10**27
 8154/    2F32 : CECB 8F28              	dc.l	$CECB8F28
 8155/    2F36 : D700                   	dc.w	215<<8					; 10**26
 8156/    2F38 : A56F A5BA              	dc.l	$A56FA5BA
 8157/    2F3C : D400                   	dc.w	212<<8					; 10**25
 8158/    2F3E : 8459 5161              	dc.l	$84595161
 8159/    2F42 : D000                   	dc.w	208<<8					; 10**24
 8160/    2F44 : D3C2 1BCF              	dc.l	$D3C21BCF
 8161/    2F48 : CD00                   	dc.w	205<<8					; 10**23
 8162/    2F4A : A968 163F              	dc.l	$A968163F
 8163/    2F4E : CA00                   	dc.w	202<<8					; 10**22
 8164/    2F50 : 8786 7832              	dc.l	$87867832
 8165/    2F54 : C600                   	dc.w	198<<8					; 10**21
 8166/    2F56 : D8D7 26B7              	dc.l	$D8D726B7
 8167/    2F5A : C300                   	dc.w	195<<8					; 10**20
 8168/    2F5C : AD78 EBC6              	dc.l	$AD78EBC6
 8169/    2F60 : C000                   	dc.w	192<<8					; 10**19
 8170/    2F62 : 8AC7 2305              	dc.l	$8AC72305
 8171/    2F66 : BC00                   	dc.w	188<<8					; 10**18
 8172/    2F68 : DE0B 6B3A              	dc.l	$DE0B6B3A
 8173/    2F6C : B900                   	dc.w	185<<8					; 10**17
 8174/    2F6E : B1A2 BC2F              	dc.l	$B1A2BC2F
 8175/    2F72 : B600                   	dc.w	182<<8					; 10**16
 8176/    2F74 : 8E1B C9BF              	dc.l	$8E1BC9BF
 8177/    2F78 : B200                   	dc.w	178<<8					; 10**15
 8178/    2F7A : E35F A932              	dc.l	$E35FA932
 8179/    2F7E : AF00                   	dc.w	175<<8					; 10**14
 8180/    2F80 : B5E6 20F5              	dc.l	$B5E620F5
 8181/    2F84 : AC00                   	dc.w	172<<8					; 10**13
 8182/    2F86 : 9184 E72A              	dc.l	$9184E72A
 8183/    2F8A : A800                   	dc.w	168<<8					; 10**12
 8184/    2F8C : E8D4 A510              	dc.l	$E8D4A510
 8185/    2F90 : A500                   	dc.w	165<<8					; 10**11
 8186/    2F92 : BA43 B740              	dc.l	$BA43B740
 8187/    2F96 : A200                   	dc.w	162<<8					; 10**10
 8188/    2F98 : 9502 F900              	dc.l	$9502F900
 8189/    2F9C : 9E00                   	dc.w	158<<8					; 10**9
 8190/    2F9E : EE6B 2800              	dc.l	$EE6B2800
 8191/    2FA2 : 9B00                   	dc.w	155<<8					; 10**8
 8192/    2FA4 : BEBC 2000              	dc.l	$BEBC2000
 8193/    2FA8 : 9800                   	dc.w	152<<8					; 10**7
 8194/    2FAA : 9896 8000              	dc.l	$98968000
 8195/    2FAE : 9400                   	dc.w	148<<8					; 10**6
 8196/    2FB0 : F424 0000              	dc.l	$F4240000
 8197/    2FB4 : 9100                   	dc.w	145<<8					; 10**5
 8198/    2FB6 : C350 0000              	dc.l	$C3500000
 8199/    2FBA : 8E00                   	dc.w	142<<8					; 10**4
 8200/    2FBC : 9C40 0000              	dc.l	$9C400000
 8201/    2FC0 : 8A00                   	dc.w	138<<8					; 10**3
 8202/    2FC2 : FA00 0000              	dc.l	$FA000000
 8203/    2FC6 : 8700                   	dc.w	135<<8					; 10**2
 8204/    2FC8 : C800 0000              	dc.l	$C8000000
 8205/    2FCC : 8400                   	dc.w	132<<8					; 10**1
 8206/    2FCE : A000 0000              	dc.l	$A0000000
 8207/    2FD2 :                        LAB_P_10
 8208/    2FD2 : 8100                   	dc.w	129<<8					; 10**0
 8209/    2FD4 : 8000 0000              	dc.l	$80000000
 8210/    2FD8 : 7D00                   	dc.w	125<<8					; 10**-1
 8211/    2FDA : CCCC CCCD              	dc.l	$CCCCCCCD
 8212/    2FDE : 7A00                   	dc.w	122<<8					; 10**-2
 8213/    2FE0 : A3D7 0A3D              	dc.l	$A3D70A3D
 8214/    2FE4 : 7700                   	dc.w	119<<8					; 10**-3
 8215/    2FE6 : 8312 6E98              	dc.l	$83126E98
 8216/    2FEA : 7300                   	dc.w	115<<8					; 10**-4
 8217/    2FEC : D1B7 1759              	dc.l	$D1B71759
 8218/    2FF0 : 7000                   	dc.w	112<<8					; 10**-5
 8219/    2FF2 : A7C5 AC47              	dc.l	$A7C5AC47
 8220/    2FF6 : 6D00                   	dc.w	109<<8					; 10**-6
 8221/    2FF8 : 8637 BD06              	dc.l	$8637BD06
 8222/    2FFC : 6900                   	dc.w	105<<8					; 10**-7
 8223/    2FFE : D6BF 94D6              	dc.l	$D6BF94D6
 8224/    3002 : 6600                   	dc.w	102<<8					; 10**-8
 8225/    3004 : ABCC 7712              	dc.l	$ABCC7712
 8226/    3008 : 6300                   	dc.w	99<<8						; 10**-9
 8227/    300A : 8970 5F41              	dc.l	$89705F41
 8228/    300E : 5F00                   	dc.w	95<<8						; 10**-10
 8229/    3010 : DBE6 FECF              	dc.l	$DBE6FECF
 8230/    3014 : 5C00                   	dc.w	92<<8						; 10**-11
 8231/    3016 : AFEB FF0C              	dc.l	$AFEBFF0C
 8232/    301A : 5900                   	dc.w	89<<8						; 10**-12
 8233/    301C : 8CBC CC09              	dc.l	$8CBCCC09
 8234/    3020 : 5500                   	dc.w	85<<8						; 10**-13
 8235/    3022 : E12E 1342              	dc.l	$E12E1342
 8236/    3026 : 5200                   	dc.w	82<<8						; 10**-14
 8237/    3028 : B424 DC35              	dc.l	$B424DC35
 8238/    302C : 4F00                   	dc.w	79<<8						; 10**-15
 8239/    302E : 901D 7CF7              	dc.l	$901D7CF7
 8240/    3032 : 4B00                   	dc.w	75<<8						; 10**-16
 8241/    3034 : E695 94BF              	dc.l	$E69594BF
 8242/    3038 : 4800                   	dc.w	72<<8						; 10**-17
 8243/    303A : B877 AA32              	dc.l	$B877AA32
 8244/    303E : 4500                   	dc.w	69<<8						; 10**-18
 8245/    3040 : 9392 EE8F              	dc.l	$9392EE8F
 8246/    3044 : 4100                   	dc.w	65<<8						; 10**-19
 8247/    3046 : EC1E 4A7E              	dc.l	$EC1E4A7E
 8248/    304A : 3E00                   	dc.w	62<<8						; 10**-20
 8249/    304C : BCE5 0865              	dc.l	$BCE50865
 8250/    3050 : 3B00                   	dc.w	59<<8						; 10**-21
 8251/    3052 : 971D A050              	dc.l	$971DA050
 8252/    3056 : 3700                   	dc.w	55<<8						; 10**-22
 8253/    3058 : F1C9 0081              	dc.l	$F1C90081
 8254/    305C : 3400                   	dc.w	52<<8						; 10**-23
 8255/    305E : C16D 9A01              	dc.l	$C16D9A01
 8256/    3062 : 3100                   	dc.w	49<<8						; 10**-24
 8257/    3064 : 9ABE 14CD              	dc.l	$9ABE14CD
 8258/    3068 : 2D00                   	dc.w	45<<8						; 10**-25
 8259/    306A : F796 87AE              	dc.l	$F79687AE
 8260/    306E : 2A00                   	dc.w	42<<8						; 10**-26
 8261/    3070 : C612 0625              	dc.l	$C6120625
 8262/    3074 : 2700                   	dc.w	39<<8						; 10**-27
 8263/    3076 : 9E74 D1B8              	dc.l	$9E74D1B8
 8264/    307A : 2300                   	dc.w	35<<8						; 10**-28
 8265/    307C : FD87 B5F3              	dc.l	$FD87B5F3
 8266/    3080 : 2000                   	dc.w	32<<8						; 10**-29
 8267/    3082 : CAD2 F7F5              	dc.l	$CAD2F7F5
 8268/    3086 : 1D00                   	dc.w	29<<8						; 10**-30
 8269/    3088 : A242 5FF7              	dc.l	$A2425FF7
 8270/    308C : 1A00                   	dc.w	26<<8						; 10**-31
 8271/    308E : 81CE B32C              	dc.l	$81CEB32C
 8272/    3092 : 1600                   	dc.w	22<<8						; 10**-32
 8273/    3094 : CFB1 1EAD              	dc.l	$CFB11EAD
 8274/    3098 : 1300                   	dc.w	19<<8						; 10**-33
 8275/    309A : A627 4BBE              	dc.l	$A6274BBE
 8276/    309E : 1000                   	dc.w	16<<8						; 10**-34
 8277/    30A0 : 84EC 3C98              	dc.l	$84EC3C98
 8278/    30A4 : 0C00                   	dc.w	12<<8						; 10**-35
 8279/    30A6 : D4AD 2DC0              	dc.l	$D4AD2DC0
 8280/    30AA : 0900                   	dc.w	9<<8						; 10**-36
 8281/    30AC : AA24 2499              	dc.l	$AA242499
 8282/    30B0 : 0600                   	dc.w	6<<8						; 10**-37
 8283/    30B2 : 881C EA14              	dc.l	$881CEA14
 8284/    30B6 : 0200                   	dc.w	2<<8						; 10**-38
 8285/    30B8 : D9C7 DCED              	dc.l	$D9C7DCED
 8286/    30BC :                        
 8287/    30BC :                        
 8288/    30BC :                        ;************************************************************************************
 8289/    30BC :                        ;
 8290/    30BC :                        ; table of constants for cordic SIN/COS/TAN calculations
 8291/    30BC :                        ; constants are un normalised fractions and are atn(2^-i)/2pi
 8292/    30BC :                        
 8293/    30BC : 4DBA 76D4              	dc.l	$4DBA76D4					; SIN/COS multiply constant
 8294/    30C0 :                        TAB_SNCO
 8295/    30C0 : 2000 0000              	dc.l	$20000000					; atn(2^0)/2pi
 8296/    30C4 : 12E4 051E              	dc.l	$12E4051E					; atn(2^1)/2pi
 8297/    30C8 : 09FB 385C              	dc.l	$09FB385C					; atn(2^2)/2pi
 8298/    30CC : 0511 11D5              	dc.l	$051111D5					; atn(2^3)/2pi
 8299/    30D0 : 028B 0D44              	dc.l	$028B0D44					; atn(2^4)/2pi
 8300/    30D4 : 0145 D7E2              	dc.l	$0145D7E2					; atn(2^5)/2pi
 8301/    30D8 : 00A2 F61F              	dc.l	$00A2F61F					; atn(2^6)/2pi
 8302/    30DC : 0051 7C56              	dc.l	$00517C56					; atn(2^7)/2pi
 8303/    30E0 : 0028 BE54              	dc.l	$0028BE54					; atn(2^8)/2pi
 8304/    30E4 : 0014 5F2F              	dc.l	$00145F2F					; atn(2^9)/2pi
 8305/    30E8 : 000A 2F99              	dc.l	$000A2F99					; atn(2^10)/2pi
 8306/    30EC : 0005 17CD              	dc.l	$000517CD					; atn(2^11)/2pi
 8307/    30F0 : 0002 8BE7              	dc.l	$00028BE7					; atn(2^12)/2pi
 8308/    30F4 : 0001 45F4              	dc.l	$000145F4					; atn(2^13)/2pi
 8309/    30F8 : 0000 A2FA              	dc.l	$0000A2FA					; atn(2^14)/2pi
 8310/    30FC : 0000 517D              	dc.l	$0000517D					; atn(2^15)/2pi
 8311/    3100 : 0000 28BF              	dc.l	$000028BF					; atn(2^16)/2pi
 8312/    3104 : 0000 1460              	dc.l	$00001460					; atn(2^17)/2pi
 8313/    3108 : 0000 0A30              	dc.l	$00000A30					; atn(2^18)/2pi
 8314/    310C : 0000 0518              	dc.l	$00000518					; atn(2^19)/2pi
 8315/    3110 : 0000 028C              	dc.l	$0000028C					; atn(2^20)/2pi
 8316/    3114 : 0000 0146              	dc.l	$00000146					; atn(2^21)/2pi
 8317/    3118 : 0000 00A3              	dc.l	$000000A3					; atn(2^22)/2pi
 8318/    311C : 0000 0052              	dc.l	$00000052					; atn(2^23)/2pi
 8319/    3120 : 0000 0029              	dc.l	$00000029					; atn(2^24)/2pi
 8320/    3124 : 0000 0015              	dc.l	$00000015					; atn(2^25)/2pi
 8321/    3128 : 0000 000B              	dc.l	$0000000B					; atn(2^26)/2pi
 8322/    312C : 0000 0006              	dc.l	$00000006					; atn(2^27)/2pi
 8323/    3130 : 0000 0003              	dc.l	$00000003					; atn(2^28)/2pi
 8324/    3134 : 0000 0002              	dc.l	$00000002					; atn(2^29)/2pi
 8325/    3138 : 0000 0001              	dc.l	$00000001					; atn(2^30)/2pi
 8326/    313C : 0000 0001              	dc.l	$00000001					; atn(2^31)/2pi
 8327/    3140 :                        
 8328/    3140 :                        
 8329/    3140 :                        ;************************************************************************************
 8330/    3140 :                        ;
 8331/    3140 :                        ; table of constants for cordic ATN calculation
 8332/    3140 :                        ; constants are normalised to two integer bits and are atn(2^-i)
 8333/    3140 :                        
 8334/    3140 :                        TAB_ATNC
 8335/    3140 : 1DAC 6705              	dc.l	$1DAC6705					; atn(2^-1)
 8336/    3144 : 0FAD BAFD              	dc.l	$0FADBAFD					; atn(2^-2)
 8337/    3148 : 07F5 6EA7              	dc.l	$07F56EA7					; atn(2^-3)
 8338/    314C : 03FE AB77              	dc.l	$03FEAB77					; atn(2^-4)
 8339/    3150 : 01FF D55C              	dc.l	$01FFD55C					; atn(2^-5)
 8340/    3154 : 00FF FAAB              	dc.l	$00FFFAAB					; atn(2^-6)
 8341/    3158 : 007F FF55              	dc.l	$007FFF55					; atn(2^-7)
 8342/    315C : 003F FFEB              	dc.l	$003FFFEB					; atn(2^-8)
 8343/    3160 : 001F FFFD              	dc.l	$001FFFFD					; atn(2^-9)
 8344/    3164 : 0010 0000              	dc.l	$00100000					; atn(2^-10)
 8345/    3168 : 0008 0000              	dc.l	$00080000					; atn(2^-11)
 8346/    316C : 0004 0000              	dc.l	$00040000					; atn(2^-12)
 8347/    3170 : 0002 0000              	dc.l	$00020000					; atn(2^-13)
 8348/    3174 : 0001 0000              	dc.l	$00010000					; atn(2^-14)
 8349/    3178 : 0000 8000              	dc.l	$00008000					; atn(2^-15)
 8350/    317C : 0000 4000              	dc.l	$00004000					; atn(2^-16)
 8351/    3180 : 0000 2000              	dc.l	$00002000					; atn(2^-17)
 8352/    3184 : 0000 1000              	dc.l	$00001000					; atn(2^-18)
 8353/    3188 : 0000 0800              	dc.l	$00000800					; atn(2^-19)
 8354/    318C : 0000 0400              	dc.l	$00000400					; atn(2^-20)
 8355/    3190 : 0000 0200              	dc.l	$00000200					; atn(2^-21)
 8356/    3194 : 0000 0100              	dc.l	$00000100					; atn(2^-22)
 8357/    3198 : 0000 0080              	dc.l	$00000080					; atn(2^-23)
 8358/    319C : 0000 0040              	dc.l	$00000040					; atn(2^-24)
 8359/    31A0 : 0000 0020              	dc.l	$00000020					; atn(2^-25)
 8360/    31A4 : 0000 0010              	dc.l	$00000010					; atn(2^-26)
 8361/    31A8 : 0000 0008              	dc.l	$00000008					; atn(2^-27)
 8362/    31AC : 0000 0004              	dc.l	$00000004					; atn(2^-28)
 8363/    31B0 : 0000 0002              	dc.l	$00000002					; atn(2^-29)
 8364/    31B4 : 0000 0001              	dc.l	$00000001					; atn(2^-30)
 8365/    31B8 :                        LAB_1D96
 8366/    31B8 : 0000 0000              	dc.l	$00000000					; atn(2^-31)
 8367/    31BC : 0000 0000              	dc.l	$00000000					; atn(2^-32)
 8368/    31C0 :                        
 8369/    31C0 :                        ; constants are normalised to n integer bits and are tanh(2^-i)
 8370/    31C0 : =$2                    n	equ	2
 8371/    31C0 :                        TAB_HTHET
 8372/    31C0 : 2327 D4F4              	dc.l	$2327d4f4				; atnh(2^-1) .549306144
 8373/    31C4 : 1058 AEFA              	dc.l	$1058aefa				; atnh(2^-2) .255412812
 8374/    31C8 : 080A C48E              	dc.l	$080ac48e				; atnh(2^-3)
 8375/    31CC : 0401 5622              	dc.l	$04015622				; atnh(2^-4)
 8376/    31D0 : 0200 2AB0              	dc.l	$02002ab0				; atnh(2^-5)
 8377/    31D4 : 0100 0554              	dc.l	$01000554				; atnh(2^-6)
 8378/    31D8 : 0080 00AA              	dc.l	$008000aa				; atnh(2^-7)
 8379/    31DC : 0040 0014              	dc.l	$00400014				; atnh(2^-8)
 8380/    31E0 : 0020 0002              	dc.l	$00200002				; atnh(2^-9)
 8381/    31E4 : 0010 0000              	dc.l	$00100000				; atnh(2^-10)
 8382/    31E8 : 0008 0000              	dc.l	$00080000				; atnh(2^-11)
 8383/    31EC : 0004 0000              	dc.l	$00040000				; atnh(2^-12)
 8384/    31F0 : 0002 0000              	dc.l	$00020000				; atnh(2^-13)
 8385/    31F4 : 0001 0000              	dc.l	$00010000				; atnh(2^-14)
 8386/    31F8 : 0000 8000              	dc.l	$00008000				; atnh(2^-15)
 8387/    31FC : 0000 4000              	dc.l	$00004000				; atnh(2^-16)
 8388/    3200 : 0000 2000              	dc.l	$00002000				; atnh(2^-17)
 8389/    3204 : 0000 1000              	dc.l	$00001000				; atnh(2^-18)
 8390/    3208 : 0000 0800              	dc.l	$00000800				; atnh(2^-19)
 8391/    320C : 0000 0400              	dc.l	$00000400				; atnh(2^-20)
 8392/    3210 : 0000 0200              	dc.l	$00000200				; atnh(2^-21)
 8393/    3214 : 0000 0100              	dc.l	$00000100				; atnh(2^-22)
 8394/    3218 : 0000 0080              	dc.l	$00000080				; atnh(2^-23)
 8395/    321C : 0000 0040              	dc.l	$00000040				; atnh(2^-24)
 8396/    3220 : 0000 0020              	dc.l	$00000020				; atnh(2^-25)
 8397/    3224 : 0000 0010              	dc.l	$00000010				; atnh(2^-26)
 8398/    3228 : 0000 0008              	dc.l	$00000008				; atnh(2^-27)
 8399/    322C : 0000 0004              	dc.l	$00000004				; atnh(2^-28)
 8400/    3230 : 0000 0002              	dc.l	$00000002				; atnh(2^-29)
 8401/    3234 : 0000 0001              	dc.l	$00000001				; atnh(2^-30)
 8402/    3238 : 0000 0000              	dc.l	$00000000				; atnh(2^-31)
 8403/    323C : 0000 0000              	dc.l	$00000000				; atnh(2^-32)
 8404/    3240 : =$26A3D110             KFCTSEED	equ	$26A3D110			; $26A3D110
 8405/    3240 :                        
 8406/    3240 :                        
 8407/    3240 :                        ;************************************************************************************
 8408/    3240 :                        ;
 8409/    3240 :                        ; command vector table
 8410/    3240 :                        
 8411/    3240 :                        LAB_CTBL
 8412/    3240 : D79E                   	dc.w	LAB_END-LAB_CTBL				; END
 8413/    3242 : D6D2                   	dc.w	LAB_FOR-LAB_CTBL				; FOR
 8414/    3244 : DD44                   	dc.w	LAB_NEXT-LAB_CTBL				; NEXT
 8415/    3246 : D8F2                   	dc.w	LAB_DATA-LAB_CTBL				; DATA
 8416/    3248 : DC38                   	dc.w	LAB_INPUT-LAB_CTBL			; INPUT
 8417/    324A : E116                   	dc.w	LAB_DIM-LAB_CTBL				; DIM
 8418/    324C : DC5E                   	dc.w	LAB_READ-LAB_CTBL				; READ
 8419/    324E : DA6A                   	dc.w	LAB_LET-LAB_CTBL				; LET
 8420/    3250 : DA06                   	dc.w	LAB_DEC-LAB_CTBL				; DEC	
 8421/    3252 : D85A                   	dc.w	LAB_GOTO-LAB_CTBL				; GOTO
 8422/    3254 : D822                   	dc.w	LAB_RUN-LAB_CTBL				; RUN
 8423/    3256 : D91A                   	dc.w	LAB_IF-LAB_CTBL				; IF
 8424/    3258 : D7CC                   	dc.w	LAB_RESTORE-LAB_CTBL			; RESTORE
 8425/    325A : D848                   	dc.w	LAB_GOSUB-LAB_CTBL			; GOSUB
 8426/    325C : D8DE                   	dc.w	LAB_RETURN-LAB_CTBL			; RETURN
 8427/    325E : D98C                   	dc.w	LAB_REM-LAB_CTBL				; REM
 8428/    3260 : D7A6                   	dc.w	LAB_STOP-LAB_CTBL				; STOP
 8429/    3262 : D994                   	dc.w	LAB_ON-LAB_CTBL				; ON
 8430/    3264 : D7FA                   	dc.w	LAB_NULL-LAB_CTBL				; NULL
 8431/    3266 : DA0C                   	dc.w	LAB_INC-LAB_CTBL				; INC	
 8432/    3268 : EA1E                   	dc.w	LAB_WAIT-LAB_CTBL				; WAIT
 8433/    326A : EA0C                   	dc.w	LAB_LOAD-LAB_CTBL				; LOAD
 8434/    326C : EA10                   	dc.w	LAB_SAVE-LAB_CTBL				; SAVE
 8435/    326E : E4A6                   	dc.w	LAB_DEF-LAB_CTBL				; DEF
 8436/    3270 : E98C                   	dc.w	LAB_POKE-LAB_CTBL				; POKE
 8437/    3272 : E9BC                   	dc.w	LAB_DOKE-LAB_CTBL				; DOKE
 8438/    3274 : E9C2                   	dc.w	LAB_LOKE-LAB_CTBL				; LOKE
 8439/    3276 : EA14                   	dc.w	LAB_CALL-LAB_CTBL				; CALL
 8440/    3278 : D836                   	dc.w	LAB_DO-LAB_CTBL				; DO	
 8441/    327A : D888                   	dc.w	LAB_LOOP-LAB_CTBL				; LOOP
 8442/    327C : DAFE                   	dc.w	LAB_PRINT-LAB_CTBL			; PRINT
 8443/    327E : D804                   	dc.w	LAB_CONT-LAB_CTBL				; CONT
 8444/    3280 : D61C                   	dc.w	LAB_LIST-LAB_CTBL				; LIST
 8445/    3282 : D618                   	dc.w	LAB_CLEAR-LAB_CTBL			; CLEAR
 8446/    3284 : D5C6                   	dc.w	LAB_NEW-LAB_CTBL				; NEW
 8447/    3286 : F954                   	dc.w	LAB_WDTH-LAB_CTBL				; WIDTH
 8448/    3288 : DAC4                   	dc.w	LAB_GET-LAB_CTBL				; GET
 8449/    328A : E9D6                   	dc.w	LAB_SWAP-LAB_CTBL				; SWAP
 8450/    328C : F49E                   	dc.w	LAB_BITSET-LAB_CTBL			; BITSET
 8451/    328E : F4AE                   	dc.w	LAB_BITCLR-LAB_CTBL			; BITCLR
 8452/    3290 :                        
 8453/    3290 :                        
 8454/    3290 :                        ;************************************************************************************
 8455/    3290 :                        ;
 8456/    3290 :                        ; function pre process routine table
 8457/    3290 :                        
 8458/    3290 :                        LAB_FTPP
 8459/    3290 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SGN(n)	process numeric expression in ()
 8460/    3292 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; INT(n)		"
 8461/    3294 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; ABS(n)		"
 8462/    3296 : DDC4                   	dc.w	LAB_EVEZ-LAB_FTPP				; USR(x)	process any expression
 8463/    3298 : DF0C                   	dc.w	LAB_1BF7-LAB_FTPP				; FRE(x)	process any expression in ()
 8464/    329A : DF0C                   	dc.w	LAB_1BF7-LAB_FTPP				; POS(x)		"
 8465/    329C : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SQR(n)	process numeric expression in ()
 8466/    329E : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; RND(n)		"
 8467/    32A0 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; LOG(n)		"
 8468/    32A2 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; EXP(n)		"
 8469/    32A4 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; COS(n)		"
 8470/    32A6 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SIN(n)		"
 8471/    32A8 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; TAN(n)		"
 8472/    32AA : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; ATN(n)		"
 8473/    32AC : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; PEEK(n)		"
 8474/    32AE : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; DEEK(n)		"
 8475/    32B0 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; LEEK(n)		"
 8476/    32B2 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; LEN($)	process string expression in ()
 8477/    32B4 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; STR$(n)	process numeric expression in ()
 8478/    32B6 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; VAL($)	process string expression in ()
 8479/    32B8 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; ASC($)		"
 8480/    32BA : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; UCASE$($)		"
 8481/    32BC : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; LCASE$($)		"
 8482/    32BE : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; CHR$(n)	process numeric expression in ()
 8483/    32C0 : DFFE                   	dc.w	LAB_BHSS-LAB_FTPP				; HEX$()	bin/hex pre process
 8484/    32C2 : DFFE                   	dc.w	LAB_BHSS-LAB_FTPP				; BIN$()		"
 8485/    32C4 : 0000                   	dc.w	$0000						; BITTST()	none
 8486/    32C6 : 0000                   	dc.w	$0000						; MAX()		"
 8487/    32C8 : 0000                   	dc.w	$0000						; MIN()		"
 8488/    32CA : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; RAMBASE	advance pointer
 8489/    32CC : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; PI			"
 8490/    32CE : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; TWOPI		"
 8491/    32D0 : 0000                   	dc.w	$0000						; VARPTR()	none
 8492/    32D2 : 0000                   	dc.w	$0000						; SADD()		"
 8493/    32D4 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; LEFT$()	process string expression
 8494/    32D6 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; RIGHT$()		"
 8495/    32D8 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; MID$()		"
 8496/    32DA : DDC4                   	dc.w	LAB_EVEZ-LAB_FTPP				; USING$(x)	process any expression
 8497/    32DC :                        
 8498/    32DC :                        
 8499/    32DC :                        ;************************************************************************************
 8500/    32DC :                        ;
 8501/    32DC :                        ; action addresses for functions
 8502/    32DC :                        
 8503/    32DC :                        LAB_FTBL
 8504/    32DC : ED4A                   	dc.w	LAB_SGN-LAB_FTBL				; SGN()
 8505/    32DE : EDCE                   	dc.w	LAB_INT-LAB_FTBL				; INT()
 8506/    32E0 : ED5C                   	dc.w	LAB_ABS-LAB_FTBL				; ABS()
 8507/    32E2 : E968                   	dc.w	LAB_USR-LAB_FTBL				; USR()
 8508/    32E4 : E3C2                   	dc.w	LAB_FRE-LAB_FTBL				; FRE()
 8509/    32E6 : E3F4                   	dc.w	LAB_POS-LAB_FTBL				; POS()
 8510/    32E8 : F938                   	dc.w	LAB_SQR-LAB_FTBL				; SQR()
 8511/    32EA : F21C                   	dc.w	LAB_RND-LAB_FTBL				; RND()
 8512/    32EC : EA6C                   	dc.w	LAB_LOG-LAB_FTBL				; LOG()
 8513/    32EE : F102                   	dc.w	LAB_EXP-LAB_FTBL				; EXP()
 8514/    32F0 : F270                   	dc.w	LAB_COS-LAB_FTBL				; COS()
 8515/    32F2 : F288                   	dc.w	LAB_SIN-LAB_FTBL				; SIN()
 8516/    32F4 : F24E                   	dc.w	LAB_TAN-LAB_FTBL				; TAN()
 8517/    32F6 : F34E                   	dc.w	LAB_ATN-LAB_FTBL				; ATN()
 8518/    32F8 : E8E4                   	dc.w	LAB_PEEK-LAB_FTBL				; PEEK()
 8519/    32FA : E8F6                   	dc.w	LAB_DEEK-LAB_FTBL				; DEEK()
 8520/    32FC : E90C                   	dc.w	LAB_LEEK-LAB_FTBL				; LEEK()
 8521/    32FE : E826                   	dc.w	LAB_LENS-LAB_FTBL				; LEN()
 8522/    3300 : E4EA                   	dc.w	LAB_STRS-LAB_FTBL				; STR$()
 8523/    3302 : E86C                   	dc.w	LAB_VAL-LAB_FTBL				; VAL()
 8524/    3304 : E82E                   	dc.w	LAB_ASC-LAB_FTBL				; ASC()
 8525/    3306 : E7DC                   	dc.w	LAB_UCASE-LAB_FTBL			; UCASE$()
 8526/    3308 : E7AC                   	dc.w	LAB_LCASE-LAB_FTBL			; LCASE$()
 8527/    330A : E714                   	dc.w	LAB_CHRS-LAB_FTBL				; CHR$()
 8528/    330C : F7DA                   	dc.w	LAB_HEXS-LAB_FTBL				; HEX$()
 8529/    330E : F788                   	dc.w	LAB_BINS-LAB_FTBL				; BIN$()
 8530/    3310 : F422                   	dc.w	LAB_BTST-LAB_FTBL				; BITTST()
 8531/    3312 : F846                   	dc.w	LAB_MAX-LAB_FTBL				; MAX()
 8532/    3314 : F85C                   	dc.w	LAB_MIN-LAB_FTBL				; MIN()
 8533/    3316 : F9AA                   	dc.w	LAB_RAM-LAB_FTBL				; RAMBASE
 8534/    3318 : F9B4                   	dc.w	LAB_PI-LAB_FTBL				; PI
 8535/    331A : F9C4                   	dc.w	LAB_TWOPI-LAB_FTBL			; TWOPI
 8536/    331C : F99A                   	dc.w	LAB_VARPTR-LAB_FTBL			; VARPTR()
 8537/    331E : E80E                   	dc.w	LAB_SADD-LAB_FTBL				; SADD()
 8538/    3320 : E724                   	dc.w	LAB_LEFT-LAB_FTBL				; LEFT$()
 8539/    3322 : E738                   	dc.w	LAB_RIGHT-LAB_FTBL			; RIGHT$()
 8540/    3324 : E768                   	dc.w	LAB_MIDS-LAB_FTBL				; MID$()
 8541/    3326 : F450                   	dc.w	LAB_USINGS-LAB_FTBL			; USING$()
 8542/    3328 :                        
 8543/    3328 :                        
 8544/    3328 :                        ;************************************************************************************
 8545/    3328 :                        ;
 8546/    3328 :                        ; hierarchy and action addresses for operator
 8547/    3328 :                        
 8548/    3328 :                        LAB_OPPT
 8549/    3328 : 0079                   	dc.w	$0079						; +
 8550/    332A : E96E                   	dc.w	LAB_ADD-LAB_OPPT
 8551/    332C : 0079                   	dc.w	$0079						; -
 8552/    332E : E95A                   	dc.w	LAB_SUBTRACT-LAB_OPPT
 8553/    3330 : 007B                   	dc.w	$007B						; *
 8554/    3332 : EB12                   	dc.w	LAB_MULTIPLY-LAB_OPPT
 8555/    3334 : 007B                   	dc.w	$007B						; /
 8556/    3336 : EB9E                   	dc.w	LAB_DIVIDE-LAB_OPPT
 8557/    3338 : 007F                   	dc.w	$007F						; ^
 8558/    333A : F000                   	dc.w	LAB_POWER-LAB_OPPT
 8559/    333C : 0050                   	dc.w	$0050						; AND
 8560/    333E : DFA6                   	dc.w	LAB_AND-LAB_OPPT
 8561/    3340 : 0046                   	dc.w	$0046						; EOR
 8562/    3342 : DF96                   	dc.w	LAB_EOR-LAB_OPPT
 8563/    3344 : 0046                   	dc.w	$0046						; OR
 8564/    3346 : DF9E                   	dc.w	LAB_OR-LAB_OPPT
 8565/    3348 : 0056                   	dc.w	$0056						; >>
 8566/    334A : E04A                   	dc.w	LAB_RSHIFT-LAB_OPPT
 8567/    334C : 0056                   	dc.w	$0056						; <<
 8568/    334E : E03A                   	dc.w	LAB_LSHIFT-LAB_OPPT
 8569/    3350 : 007D                   	dc.w	$007D						; >
 8570/    3352 : F064                   	dc.w	LAB_GTHAN-LAB_OPPT			; used to evaluate -n
 8571/    3354 : 005A                   	dc.w	$005A						; =
 8572/    3356 : DFBC                   	dc.w	LAB_EQUAL-LAB_OPPT			; used to evaluate NOT
 8573/    3358 : 0064                   	dc.w	$0064						; <
 8574/    335A : DFC6                   	dc.w	LAB_LTHAN-LAB_OPPT
 8575/    335C :                        
 8576/    335C :                        
 8577/    335C :                        ;************************************************************************************
 8578/    335C :                        ;
 8579/    335C :                        ; misc constants
 8580/    335C :                        
 8581/    335C :                        ; This table is used in converting numbers to ASCII.
 8582/    335C :                        ; first four entries for expansion to 9.25 digits
 8583/    335C :                        
 8584/    335C :                        LAB_2A9A
 8585/    335C : FFF0 BDC0              	dc.l	$FFF0BDC0					; -1000000
 8586/    3360 : 0001 86A0              	dc.l	$000186A0					; 100000
 8587/    3364 : FFFF D8F0              	dc.l	$FFFFD8F0					; -10000
 8588/    3368 : 0000 03E8              	dc.l	$000003E8					; 1000
 8589/    336C : FFFF FF9C              	dc.l	$FFFFFF9C					; -100
 8590/    3370 : 0000 000A              	dc.l	$0000000A					; 10
 8591/    3374 : FFFF FFFF              	dc.l	$FFFFFFFF					; -1
 8592/    3378 :                        LAB_2A9B
 8593/    3378 :                        
 8594/    3378 :                        
 8595/    3378 :                        ;************************************************************************************
 8596/    3378 :                        ;
 8597/    3378 :                        ; new keyword tables
 8598/    3378 :                        
 8599/    3378 :                        ; offsets to keyword tables
 8600/    3378 :                        
 8601/    3378 :                        TAB_CHRT
 8602/    3378 : 0000                   	dc.w	TAB_STAR-TAB_STAR				; "*"	$2A
 8603/    337A : 0002                   	dc.w	TAB_PLUS-TAB_STAR				; "+"	$2B
 8604/    337C : FFFF                   	dc.w	-1						; "," $2C no keywords
 8605/    337E : 0004                   	dc.w	TAB_MNUS-TAB_STAR				; "-"	$2D
 8606/    3380 : FFFF                   	dc.w	-1						; "." $2E no keywords
 8607/    3382 : 0006                   	dc.w	TAB_SLAS-TAB_STAR				; "/"	$2F
 8608/    3384 : FFFF                   	dc.w	-1						; "0" $30 no keywords
 8609/    3386 : FFFF                   	dc.w	-1						; "1" $31 no keywords
 8610/    3388 : FFFF                   	dc.w	-1						; "2" $32 no keywords
 8611/    338A : FFFF                   	dc.w	-1						; "3" $33 no keywords
 8612/    338C : FFFF                   	dc.w	-1						; "4" $34 no keywords
 8613/    338E : FFFF                   	dc.w	-1						; "5" $35 no keywords
 8614/    3390 : FFFF                   	dc.w	-1						; "6" $36 no keywords
 8615/    3392 : FFFF                   	dc.w	-1						; "7" $37 no keywords
 8616/    3394 : FFFF                   	dc.w	-1						; "8" $38 no keywords
 8617/    3396 : FFFF                   	dc.w	-1						; "9" $39 no keywords
 8618/    3398 : FFFF                   	dc.w	-1						; ";" $3A no keywords
 8619/    339A : FFFF                   	dc.w	-1						; ":" $3B no keywords
 8620/    339C : 0008                   	dc.w	TAB_LESS-TAB_STAR				; "<"	$3C
 8621/    339E : 000C                   	dc.w	TAB_EQUL-TAB_STAR				; "="	$3D
 8622/    33A0 : 000E                   	dc.w	TAB_MORE-TAB_STAR				; ">"	$3E
 8623/    33A2 : 0012                   	dc.w	TAB_QEST-TAB_STAR				; "?"	$3F
 8624/    33A4 : FFFF                   	dc.w	-1						; "@" $40 no keywords
 8625/    33A6 : 0014                   	dc.w	TAB_ASCA-TAB_STAR				; "A"	$41
 8626/    33A8 : 0024                   	dc.w	TAB_ASCB-TAB_STAR				; "B"	$42
 8627/    33AA : 003D                   	dc.w	TAB_ASCC-TAB_STAR				; "C"	$43
 8628/    33AC : 0054                   	dc.w	TAB_ASCD-TAB_STAR				; "D"	$44
 8629/    33AE : 006D                   	dc.w	TAB_ASCE-TAB_STAR				; "E"	$45
 8630/    33B0 : 007C                   	dc.w	TAB_ASCF-TAB_STAR				; "F"	$46
 8631/    33B2 : 0086                   	dc.w	TAB_ASCG-TAB_STAR				; "G"	$47
 8632/    33B4 : 0093                   	dc.w	TAB_ASCH-TAB_STAR				; "H"	$48
 8633/    33B6 : 0099                   	dc.w	TAB_ASCI-TAB_STAR				; "I"	$49
 8634/    33B8 : FFFF                   	dc.w	-1						; "J" $4A no keywords
 8635/    33BA : FFFF                   	dc.w	-1						; "K" $4B no keywords
 8636/    33BC : 00A8                   	dc.w	TAB_ASCL-TAB_STAR				; "L"	$4C
 8637/    33BE : 00D6                   	dc.w	TAB_ASCM-TAB_STAR				; "M"	$4D
 8638/    33C0 : 00E4                   	dc.w	TAB_ASCN-TAB_STAR				; "N"	$4E
 8639/    33C2 : 00F3                   	dc.w	TAB_ASCO-TAB_STAR				; "O"	$4F
 8640/    33C4 : 00F8                   	dc.w	TAB_ASCP-TAB_STAR				; "P"	$50
 8641/    33C6 : FFFF                   	dc.w	-1						; "Q" $51 no keywords
 8642/    33C8 : 010D                   	dc.w	TAB_ASCR-TAB_STAR				; "R"	$52
 8643/    33CA : 0137                   	dc.w	TAB_ASCS-TAB_STAR				; "S"	$53
 8644/    33CC : 0162                   	dc.w	TAB_ASCT-TAB_STAR				; "T"	$54
 8645/    33CE : 0176                   	dc.w	TAB_ASCU-TAB_STAR				; "U"	$55
 8646/    33D0 : 018E                   	dc.w	TAB_ASCV-TAB_STAR				; "V"	$56
 8647/    33D2 : 019A                   	dc.w	TAB_ASCW-TAB_STAR				; "W"	$57
 8648/    33D4 : FFFF                   	dc.w	-1						; "X" $58 no keywords
 8649/    33D6 : FFFF                   	dc.w	-1						; "Y" $59 no keywords
 8650/    33D8 : FFFF                   	dc.w	-1						; "Z" $5A no keywords
 8651/    33DA : FFFF                   	dc.w	-1						; "[" $5B no keywords
 8652/    33DC : FFFF                   	dc.w	-1						; "\" $5C no keywords
 8653/    33DE : FFFF                   	dc.w	-1						; "]" $5D no keywords
 8654/    33E0 : 01A9                   	dc.w	TAB_POWR-TAB_STAR				; "^"	$5E
 8655/    33E2 :                        
 8656/    33E2 :                        
 8657/    33E2 :                        ;************************************************************************************
 8658/    33E2 :                        ;
 8659/    33E2 :                        ; Table of Basic keywords for LIST command
 8660/    33E2 :                        ; [byte]first character,[byte]remaining length -1
 8661/    33E2 :                        ; [word]offset from table start
 8662/    33E2 :                        
 8663/    33E2 :                        LAB_KEYT
 8664/    33E2 : 4501                   	dc.b	'E',1
 8665/    33E4 : 0071                   	dc.w	KEY_END-TAB_STAR				; END
 8666/    33E6 : 4601                   	dc.b	'F',1
 8667/    33E8 : 007C                   	dc.w	KEY_FOR-TAB_STAR				; FOR
 8668/    33EA : 4E02                   	dc.b	'N',2
 8669/    33EC : 00E7                   	dc.w	KEY_NEXT-TAB_STAR				; NEXT
 8670/    33EE : 4402                   	dc.b	'D',2
 8671/    33F0 : 0054                   	dc.w	KEY_DATA-TAB_STAR				; DATA
 8672/    33F2 : 4903                   	dc.b	'I',3
 8673/    33F4 : 009E                   	dc.w	KEY_INPUT-TAB_STAR			; INPUT
 8674/    33F6 : 4401                   	dc.b	'D',1
 8675/    33F8 : 0063                   	dc.w	KEY_DIM-TAB_STAR				; DIM
 8676/    33FA : 5202                   	dc.b	'R',2
 8677/    33FC : 0114                   	dc.w	KEY_READ-TAB_STAR				; READ
 8678/    33FE : 4C01                   	dc.b	'L',1
 8679/    3400 : 00BE                   	dc.w	KEY_LET-TAB_STAR				; LET
 8680/    3402 : 4401                   	dc.b	'D',1
 8681/    3404 : 0058                   	dc.w	KEY_DEC-TAB_STAR				; DEC
 8682/    3406 : 4702                   	dc.b	'G',2
 8683/    3408 : 0089                   	dc.w	KEY_GOTO-TAB_STAR				; GOTO
 8684/    340A : 5201                   	dc.b	'R',1
 8685/    340C : 0133                   	dc.w	KEY_RUN-TAB_STAR				; RUN
 8686/    340E : 4900                   	dc.b	'I',0
 8687/    3410 : 0099                   	dc.w	KEY_IF-TAB_STAR				; IF
 8688/    3412 : 5205                   	dc.b	'R',5
 8689/    3414 : 011B                   	dc.w	KEY_RESTORE-TAB_STAR			; RESTORE
 8690/    3416 : 4703                   	dc.b	'G',3
 8691/    3418 : 008D                   	dc.w	KEY_GOSUB-TAB_STAR			; GOSUB
 8692/    341A : 5204                   	dc.b	'R',4
 8693/    341C : 0122                   	dc.w	KEY_RETURN-TAB_STAR			; RETURN
 8694/    341E : 5201                   	dc.b	'R',1
 8695/    3420 : 0118                   	dc.w	KEY_REM-TAB_STAR				; REM
 8696/    3422 : 5302                   	dc.b	'S',2
 8697/    3424 : 0154                   	dc.w	KEY_STOP-TAB_STAR				; STOP
 8698/    3426 : 4F00                   	dc.b	'O',0
 8699/    3428 : 00F3                   	dc.w	KEY_ON-TAB_STAR				; ON
 8700/    342A : 4E02                   	dc.b	'N',2
 8701/    342C : 00EE                   	dc.w	KEY_NULL-TAB_STAR				; NULL
 8702/    342E : 4901                   	dc.b	'I',1
 8703/    3430 : 009B                   	dc.w	KEY_INC-TAB_STAR				; INC
 8704/    3432 : 5702                   	dc.b	'W',2
 8705/    3434 : 019A                   	dc.w	KEY_WAIT-TAB_STAR				; WAIT
 8706/    3436 : 4C02                   	dc.b	'L',2
 8707/    3438 : 00C5                   	dc.w	KEY_LOAD-TAB_STAR				; LOAD
 8708/    343A : 5302                   	dc.b	'S',2
 8709/    343C : 013C                   	dc.w	KEY_SAVE-TAB_STAR				; SAVE
 8710/    343E : 4401                   	dc.b	'D',1
 8711/    3440 : 0060                   	dc.w	KEY_DEF-TAB_STAR				; DEF
 8712/    3442 : 5002                   	dc.b	'P',2
 8713/    3444 : 00FF                   	dc.w	KEY_POKE-TAB_STAR				; POKE
 8714/    3446 : 4402                   	dc.b	'D',2
 8715/    3448 : 0066                   	dc.w	KEY_DOKE-TAB_STAR				; DOKE
 8716/    344A : 4C02                   	dc.b	'L',2
 8717/    344C : 00CD                   	dc.w	KEY_LOKE-TAB_STAR				; LOKE
 8718/    344E : 4302                   	dc.b	'C',2
 8719/    3450 : 003D                   	dc.w	KEY_CALL-TAB_STAR				; CALL
 8720/    3452 : 4400                   	dc.b	'D',0
 8721/    3454 : 006A                   	dc.w	KEY_DO-TAB_STAR				; DO
 8722/    3456 : 4C02                   	dc.b	'L',2
 8723/    3458 : 00D1                   	dc.w	KEY_LOOP-TAB_STAR				; LOOP
 8724/    345A : 5003                   	dc.b	'P',3
 8725/    345C : 0107                   	dc.w	KEY_PRINT-TAB_STAR			; PRINT
 8726/    345E : 4302                   	dc.b	'C',2
 8727/    3460 : 004B                   	dc.w	KEY_CONT-TAB_STAR				; CONT
 8728/    3462 : 4C02                   	dc.b	'L',2
 8729/    3464 : 00C1                   	dc.w	KEY_LIST-TAB_STAR				; LIST
 8730/    3466 : 4303                   	dc.b	'C',3
 8731/    3468 : 0046                   	dc.w	KEY_CLEAR-TAB_STAR			; CLEAR
 8732/    346A : 4E01                   	dc.b	'N',1
 8733/    346C : 00E4                   	dc.w	KEY_NEW-TAB_STAR				; NEW
 8734/    346E : 5703                   	dc.b	'W',3
 8735/    3470 : 01A3                   	dc.w	KEY_WIDTH-TAB_STAR			; WIDTH
 8736/    3472 : 4701                   	dc.b	'G',1
 8737/    3474 : 0086                   	dc.w	KEY_GET-TAB_STAR				; GET
 8738/    3476 : 5302                   	dc.b	'S',2
 8739/    3478 : 015D                   	dc.w	KEY_SWAP-TAB_STAR				; SWAP
 8740/    347A : 4204                   	dc.b	'B',4
 8741/    347C : 002F                   	dc.w	KEY_BITSET-TAB_STAR			; BITSET
 8742/    347E : 4204                   	dc.b	'B',4
 8743/    3480 : 0029                   	dc.w	KEY_BITCLR-TAB_STAR			; BITCLR
 8744/    3482 : 5402                   	dc.b	'T',2
 8745/    3484 : 0162                   	dc.w	KEY_TAB-TAB_STAR				; TAB(
 8746/    3486 : 4502                   	dc.b	'E',2
 8747/    3488 : 006D                   	dc.w	KEY_ELSE-TAB_STAR				; ELSE
 8748/    348A : 5400                   	dc.b	'T',0
 8749/    348C : 016E                   	dc.w	KEY_TO-TAB_STAR				; TO
 8750/    348E : 4600                   	dc.b	'F',0
 8751/    3490 : 007F                   	dc.w	KEY_FN-TAB_STAR				; FN
 8752/    3492 : 5302                   	dc.b	'S',2
 8753/    3494 : 0148                   	dc.w	KEY_SPC-TAB_STAR				; SPC(
 8754/    3496 : 5402                   	dc.b	'T',2
 8755/    3498 : 016A                   	dc.w	KEY_THEN-TAB_STAR				; THEN
 8756/    349A : 4E01                   	dc.b	'N',1
 8757/    349C : 00EB                   	dc.w	KEY_NOT-TAB_STAR				; NOT
 8758/    349E : 5302                   	dc.b	'S',2
 8759/    34A0 : 0150                   	dc.w	KEY_STEP-TAB_STAR				; STEP
 8760/    34A2 : 5503                   	dc.b	'U',3
 8761/    34A4 : 017D                   	dc.w	KEY_UNTIL-TAB_STAR			; UNTIL
 8762/    34A6 : 5703                   	dc.b	'W',3
 8763/    34A8 : 019E                   	dc.w	KEY_WHILE-TAB_STAR			; WHILE
 8764/    34AA :                        
 8765/    34AA : 2BFF                   	dc.b	'+',-1
 8766/    34AC : 0002                   	dc.w	KEY_PLUS-TAB_STAR				; +
 8767/    34AE : 2DFF                   	dc.b	'-',-1
 8768/    34B0 : 0004                   	dc.w	KEY_MINUS-TAB_STAR			; -
 8769/    34B2 : 2AFF                   	dc.b	'*',-1
 8770/    34B4 : 0000                   	dc.w	KEY_MULT-TAB_STAR				; *
 8771/    34B6 : 2FFF                   	dc.b	'/',-1
 8772/    34B8 : 0006                   	dc.w	KEY_DIV-TAB_STAR				; /
 8773/    34BA : 5EFF                   	dc.b	'^',-1
 8774/    34BC : 01A9                   	dc.w	KEY_POWER-TAB_STAR			; ^
 8775/    34BE : 4101                   	dc.b	'A',1
 8776/    34C0 : 0018                   	dc.w	KEY_AND-TAB_STAR				; AND
 8777/    34C2 : 4501                   	dc.b	'E',1
 8778/    34C4 : 0074                   	dc.w	KEY_EOR-TAB_STAR				; EOR
 8779/    34C6 : 4F00                   	dc.b	'O',0
 8780/    34C8 : 00F5                   	dc.w	KEY_OR-TAB_STAR				; OR
 8781/    34CA : 3E00                   	dc.b	'>',0
 8782/    34CC : 000E                   	dc.w	KEY_RSHIFT-TAB_STAR			; >>
 8783/    34CE : 3C00                   	dc.b	'<',0
 8784/    34D0 : 0008                   	dc.w	KEY_LSHIFT-TAB_STAR			; <<
 8785/    34D2 : 3EFF                   	dc.b	'>',-1
 8786/    34D4 : 0010                   	dc.w	KEY_GT-TAB_STAR				; >
 8787/    34D6 : 3DFF                   	dc.b	'=',-1
 8788/    34D8 : 000C                   	dc.w	KEY_EQUAL-TAB_STAR			; =
 8789/    34DA : 3CFF                   	dc.b	'<',-1
 8790/    34DC : 000A                   	dc.w	KEY_LT-TAB_STAR				; <
 8791/    34DE :                        
 8792/    34DE : 5302                   	dc.b	'S',2
 8793/    34E0 : 0140                   	dc.w	KEY_SGN-TAB_STAR				; SGN(
 8794/    34E2 : 4902                   	dc.b	'I',2
 8795/    34E4 : 00A3                   	dc.w	KEY_INT-TAB_STAR				; INT(
 8796/    34E6 : 4102                   	dc.b	'A',2
 8797/    34E8 : 0014                   	dc.w	KEY_ABS-TAB_STAR				; ABS(
 8798/    34EA : 5502                   	dc.b	'U',2
 8799/    34EC : 0189                   	dc.w	KEY_USR-TAB_STAR				; USR(
 8800/    34EE : 4602                   	dc.b	'F',2
 8801/    34F0 : 0081                   	dc.w	KEY_FRE-TAB_STAR				; FRE(
 8802/    34F2 : 5002                   	dc.b	'P',2
 8803/    34F4 : 0103                   	dc.w	KEY_POS-TAB_STAR				; POS(
 8804/    34F6 : 5302                   	dc.b	'S',2
 8805/    34F8 : 014C                   	dc.w	KEY_SQR-TAB_STAR				; SQR(
 8806/    34FA : 5202                   	dc.b	'R',2
 8807/    34FC : 012F                   	dc.w	KEY_RND-TAB_STAR				; RND(
 8808/    34FE : 4C02                   	dc.b	'L',2
 8809/    3500 : 00C9                   	dc.w	KEY_LOG-TAB_STAR				; LOG(
 8810/    3502 : 4502                   	dc.b	'E',2
 8811/    3504 : 0077                   	dc.w	KEY_EXP-TAB_STAR				; EXP(
 8812/    3506 : 4302                   	dc.b	'C',2
 8813/    3508 : 004F                   	dc.w	KEY_COS-TAB_STAR				; COS(
 8814/    350A : 5302                   	dc.b	'S',2
 8815/    350C : 0144                   	dc.w	KEY_SIN-TAB_STAR				; SIN(
 8816/    350E : 5402                   	dc.b	'T',2
 8817/    3510 : 0166                   	dc.w	KEY_TAN-TAB_STAR				; TAN(
 8818/    3512 : 4102                   	dc.b	'A',2
 8819/    3514 : 001F                   	dc.w	KEY_ATN-TAB_STAR				; ATN(
 8820/    3516 : 5003                   	dc.b	'P',3
 8821/    3518 : 00F8                   	dc.w	KEY_PEEK-TAB_STAR				; PEEK(
 8822/    351A : 4403                   	dc.b	'D',3
 8823/    351C : 005B                   	dc.w	KEY_DEEK-TAB_STAR				; DEEK(
 8824/    351E : 4C03                   	dc.b	'L',3
 8825/    3520 : 00AF                   	dc.w	KEY_LEEK-TAB_STAR				; LEEK(
 8826/    3522 : 4C02                   	dc.b	'L',2
 8827/    3524 : 00BA                   	dc.w	KEY_LEN-TAB_STAR				; LEN(
 8828/    3526 : 5303                   	dc.b	'S',3
 8829/    3528 : 0158                   	dc.w	KEY_STRS-TAB_STAR				; STR$(
 8830/    352A : 5602                   	dc.b	'V',2
 8831/    352C : 018E                   	dc.w	KEY_VAL-TAB_STAR				; VAL(
 8832/    352E : 4102                   	dc.b	'A',2
 8833/    3530 : 001B                   	dc.w	KEY_ASC-TAB_STAR				; ASC(
 8834/    3532 : 5505                   	dc.b	'U',5
 8835/    3534 : 0176                   	dc.w	KEY_UCASES-TAB_STAR			; UCASE$(
 8836/    3536 : 4C05                   	dc.b	'L',5
 8837/    3538 : 00A8                   	dc.w	KEY_LCASES-TAB_STAR			; LCASE$(
 8838/    353A : 4303                   	dc.b	'C',3
 8839/    353C : 0041                   	dc.w	KEY_CHRS-TAB_STAR				; CHR$(
 8840/    353E : 4803                   	dc.b	'H',3
 8841/    3540 : 0093                   	dc.w	KEY_HEXS-TAB_STAR				; HEX$(
 8842/    3542 : 4203                   	dc.b	'B',3
 8843/    3544 : 0024                   	dc.w	KEY_BINS-TAB_STAR				; BIN$(
 8844/    3546 : 4205                   	dc.b	'B',5
 8845/    3548 : 0035                   	dc.w	KEY_BITTST-TAB_STAR			; BITTST(
 8846/    354A : 4D02                   	dc.b	'M',2
 8847/    354C : 00D6                   	dc.w	KEY_MAX-TAB_STAR				; MAX(
 8848/    354E : 4D02                   	dc.b	'M',2
 8849/    3550 : 00DF                   	dc.w	KEY_MIN-TAB_STAR				; MIN(
 8850/    3552 : 5205                   	dc.b	'R',5
 8851/    3554 : 010D                   	dc.w	KEY_RAM-TAB_STAR				; RAMBASE
 8852/    3556 : 5000                   	dc.b	'P',0
 8853/    3558 : 00FD                   	dc.w	KEY_PI-TAB_STAR				; PI
 8854/    355A : 5403                   	dc.b	'T',3
 8855/    355C : 0170                   	dc.w	KEY_TWOPI-TAB_STAR			; TWOPI
 8856/    355E : 5605                   	dc.b	'V',5
 8857/    3560 : 0192                   	dc.w	KEY_VPTR-TAB_STAR				; VARPTR(
 8858/    3562 : 5303                   	dc.b	'S',3
 8859/    3564 : 0137                   	dc.w	KEY_SADD-TAB_STAR				; SADD(
 8860/    3566 : 4C04                   	dc.b	'L',4
 8861/    3568 : 00B4                   	dc.w	KEY_LEFTS-TAB_STAR			; LEFT$(
 8862/    356A : 5205                   	dc.b	'R',5
 8863/    356C : 0128                   	dc.w	KEY_RIGHTS-TAB_STAR			; RIGHT$(
 8864/    356E : 4D03                   	dc.b	'M',3
 8865/    3570 : 00DA                   	dc.w	KEY_MIDS-TAB_STAR				; MID$(
 8866/    3572 : 5505                   	dc.b	'U',5
 8867/    3574 : 0182                   	dc.w	KEY_USINGS-TAB_STAR			; USING$(
 8868/    3576 :                        
 8869/    3576 :                        
 8870/    3576 :                        ;************************************************************************************
 8871/    3576 :                        ;
 8872/    3576 :                        ; BASIC error messages
 8873/    3576 :                        
 8874/    3576 :                        LAB_BAER
 8875/    3576 : 0030                   	dc.w	LAB_NF-LAB_BAER				; $00 NEXT without FOR
 8876/    3578 : 0041                   	dc.w	LAB_SN-LAB_BAER				; $02 syntax
 8877/    357A : 0048                   	dc.w	LAB_RG-LAB_BAER				; $04 RETURN without GOSUB
 8878/    357C : 005D                   	dc.w	LAB_OD-LAB_BAER				; $06 out of data
 8879/    357E : 0069                   	dc.w	LAB_FC-LAB_BAER				; $08 function call
 8880/    3580 : 0077                   	dc.w	LAB_OV-LAB_BAER				; $0A overflow
 8881/    3582 : 0080                   	dc.w	LAB_OM-LAB_BAER				; $0C out of memory
 8882/    3584 : 008E                   	dc.w	LAB_US-LAB_BAER				; $0E undefined statement
 8883/    3586 : 00A2                   	dc.w	LAB_BS-LAB_BAER				; $10 array bounds
 8884/    3588 : 00AF                   	dc.w	LAB_DD-LAB_BAER				; $12 double dimension array
 8885/    358A : 00C0                   	dc.w	LAB_D0-LAB_BAER				; $14 divide by 0
 8886/    358C : 00CF                   	dc.w	LAB_ID-LAB_BAER				; $16 illegal direct
 8887/    358E : 00DE                   	dc.w	LAB_TM-LAB_BAER				; $18 type mismatch
 8888/    3590 : 00EC                   	dc.w	LAB_LS-LAB_BAER				; $1A long string
 8889/    3592 : 00FC                   	dc.w	LAB_ST-LAB_BAER				; $1C string too complex
 8890/    3594 : 010F                   	dc.w	LAB_CN-LAB_BAER				; $1E continue error
 8891/    3596 : 011E                   	dc.w	LAB_UF-LAB_BAER				; $20 undefined function
 8892/    3598 : 0131                   	dc.w	LAB_LD-LAB_BAER				; $22 LOOP without DO
 8893/    359A : 0141                   	dc.w	LAB_UV-LAB_BAER				; $24 undefined variable
 8894/    359C : 0154                   	dc.w	LAB_UA-LAB_BAER				; $26 undimensioned array
 8895/    359E : 0168                   	dc.w	LAB_WD-LAB_BAER				; $28 wrong dimensions
 8896/    35A0 : 0179                   	dc.w	LAB_AD-LAB_BAER				; $2A address
 8897/    35A2 : 0181                   	dc.w	LAB_FO-LAB_BAER				; $2C format
 8898/    35A4 : 0188                   	dc.w	LAB_NI-LAB_BAER				; $2E not implemented
 8899/    35A6 :                        
 8900/    35A6 : 4E45 5854 2077 6974    LAB_NF	dc.b	'NEXT without FOR',$00
          35AE : 686F 7574 2046 4F52 00
 8901/    35B7 : 5379 6E74 6178 00      LAB_SN	dc.b	'Syntax',$00
 8902/    35BE : 5245 5455 524E 2077    LAB_RG	dc.b	'RETURN without GOSUB',$00
          35C6 : 6974 686F 7574 2047
          35CE : 4F53 5542 00         
 8903/    35D3 : 4F75 7420 6F66 2044    LAB_OD	dc.b	'Out of DATA',$00
          35DB : 4154 4100            
 8904/    35DF : 4675 6E63 7469 6F6E    LAB_FC	dc.b	'Function call',$00
          35E7 : 2063 616C 6C00      
 8905/    35ED : 4F76 6572 666C 6F77 00 LAB_OV	dc.b	'Overflow',$00
 8906/    35F6 : 4F75 7420 6F66 206D    LAB_OM	dc.b	'Out of memory',$00
          35FE : 656D 6F72 7900      
 8907/    3604 : 556E 6465 6669 6E65    LAB_US	dc.b	'Undefined statement',$00
          360C : 6420 7374 6174 656D
          3614 : 656E 7400            
 8908/    3618 : 4172 7261 7920 626F    LAB_BS	dc.b	'Array bounds',$00
          3620 : 756E 6473 00         
 8909/    3625 : 446F 7562 6C65 2064    LAB_DD	dc.b	'Double dimension',$00
          362D : 696D 656E 7369 6F6E 00
 8910/    3636 : 4469 7669 6465 2062    LAB_D0	dc.b	'Divide by zero',$00
          363E : 7920 7A65 726F 00   
 8911/    3645 : 496C 6C65 6761 6C20    LAB_ID	dc.b	'Illegal direct',$00
          364D : 6469 7265 6374 00   
 8912/    3654 : 5479 7065 206D 6973    LAB_TM	dc.b	'Type mismatch',$00
          365C : 6D61 7463 6800      
 8913/    3662 : 5374 7269 6E67 2074    LAB_LS	dc.b	'String too long',$00
          366A : 6F6F 206C 6F6E 6700   
 8914/    3672 : 5374 7269 6E67 2074    LAB_ST	dc.b	'String too complex',$00
          367A : 6F6F 2063 6F6D 706C
          3682 : 6578 00               
 8915/    3685 : 4361 6E27 7420 636F    LAB_CN	dc.b	"Can't continue",$00
          368D : 6E74 696E 7565 00   
 8916/    3694 : 556E 6465 6669 6E65    LAB_UF	dc.b	'Undefined function',$00
          369C : 6420 6675 6E63 7469
          36A4 : 6F6E 00               
 8917/    36A7 : 4C4F 4F50 2077 6974    LAB_LD	dc.b	'LOOP without DO',$00
          36AF : 686F 7574 2044 4F00   
 8918/    36B7 : 556E 6465 6669 6E65    LAB_UV	dc.b	'Undefined variable',$00
          36BF : 6420 7661 7269 6162
          36C7 : 6C65 00               
 8919/    36CA : 556E 6469 6D65 6E73    LAB_UA	dc.b	'Undimensioned array',$00
          36D2 : 696F 6E65 6420 6172
          36DA : 7261 7900            
 8920/    36DE : 5772 6F6E 6720 6469    LAB_WD	dc.b	'Wrong dimensions',$00
          36E6 : 6D65 6E73 696F 6E73 00
 8921/    36EF : 4164 6472 6573 7300    LAB_AD	dc.b	'Address',$00
 8922/    36F7 : 466F 726D 6174 00      LAB_FO	dc.b	'Format',$00
 8923/    36FE : 4E6F 7420 696D 706C    LAB_NI  dc.b    'Not implemented',$00
          3706 : 656D 656E 7465 6400   
 8924/    370E :                        
 8925/    370E :                        
 8926/    370E :                        ;************************************************************************************
 8927/    370E :                        ;
 8928/    370E :                        ; keyword table for line (un)crunching
 8929/    370E :                        
 8930/    370E :                        ; [keyword,token
 8931/    370E :                        ; [keyword,token]]
 8932/    370E :                        ; end marker (#$00)
 8933/    370E :                        
 8934/    370E :                        TAB_STAR
 8935/    370E :                        KEY_MULT
 8936/    370E : B400                   	dc.b TK_MULT,$00					; *
 8937/    3710 :                        TAB_PLUS
 8938/    3710 :                        KEY_PLUS
 8939/    3710 : B200                   	dc.b TK_PLUS,$00					; +
 8940/    3712 :                        TAB_MNUS
 8941/    3712 :                        KEY_MINUS
 8942/    3712 : B300                   	dc.b TK_MINUS,$00					; -
 8943/    3714 :                        TAB_SLAS
 8944/    3714 :                        KEY_DIV
 8945/    3714 : B500                   	dc.b TK_DIV,$00					; /
 8946/    3716 :                        TAB_LESS
 8947/    3716 :                        KEY_LSHIFT
 8948/    3716 : 3CBB                   	dc.b	'<',TK_LSHIFT				; <<
 8949/    3718 :                        KEY_LT
 8950/    3718 : BE                     	dc.b TK_LT						; <
 8951/    3719 : 00                     	dc.b	$00
 8952/    371A :                        TAB_EQUL
 8953/    371A :                        KEY_EQUAL
 8954/    371A : BD00                   	dc.b TK_EQUAL,$00					; =
 8955/    371C :                        TAB_MORE
 8956/    371C :                        KEY_RSHIFT
 8957/    371C : 3EBA                   	dc.b	'>',TK_RSHIFT				; >>
 8958/    371E :                        KEY_GT
 8959/    371E : BC                     	dc.b TK_GT						; >
 8960/    371F : 00                     	dc.b	$00
 8961/    3720 :                        TAB_QEST
 8962/    3720 : 9E00                   	dc.b TK_PRINT,$00					; ?
 8963/    3722 :                        TAB_ASCA
 8964/    3722 :                        KEY_ABS
 8965/    3722 : 4253 28C1              	dc.b	'BS(',TK_ABS				; ABS(
 8966/    3726 :                        KEY_AND
 8967/    3726 : 4E44 B7                	dc.b	'ND',TK_AND					; AND
 8968/    3729 :                        KEY_ASC
 8969/    3729 : 5343 28D3              	dc.b	'SC(',TK_ASC				; ASC(
 8970/    372D :                        KEY_ATN
 8971/    372D : 544E 28CC              	dc.b	'TN(',TK_ATN				; ATN(
 8972/    3731 : 00                     	dc.b	$00
 8973/    3732 :                        TAB_ASCB
 8974/    3732 :                        KEY_BINS
 8975/    3732 : 494E 2428 D8           	dc.b	'IN$(',TK_BINS				; BIN$(
 8976/    3737 :                        KEY_BITCLR
 8977/    3737 : 4954 434C 52A7         	dc.b	'ITCLR',TK_BITCLR				; BITCLR
 8978/    373D :                        KEY_BITSET
 8979/    373D : 4954 5345 54A6         	dc.b	'ITSET',TK_BITSET				; BITSET
 8980/    3743 :                        KEY_BITTST
 8981/    3743 : 4954 5453 5428 D9      	dc.b	'ITTST(',TK_BITTST			; BITTST(
 8982/    374A : 00                     	dc.b	$00
 8983/    374B :                        TAB_ASCC
 8984/    374B :                        KEY_CALL
 8985/    374B : 414C 4C9B              	dc.b	'ALL',TK_CALL				; CALL
 8986/    374F :                        KEY_CHRS
 8987/    374F : 4852 2428 D6           	dc.b	'HR$(',TK_CHRS				; CHR$(
 8988/    3754 :                        KEY_CLEAR
 8989/    3754 : 4C45 4152 A1           	dc.b	'LEAR',TK_CLEAR				; CLEAR
 8990/    3759 :                        KEY_CONT
 8991/    3759 : 4F4E 549F              	dc.b	'ONT',TK_CONT				; CONT
 8992/    375D :                        KEY_COS
 8993/    375D : 4F53 28C9              	dc.b	'OS(',TK_COS				; COS(
 8994/    3761 : 00                     	dc.b	$00
 8995/    3762 :                        TAB_ASCD
 8996/    3762 :                        KEY_DATA
 8997/    3762 : 4154 4183              	dc.b	'ATA',TK_DATA				; DATA
 8998/    3766 :                        KEY_DEC
 8999/    3766 : 4543 88                	dc.b	'EC',TK_DEC					; DEC
 9000/    3769 :                        KEY_DEEK
 9001/    3769 : 4545 4B28 CE           	dc.b	'EEK(',TK_DEEK				; DEEK(
 9002/    376E :                        KEY_DEF
 9003/    376E : 4546 97                	dc.b	'EF',TK_DEF					; DEF
 9004/    3771 :                        KEY_DIM
 9005/    3771 : 494D 85                	dc.b	'IM',TK_DIM					; DIM
 9006/    3774 :                        KEY_DOKE
 9007/    3774 : 4F4B 4599              	dc.b	'OKE',TK_DOKE				; DOKE
 9008/    3778 :                        KEY_DO
 9009/    3778 : 4F9C                   	dc.b	'O',TK_DO					; DO
 9010/    377A : 00                     	dc.b	$00
 9011/    377B :                        TAB_ASCE
 9012/    377B :                        KEY_ELSE
 9013/    377B : 4C53 45A9              	dc.b	'LSE',TK_ELSE				; ELSE
 9014/    377F :                        KEY_END
 9015/    377F : 4E44 80                	dc.b	'ND',TK_END					; END
 9016/    3782 :                        KEY_EOR
 9017/    3782 : 4F52 B8                	dc.b	'OR',TK_EOR					; EOR
 9018/    3785 :                        KEY_EXP
 9019/    3785 : 5850 28C8              	dc.b	'XP(',TK_EXP				; EXP(
 9020/    3789 : 00                     	dc.b	$00
 9021/    378A :                        TAB_ASCF
 9022/    378A :                        KEY_FOR
 9023/    378A : 4F52 81                	dc.b	'OR',TK_FOR					; FOR
 9024/    378D :                        KEY_FN
 9025/    378D : 4EAB                   	dc.b	'N',TK_FN					; FN
 9026/    378F :                        KEY_FRE
 9027/    378F : 5245 28C3              	dc.b	'RE(',TK_FRE				; FRE(
 9028/    3793 : 00                     	dc.b	$00
 9029/    3794 :                        TAB_ASCG
 9030/    3794 :                        KEY_GET
 9031/    3794 : 4554 A4                	dc.b	'ET',TK_GET					; GET
 9032/    3797 :                        KEY_GOTO
 9033/    3797 : 4F54 4F89              	dc.b	'OTO',TK_GOTO				; GOTO
 9034/    379B :                        KEY_GOSUB
 9035/    379B : 4F53 5542 8D           	dc.b	'OSUB',TK_GOSUB				; GOSUB
 9036/    37A0 : 00                     	dc.b	$00
 9037/    37A1 :                        TAB_ASCH
 9038/    37A1 :                        KEY_HEXS
 9039/    37A1 : 4558 2428 D700         	dc.b	'EX$(',TK_HEXS,$00			; HEX$(
 9040/    37A7 :                        TAB_ASCI
 9041/    37A7 :                        KEY_IF
 9042/    37A7 : 468B                   	dc.b	'F',TK_IF					; IF
 9043/    37A9 :                        KEY_INC
 9044/    37A9 : 4E43 93                	dc.b	'NC',TK_INC					; INC
 9045/    37AC :                        KEY_INPUT
 9046/    37AC : 4E50 5554 84           	dc.b	'NPUT',TK_INPUT				; INPUT
 9047/    37B1 :                        KEY_INT
 9048/    37B1 : 4E54 28C0              	dc.b	'NT(',TK_INT				; INT(
 9049/    37B5 : 00                     	dc.b	$00
 9050/    37B6 :                        TAB_ASCL
 9051/    37B6 :                        KEY_LCASES
 9052/    37B6 : 4341 5345 2428 D5      	dc.b	'CASE$(',TK_LCASES			; LCASE$(
 9053/    37BD :                        KEY_LEEK
 9054/    37BD : 4545 4B28 CF           	dc.b	'EEK(',TK_LEEK				; LEEK(
 9055/    37C2 :                        KEY_LEFTS
 9056/    37C2 : 4546 5424 28E1         	dc.b	'EFT$(',TK_LEFTS				; LEFT$(
 9057/    37C8 :                        KEY_LEN
 9058/    37C8 : 454E 28D0              	dc.b	'EN(',TK_LEN				; LEN(
 9059/    37CC :                        KEY_LET
 9060/    37CC : 4554 87                	dc.b	'ET',TK_LET					; LET
 9061/    37CF :                        KEY_LIST
 9062/    37CF : 4953 54A0              	dc.b	'IST',TK_LIST				; LIST
 9063/    37D3 :                        KEY_LOAD
 9064/    37D3 : 4F41 4495              	dc.b	'OAD',TK_LOAD				; LOAD
 9065/    37D7 :                        KEY_LOG
 9066/    37D7 : 4F47 28C7              	dc.b	'OG(',TK_LOG				; LOG(
 9067/    37DB :                        KEY_LOKE
 9068/    37DB : 4F4B 459A              	dc.b	'OKE',TK_LOKE				; LOKE
 9069/    37DF :                        KEY_LOOP
 9070/    37DF : 4F4F 509D              	dc.b	'OOP',TK_LOOP				; LOOP
 9071/    37E3 : 00                     	dc.b	$00
 9072/    37E4 :                        TAB_ASCM
 9073/    37E4 :                        KEY_MAX
 9074/    37E4 : 4158 28DA              	dc.b	'AX(',TK_MAX				; MAX(
 9075/    37E8 :                        KEY_MIDS
 9076/    37E8 : 4944 2428 E3           	dc.b	'ID$(',TK_MIDS				; MID$(
 9077/    37ED :                        KEY_MIN
 9078/    37ED : 494E 28DB              	dc.b	'IN(',TK_MIN				; MIN(
 9079/    37F1 : 00                     	dc.b	$00
 9080/    37F2 :                        TAB_ASCN
 9081/    37F2 :                        KEY_NEW
 9082/    37F2 : 4557 A2                	dc.b	'EW',TK_NEW					; NEW
 9083/    37F5 :                        KEY_NEXT
 9084/    37F5 : 4558 5482              	dc.b	'EXT',TK_NEXT				; NEXT
 9085/    37F9 :                        KEY_NOT
 9086/    37F9 : 4F54 AE                	dc.b	'OT',TK_NOT					; NOT
 9087/    37FC :                        KEY_NULL
 9088/    37FC : 554C 4C92              	dc.b	'ULL',TK_NULL				; NULL
 9089/    3800 : 00                     	dc.b	$00
 9090/    3801 :                        TAB_ASCO
 9091/    3801 :                        KEY_ON
 9092/    3801 : 4E91                   	dc.b	'N',TK_ON					; ON
 9093/    3803 :                        KEY_OR
 9094/    3803 : 52B9                   	dc.b	'R',TK_OR					; OR
 9095/    3805 : 00                     	dc.b	$00
 9096/    3806 :                        TAB_ASCP
 9097/    3806 :                        KEY_PEEK
 9098/    3806 : 4545 4B28 CD           	dc.b	'EEK(',TK_PEEK				; PEEK(
 9099/    380B :                        KEY_PI
 9100/    380B : 49DD                   	dc.b	'I',TK_PI					; PI
 9101/    380D :                        KEY_POKE
 9102/    380D : 4F4B 4598              	dc.b	'OKE',TK_POKE				; POKE
 9103/    3811 :                        KEY_POS
 9104/    3811 : 4F53 28C4              	dc.b	'OS(',TK_POS				; POS(
 9105/    3815 :                        KEY_PRINT
 9106/    3815 : 5249 4E54 9E           	dc.b	'RINT',TK_PRINT				; PRINT
 9107/    381A : 00                     	dc.b	$00
 9108/    381B :                        TAB_ASCR
 9109/    381B :                        KEY_RAM
 9110/    381B : 414D 4241 5345 DC      	dc.b	'AMBASE',TK_RAM				; RAMBASE
 9111/    3822 :                        KEY_READ
 9112/    3822 : 4541 4486              	dc.b	'EAD',TK_READ				; READ
 9113/    3826 :                        KEY_REM
 9114/    3826 : 454D 8F                	dc.b	'EM',TK_REM					; REM
 9115/    3829 :                        KEY_RESTORE
 9116/    3829 : 4553 544F 5245 8C      	dc.b	'ESTORE',TK_RESTORE			; RESTORE
 9117/    3830 :                        KEY_RETURN
 9118/    3830 : 4554 5552 4E8E         	dc.b	'ETURN',TK_RETURN				; RETURN
 9119/    3836 :                        KEY_RIGHTS
 9120/    3836 : 4947 4854 2428 E2      	dc.b	'IGHT$(',TK_RIGHTS			; RIGHT$(
 9121/    383D :                        KEY_RND
 9122/    383D : 4E44 28C6              	dc.b	'ND(',TK_RND				; RND(
 9123/    3841 :                        KEY_RUN
 9124/    3841 : 554E 8A                	dc.b	'UN',TK_RUN					; RUN
 9125/    3844 : 00                     	dc.b	$00
 9126/    3845 :                        TAB_ASCS
 9127/    3845 :                        KEY_SADD
 9128/    3845 : 4144 4428 E0           	dc.b	'ADD(',TK_SADD				; SADD(
 9129/    384A :                        KEY_SAVE
 9130/    384A : 4156 4596              	dc.b	'AVE',TK_SAVE				; SAVE
 9131/    384E :                        KEY_SGN
 9132/    384E : 474E 28BF              	dc.b	'GN(',TK_SGN				; SGN(
 9133/    3852 :                        KEY_SIN
 9134/    3852 : 494E 28CA              	dc.b	'IN(',TK_SIN				; SIN(
 9135/    3856 :                        KEY_SPC
 9136/    3856 : 5043 28AC              	dc.b	'PC(',TK_SPC				; SPC(
 9137/    385A :                        KEY_SQR
 9138/    385A : 5152 28C5              	dc.b	'QR(',TK_SQR				; SQR(
 9139/    385E :                        KEY_STEP
 9140/    385E : 5445 50AF              	dc.b	'TEP',TK_STEP				; STEP
 9141/    3862 :                        KEY_STOP
 9142/    3862 : 544F 5090              	dc.b	'TOP',TK_STOP				; STOP
 9143/    3866 :                        KEY_STRS
 9144/    3866 : 5452 2428 D1           	dc.b	'TR$(',TK_STRS				; STR$(
 9145/    386B :                        KEY_SWAP
 9146/    386B : 5741 50A5              	dc.b	'WAP',TK_SWAP				; SWAP
 9147/    386F : 00                     	dc.b	$00
 9148/    3870 :                        TAB_ASCT
 9149/    3870 :                        KEY_TAB
 9150/    3870 : 4142 28A8              	dc.b	'AB(',TK_TAB				; TAB(
 9151/    3874 :                        KEY_TAN
 9152/    3874 : 414E 28CB              	dc.b	'AN(',TK_TAN				; TAN
 9153/    3878 :                        KEY_THEN
 9154/    3878 : 4845 4EAD              	dc.b	'HEN',TK_THEN				; THEN
 9155/    387C :                        KEY_TO
 9156/    387C : 4FAA                   	dc.b	'O',TK_TO					; TO
 9157/    387E :                        KEY_TWOPI
 9158/    387E : 574F 5049 DE           	dc.b	'WOPI',TK_TWOPI				; TWOPI
 9159/    3883 : 00                     	dc.b	$00
 9160/    3884 :                        TAB_ASCU
 9161/    3884 :                        KEY_UCASES
 9162/    3884 : 4341 5345 2428 D4      	dc.b	'CASE$(',TK_UCASES			; UCASE$(
 9163/    388B :                        KEY_UNTIL
 9164/    388B : 4E54 494C B0           	dc.b	'NTIL',TK_UNTIL				; UNTIL
 9165/    3890 :                        KEY_USINGS
 9166/    3890 : 5349 4E47 2428 E4      	dc.b	'SING$(',TK_USINGS			; USING$(
 9167/    3897 :                        KEY_USR
 9168/    3897 : 5352 28C2              	dc.b	'SR(',TK_USR				; USR(
 9169/    389B : 00                     	dc.b	$00
 9170/    389C :                        TAB_ASCV
 9171/    389C :                        KEY_VAL
 9172/    389C : 414C 28D2              	dc.b	'AL(',TK_VAL				; VAL(
 9173/    38A0 :                        KEY_VPTR
 9174/    38A0 : 4152 5054 5228 DF      	dc.b	'ARPTR(',TK_VPTR				; VARPTR(
 9175/    38A7 : 00                     	dc.b	$00
 9176/    38A8 :                        TAB_ASCW
 9177/    38A8 :                        KEY_WAIT
 9178/    38A8 : 4149 5494              	dc.b	'AIT',TK_WAIT				; WAIT
 9179/    38AC :                        KEY_WHILE
 9180/    38AC : 4849 4C45 B1           	dc.b	'HILE',TK_WHILE				; WHILE
 9181/    38B1 :                        KEY_WIDTH
 9182/    38B1 : 4944 5448 A3           	dc.b	'IDTH',TK_WIDTH				; WIDTH
 9183/    38B6 : 00                     	dc.b	$00
 9184/    38B7 :                        TAB_POWR
 9185/    38B7 :                        KEY_POWER
 9186/    38B7 : B600                   	dc.b	TK_POWER,$00				; ^
 9187/    38B9 :                        
 9188/    38B9 :                        ;************************************************************************************
 9189/    38B9 :                        ;
 9190/    38B9 :                        ; just messages
 9191/    38B9 :                        
 9192/    38B9 :                        LAB_BMSG
 9193/    38B9 : 0D0A 4272 6561 6B00    	dc.b	$0D,$0A,'Break',$00
 9194/    38C1 :                        LAB_EMSG
 9195/    38C1 : 2045 7272 6F72 00      	dc.b	' Error',$00
 9196/    38C8 :                        LAB_LMSG
 9197/    38C8 : 2069 6E20 6C69 6E65    	dc.b	' in line ',$00
          38D0 : 2000                  
 9198/    38D2 :                        LAB_IMSG
 9199/    38D2 : 4578 7472 6120 6967    	dc.b	'Extra ignored',$0D,$0A,$00
          38DA : 6E6F 7265 640D 0A00   
 9200/    38E2 :                        LAB_REDO
 9201/    38E2 : 5265 646F 2066 726F    	dc.b	'Redo from start',$0D,$0A,$00
          38EA : 6D20 7374 6172 740D
          38F2 : 0A00                  
 9202/    38F4 :                        LAB_RMSG
 9203/    38F4 : 0D0A 5265 6164 790D    	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
          38FC : 0A00                  
 9204/    38FE :                        LAB_SMSG
 9205/    38FE : 2042 7974 6573 2066    	dc.b	' Bytes free',$0D,$0A,$0A
          3906 : 7265 650D 0A0A      
 9206/    390C : 456E 6861 6E63 6564    	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
          3914 : 2036 386B 2042 4153
          391C : 4943 2056 6572 7369
          3924 : 6F6E 2033 2E35 340D
          392C : 0A00                  
 9207/    392E :                        
 9208/    392E :                        ROM_E:
 9209/    392E :                        
 9210/    392E :                        ;************************************************************************************
 9211/    392E :                        ;
 9212/    392E :                        ; This lot is in Work area
 9213/    392E :                        
 9214/    392E : =$3A00                 WORK_B	EQU	(ROM_E+$100) & $ffffff00
 9215/    392E :                        
 9216/    3A00 :                        	ORG	WORK_B
 9217/    3A00 :                        
 9218/    3A00 : =$3A00                 ram_strt	equ	WORK_B
 9219/    3A00 :                        
 9220/    3A00 : =$7C600                ram_size:	EQU	$80000 - WORK_B
 9221/    3A00 :                        
 9222/    3A00 :                        ;
 9223/    3A00 :                        ;
 9224/    3A00 :                        
 9225/    3A00 :                        ;************************************************************************************
 9226/    3A00 :                        ; EhBASIC keywords quick reference list												*
 9227/    3A00 :                        ;************************************************************************************
 9228/    3A00 :                        
 9229/    3A00 :                        ; glossary
 9230/    3A00 :                        
 9231/    3A00 :                        ;		<.>		  required
 9232/    3A00 :                        ;		{.|.}		  one of required
 9233/    3A00 :                        ;		[.]		  optional
 9234/    3A00 :                        ;		...		  may repeat as last
 9235/    3A00 :                        
 9236/    3A00 :                        ;		any		= anything
 9237/    3A00 :                        ;		num		= number
 9238/    3A00 :                        ;		state		= statement
 9239/    3A00 :                        ;		n		= positive integer
 9240/    3A00 :                        ;		str		= string
 9241/    3A00 :                        ;		var		= variable
 9242/    3A00 :                        ;		nvar		= numeric variable
 9243/    3A00 :                        ;		svar		= string variable
 9244/    3A00 :                        ;		expr		= expression
 9245/    3A00 :                        ;		nexpr		= numeric expression
 9246/    3A00 :                        ;		sexpr		= string expression
 9247/    3A00 :                        
 9248/    3A00 :                        ; statement separator
 9249/    3A00 :                        
 9250/    3A00 :                        ; :			. [<state>] : [<state>]							; done
 9251/    3A00 :                        
 9252/    3A00 :                        ; number bases
 9253/    3A00 :                        
 9254/    3A00 :                        ; %			. %<binary num>								; done
 9255/    3A00 :                        ; $			. $<hex num>								; done
 9256/    3A00 :                        
 9257/    3A00 :                        ; commands
 9258/    3A00 :                        
 9259/    3A00 :                        ; END		. END										; done
 9260/    3A00 :                        ; FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]	; done
 9261/    3A00 :                        ; NEXT		. NEXT [<nvar>[,<nvar>]...]						; done
 9262/    3A00 :                        ; DATA		. DATA [{num|["]str["]}[,{num|["]str["]}]...]	; done
 9263/    3A00 :                        ; INPUT		. INPUT [<">str<">;] <var>[,<var>[,<var>]...]	; done
 9264/    3A00 :                        ; DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])		; done
 9265/    3A00 :                        ; READ		. READ <var>[,<var>[,<var>]...]				; done
 9266/    3A00 :                        ; LET		. [LET] <var>=<expr>						; done
 9267/    3A00 :                        ; DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]			; done
 9268/    3A00 :                        ; GOTO		. GOTO <n>									; done
 9269/    3A00 :                        ; RUN		. RUN [<n>]									; done
 9270/    3A00 :                        ; IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
 9271/    3A00 :                        ; RESTORE	. RESTORE [<n>]								; done
 9272/    3A00 :                        ; GOSUB		. GOSUB <n>									; done
 9273/    3A00 :                        ; RETURN	. RETURN									; done
 9274/    3A00 :                        ; REM		. REM [<any>]								; done
 9275/    3A00 :                        ; STOP		. STOP										; done
 9276/    3A00 :                        ; ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]	; done
 9277/    3A00 :                        ; NULL		. NULL <nexpr>								; done
 9278/    3A00 :                        ; INC		. INC <nvar>[,<nvar>[,<nvar>]...]			; done
 9279/    3A00 :                        ; WAIT		. WAIT <nexpr>,<nexpr>[,<nexpr>]			; done
 9280/    3A00 :                        ; LOAD		. LOAD [<sexpr>]							; done for sim
 9281/    3A00 :                        ; SAVE		. SAVE [<sexpr>][,[<n>][-<n>]]				; done for sim
 9282/    3A00 :                        ; DEF		. DEF FN<var>(<var>)=<expr>					; done
 9283/    3A00 :                        ; POKE		. POKE <nexpr>,<nexpr>						; done
 9284/    3A00 :                        ; DOKE		. DOKE <nexpr>,<nexpr>						; done
 9285/    3A00 :                        ; LOKE		. LOKE <nexpr>,<nexpr>						; done
 9286/    3A00 :                        ; CALL		. CALL <nexpr>								; done
 9287/    3A00 :                        ; DO		. DO										; done
 9288/    3A00 :                        ; LOOP		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9289/    3A00 :                        ; PRINT		. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]	; done
 9290/    3A00 :                        ; CONT		. CONT										; done
 9291/    3A00 :                        ; LIST		. LIST [<n>][-<n>]							; done
 9292/    3A00 :                        ; CLEAR		. CLEAR										; done
 9293/    3A00 :                        ; NEW		. NEW										; done
 9294/    3A00 :                        ; WIDTH		. WIDTH [<n>][,<n>]							; done
 9295/    3A00 :                        ; GET		. GET <var>									; done
 9296/    3A00 :                        ; SWAP		. SWAP <var>,<var>							; done
 9297/    3A00 :                        ; BITSET	. BITSET <nexpr>,<nexpr>					; done
 9298/    3A00 :                        ; BITCLR	. BITCLR <nexpr>,<nexpr>					; done
 9299/    3A00 :                        
 9300/    3A00 :                        ; sub commands (may not start a statement)
 9301/    3A00 :                        
 9302/    3A00 :                        ; TAB		. TAB(<nexpr>)								; done
 9303/    3A00 :                        ; ELSE		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
 9304/    3A00 :                        ; TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
 9305/    3A00 :                        ; FN		. FN <var>(<expr>)							; done
 9306/    3A00 :                        ; SPC		. SPC(<nexpr>)								; done
 9307/    3A00 :                        ; THEN		. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}		; done
 9308/    3A00 :                        ; NOT		. NOT <nexpr>								; done
 9309/    3A00 :                        ; STEP		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
 9310/    3A00 :                        ; UNTIL		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9311/    3A00 :                        ; WHILE		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9312/    3A00 :                        
 9313/    3A00 :                        ; operators
 9314/    3A00 :                        
 9315/    3A00 :                        ; +			. [expr] + <expr>							; done
 9316/    3A00 :                        ; -			. [nexpr] - <nexpr>							; done
 9317/    3A00 :                        ; *			. <nexpr>	; <nexpr>						; done fast hardware
 9318/    3A00 :                        ; /			. <nexpr> / <nexpr>							; done fast hardware
 9319/    3A00 :                        ; ^			. <nexpr> ^ <nexpr>							; done
 9320/    3A00 :                        ; AND		. <nexpr> AND <nexpr>						; done
 9321/    3A00 :                        ; EOR		. <nexpr> EOR <nexpr>						; done
 9322/    3A00 :                        ; OR		. <nexpr> OR <nexpr>						; done
 9323/    3A00 :                        ; >>		. <nexpr> >> <nexpr>						; done
 9324/    3A00 :                        ; <<		. <nexpr> << <nexpr>						; done
 9325/    3A00 :                        
 9326/    3A00 :                        ; compare functions
 9327/    3A00 :                        
 9328/    3A00 :                        ; <			. <expr> < <expr>							; done
 9329/    3A00 :                        ; =			. <expr> = <expr>							; done
 9330/    3A00 :                        ; >			. <expr> > <expr>							; done
 9331/    3A00 :                        
 9332/    3A00 :                        ; functions
 9333/    3A00 :                        
 9334/    3A00 :                        ; SGN		. SGN(<nexpr>)								; done
 9335/    3A00 :                        ; INT		. INT(<nexpr>)								; done
 9336/    3A00 :                        ; ABS		. ABS(<nexpr>)								; done
 9337/    3A00 :                        ; USR		. USR(<expr>)								; done
 9338/    3A00 :                        ; FRE		. FRE(<expr>)								; done
 9339/    3A00 :                        ; POS		. POS(<expr>)								; done
 9340/    3A00 :                        ; SQR		. SQR(<nexpr>)								; done fast shift/sub
 9341/    3A00 :                        ; RND		. RND(<nexpr>)								; done 32 bit PRNG
 9342/    3A00 :                        ; LOG		. LOG(<nexpr>)								; done fast cordic
 9343/    3A00 :                        ; EXP		. EXP(<nexpr>)								; done fast cordic
 9344/    3A00 :                        ; COS		. COS(<nexpr>)								; done fast cordic
 9345/    3A00 :                        ; SIN		. SIN(<nexpr>)								; done fast cordic
 9346/    3A00 :                        ; TAN		. TAN(<nexpr>)								; done fast cordic
 9347/    3A00 :                        ; ATN		. ATN(<nexpr>)								; done fast cordic
 9348/    3A00 :                        ; PEEK		. PEEK(<nexpr>)								; done
 9349/    3A00 :                        ; DEEK		. DEEK(<nexpr>)								; done
 9350/    3A00 :                        ; LEEK		. LEEK(<nexpr>)								; done
 9351/    3A00 :                        ; LEN		. LEN(<sexpr>)								; done
 9352/    3A00 :                        ; STR$		. STR$(<nexpr>)								; done
 9353/    3A00 :                        ; VAL		. VAL(<sexpr>)								; done
 9354/    3A00 :                        ; ASC		. ASC(<sexpr>)								; done
 9355/    3A00 :                        ; UCASE$	. UCASE$(<sexpr>)							; done
 9356/    3A00 :                        ; LCASE$	. LCASE$(<sexpr>)							; done
 9357/    3A00 :                        ; CHR$		. CHR$(<nexpr>)								; done
 9358/    3A00 :                        ; HEX$		. HEX$(<nexpr>)								; done
 9359/    3A00 :                        ; BIN$		. BIN$(<nexpr>)								; done
 9360/    3A00 :                        ; BTST		. BTST(<nexpr>,<nexpr>)						; done
 9361/    3A00 :                        ; MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
 9362/    3A00 :                        ; MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
 9363/    3A00 :                        ; PI		. PI										; done
 9364/    3A00 :                        ; TWOPI		. TWOPI										; done
 9365/    3A00 :                        ; VARPTR	. VARPTR(<var>)								; done
 9366/    3A00 :                        ; SADD		. SADD(<svar>)								; done
 9367/    3A00 :                        ; LEFT$		. LEFT$(<sexpr>,<nexpr>)					; done
 9368/    3A00 :                        ; RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					; done
 9369/    3A00 :                        ; MID$		. MID$(<sexpr>,<nexpr>[,<nexpr>])			; done
 9370/    3A00 :                        ; USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])		; done
 9371/    3A00 :                        
 9372/    3A00 :                        
 9373/    3A00 :                        ;************************************************************************************
 9374/    3A00 :                        
 9375/    3A00 :                        	END	code_start
 AS V1.42 Beta [Bld 269] - Source File BASIC68K.ASM - Page 2 - 6/12/2024 11:45:36


  Symbol Table (* = unused):
  --------------------------

 AC1GTAC2 :                    1EFE C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ASPTL :                        5A8 C |  ASRCH :                        5DA C |
 ASTRTL :                       5AC C |  BHSEND :                       5D6 C |
 BIN2DEC :                     2EC2 C |  BINPR :                       2AA8 C |
 BINSS :                        5B6 C |  BLINEL :                       456 C |
 BREAKF :                       5DC C | *CASESENSITIVE :                  0 - |
 CBI_CHR :                      107 C |  CCBYTE :                       5E9 C |
 CCFLAG :                       5E8 C |  CCNULL :                       5EA C |
 CFLAG :                        5E1 C |  CIN0 :                         40C C |
 CIN1 :                         412 C |  CLINEL :                       452 C |
 CODE_START :                   44A C |  COMP_F :                       5E3 C |
 CONST :                        424 C | *CONSTPI :        3.141592653589793 - |
 COSOUT :                       5B4 - |  CPNTRL :                       45A C |
 CREQ_COM :                     106 C | *CVARAL :                       46E C |
 D1X02 :                       2E9C C |  D1X10 :                       2EB2 C |
 D1X16 :                       2E8E C | *DATA_DMA :                     10E C |
*DATE :                 "6/12/2024" - |  DECSS :                        5C6 C |
 DEFDIM :                       5B4 C |  DES_SK :                       48E C |
 DES_SK_E :                     476 C |  DIMCNT :                       5DB C |
*DISK_DRIVE :                   108 C | *DISK_SECTOR :                  10C C |
*DISK_TRACK :                   10A C |  DLINEL :                       45E C |
 DOCMP :                        AFE C |  DOREST :                       AEA C |
 DPTRL :                        462 C |  DTYPEF :                       5B5 - |
 DUMMY_H :                      400 C |  EARRYL :                       442 C |
 EMEML :                        44A C |  ENDBHS :                      2A82 C |
 EXPCNT :                       5AD - |  EXPNEG :                       5AF - |
 FAC1_E :                       594 C |  FAC1_M :                       590 C |
 FAC1_S :                       595 - |  FAC2_E :                       59C C |
 FAC2_M :                       598 C |  FAC2_S :                       59D - |
 FAC_SC :                       59E - | *FALSE :                          0 - |
 FEND :                           8 - |  FLAG :                         59F - |
*FLASH_SUPPORT :                  0 - |  FSD :                            0 - |
 FSDC :                           A - |  FSDPI :                          8 - |
 FSLI :                           6 - |  FSTI :                           4 - |
*FULLPMMU :                       1 - |  FUNC_L :                       5B0 C |
 GCLCTD :                       5DE C |  GETFIRST :                    12D6 C |
 GETPAIR :                     1392 C |  GOPR :                        2AB2 C |
*HAS64 :                          0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEXSS :                        5CE C |
 IBUFFE :                       590 C |  IBUFFS :                       490 C |
 ICLIM :                        5E7 C |  IMODE :                        5E0 C |
 INGET :                       2B06 C | *INIVEC :                         0 C |
*INIVECE :                       C0 C | *INSUPMODE :                      1 - |
 ITEMP :                        42A C |  KEY_ABS :                     3722 C |
 KEY_AND :                     3726 C |  KEY_ASC :                     3729 C |
 KEY_ATN :                     372D C |  KEY_BINS :                    3732 C |
 KEY_BITCLR :                  3737 C |  KEY_BITSET :                  373D C |
 KEY_BITTST :                  3743 C |  KEY_CALL :                    374B C |
 KEY_CHRS :                    374F C |  KEY_CLEAR :                   3754 C |
 KEY_CONT :                    3759 C |  KEY_COS :                     375D C |
 KEY_DATA :                    3762 C |  KEY_DEC :                     3766 C |
 KEY_DEEK :                    3769 C |  KEY_DEF :                     376E C |
 KEY_DIM :                     3771 C |  KEY_DIV :                     3714 C |
 KEY_DO :                      3778 C |  KEY_DOKE :                    3774 C |
 KEY_ELSE :                    377B C |  KEY_END :                     377F C |
 KEY_EOR :                     3782 C |  KEY_EQUAL :                   371A C |
 KEY_EXP :                     3785 C |  KEY_FN :                      378D C |
 KEY_FOR :                     378A C |  KEY_FRE :                     378F C |
 KEY_GET :                     3794 C |  KEY_GOSUB :                   379B C |
 KEY_GOTO :                    3797 C |  KEY_GT :                      371E C |
 KEY_HEXS :                    37A1 C |  KEY_IF :                      37A7 C |
 KEY_INC :                     37A9 C |  KEY_INPUT :                   37AC C |
 KEY_INT :                     37B1 C |  KEY_LCASES :                  37B6 C |
 KEY_LEEK :                    37BD C |  KEY_LEFTS :                   37C2 C |
 KEY_LEN :                     37C8 C |  KEY_LET :                     37CC C |
 KEY_LIST :                    37CF C |  KEY_LOAD :                    37D3 C |
 KEY_LOG :                     37D7 C |  KEY_LOKE :                    37DB C |
 KEY_LOOP :                    37DF C |  KEY_LSHIFT :                  3716 C |
 KEY_LT :                      3718 C |  KEY_MAX :                     37E4 C |
 KEY_MIDS :                    37E8 C |  KEY_MIN :                     37ED C |
 KEY_MINUS :                   3712 C |  KEY_MULT :                    370E C |
 KEY_NEW :                     37F2 C |  KEY_NEXT :                    37F5 C |
 KEY_NOT :                     37F9 C |  KEY_NULL :                    37FC C |
 KEY_ON :                      3801 C |  KEY_OR :                      3803 C |
 KEY_PEEK :                    3806 C |  KEY_PI :                      380B C |
 KEY_PLUS :                    3710 C |  KEY_POKE :                    380D C |
 KEY_POS :                     3811 C |  KEY_POWER :                   38B7 C |
 KEY_PRINT :                   3815 C |  KEY_RAM :                     381B C |
 KEY_READ :                    3822 C |  KEY_REM :                     3826 C |
 KEY_RESTORE :                 3829 C |  KEY_RETURN :                  3830 C |
 KEY_RIGHTS :                  3836 C |  KEY_RND :                     383D C |
 KEY_RSHIFT :                  371C C |  KEY_RUN :                     3841 C |
 KEY_SADD :                    3845 C |  KEY_SAVE :                    384A C |
 KEY_SGN :                     384E C |  KEY_SIN :                     3852 C |
 KEY_SPC :                     3856 C |  KEY_SQR :                     385A C |
 KEY_STEP :                    385E C |  KEY_STOP :                    3862 C |
 KEY_STRS :                    3866 C |  KEY_SWAP :                    386B C |
 KEY_TAB :                     3870 C |  KEY_TAN :                     3874 C |
 KEY_THEN :                    3878 C |  KEY_TO :                      387C C |
 KEY_TWOPI :                   387E C |  KEY_UCASES :                  3884 C |
 KEY_UNTIL :                   388B C |  KEY_USINGS :                  3890 C |
 KEY_USR :                     3897 C |  KEY_VAL :                     389C C |
 KEY_VPTR :                    38A0 C |  KEY_WAIT :                    38A8 C |
 KEY_WHILE :                   38AC C |  KEY_WIDTH :                   38B1 C |
 KFCTSEED :                26A3D110 - |  LAB_11A5 :                     FA4 C |
 LAB_11A6 :                     FA6 C |  LAB_11BD :                     FB2 C |
 LAB_1269 :                     58E C |  LAB_1274 :                     59C C |
 LAB_127D :                     5A4 C |  LAB_127E :                     5B2 C |
 LAB_1295 :                     5C6 C |  LAB_12AE :                     5E8 C |
 LAB_12B0 :                     5EA C |  LAB_12E6 :                     60A C |
 LAB_12FF :                     63C C |  LAB_1301 :                     63E C |
 LAB_1303 :                     65C C |  LAB_1325 :                     674 C |
 LAB_132E :                     664 C |  LAB_1330 :                     666 C |
 LAB_134B :                     682 C |  LAB_1357 :                     6A0 C |
 LAB_1359 :                     6A6 C |  LAB_1374 :                     6C6 C |
 LAB_1378 :                     6CC C |  LAB_137F :                     6D8 C |
 LAB_138E :                     6DE C |  LAB_1392 :                     6E2 C |
 LAB_13A6 :                     716 C |  LAB_13AC :                     71E C |
 LAB_13C6 :                     748 C |  LAB_13CC :                     74E C |
 LAB_13D6 :                     770 C |  LAB_13D8 :                     776 C |
 LAB_13EA :                     782 C |  LAB_13EC :                     784 C |
 LAB_13FF :                     79C C |  LAB_1401 :                     7A0 C |
 LAB_1408 :                     7AC C |  LAB_1410 :                     7B8 C |
 LAB_1417 :                     7C2 C |  LAB_141B :                     7C4 C |
 LAB_141F :                     7D4 C |  LAB_142A :                     7DA C |
 LAB_142C :                     7E6 C |  LAB_145E :                     800 C |
 LAB_145F :                     7F2 C |  LAB_1463 :                     808 C |
 LAB_1477 :                     814 C |  LAB_147A :                     81A C |
*LAB_1480 :                     834 C |  LAB_1491 :                     83E C |
 LAB_14BD :                     870 C |  LAB_14C0 :                     874 C |
 LAB_14D4 :                     894 C | *LAB_14E2 :                     8B0 C |
 LAB_150C :                     8BE C |  LAB_1519 :                     8CE C |
 LAB_152E :                     8DA C |  LAB_1540 :                     906 C |
 LAB_15B3 :                     966 C |  LAB_15C2 :                     990 C |
 LAB_15D1 :                     99C C |  LAB_15DC :                     978 C |
 LAB_15F6 :                     98A C |  LAB_15FF :                     9AA C |
 LAB_1602 :                     9AE C |  LAB_1624 :                     A32 C |
 LAB_1629 :                     9D2 C |  LAB_1636 :                     9D6 C |
 LAB_1639 :                     9DC C |  LAB_163B :                     9E8 C |
 LAB_1647 :                     9F4 C |  LAB_164F :                     9FA C |
 LAB_16B0 :                     A92 C |  LAB_16D0 :                     AB6 C |
 LAB_1723 :                     B50 C |  LAB_1725 :                     B54 C |
 LAB_172C :                     B40 C |  LAB_172D :                     B48 C |
 LAB_174B :                     B7C C |  LAB_174E :                     BA0 C |
 LAB_1750 :                     BAC C |  LAB_1752 :                     BB8 C |
 LAB_1754 :                     BD0 C | *LAB_1756 :                     BBC C |
 LAB_176C :                     BEE C |  LAB_1773 :                     BF8 C |
 LAB_1785 :                     C14 C |  LAB_1786 :                     C40 C |
 LAB_17B7 :                     C56 C |  LAB_17B8 :                     C52 C |
 LAB_17D5 :                     CD2 C |  LAB_17D6 :                     CD6 C |
*LAB_1810 :                     CE8 C |  LAB_1811 :                     CF8 C |
 LAB_1813 :                     CFE C |  LAB_1829 :                     D36 C |
 LAB_182C :                     D3A C |  LAB_1831 :                     D40 C |
 LAB_185E :                     D80 C |  LAB_1866 :                     D84 C |
 LAB_1880 :                     E46 C |  LAB_1886 :                     E50 C |
 LAB_188A :                     E54 C |  LAB_188B :                     D92 C |
 LAB_1898 :                     DA0 C |  LAB_18A2 :                     DAA C |
 LAB_18B7 :                     DCC C |  LAB_18B8 :                     DD8 C |
 LAB_18BD :                     DDE C |  LAB_18C3 :                     DE8 C |
 LAB_18C6 :                     DEC C |  LAB_18CD :                     DF6 C |
 LAB_18E3 :                     E00 C |  LAB_18F0 :                     E20 C |
 LAB_18F7 :                     E2E C |  LAB_18F9 :                     E32 C |
 LAB_1904 :                     E58 C |  LAB_1913 :                     E6A C |
 LAB_1934 :                     E90 C |  LAB_1953 :                     EA4 C |
 LAB_195B :                     EAC C | *LAB_1961 :                     EB6 C |
 LAB_1984 :                     ED6 C |  LAB_1985 :                     EDA C |
 LAB_1986 :                     EDE C |  LAB_1999 :                     EF2 C |
 LAB_19B0 :                     F04 C |  LAB_19B6 :                     F14 C |
 LAB_19C2 :                     F24 C |  LAB_19DD :                     F38 C |
 LAB_19F6 :                     F58 C |  LAB_1A03 :                     F66 C |
 LAB_1A0E :                     F76 C |  LAB_1A1B :                     F7C C |
 LAB_1A46 :                     F96 C |  LAB_1A90 :                    1014 C |
 LAB_1A9B :                    1022 C |  LAB_1ABA :                    104C C |
 LAB_1ACD :                    1078 C |  LAB_1ADB :                    1084 C |
 LAB_1ADE :                    1088 C |  LAB_1AE0 :                    109E C |
 LAB_1AFA :                    10B8 C |  LAB_1B0B :                    10CE C |
 LAB_1B13 :                    10D6 C |  LAB_1B1C :                    10E6 C |
 LAB_1B1D :                    10E8 C |  LAB_1B2A :                    10FA C |
 LAB_1B3C :                    1116 C |  LAB_1B43 :                    105C C |
 LAB_1B78 :                    1122 C |  LAB_1B7B :                    1126 C |
 LAB_1B7D :                    1128 C |  LAB_1B84 :                    1132 C |
 LAB_1B86 :                    1136 C |  LAB_1B9D :                    115A C |
 LAB_1BC1 :                    118A C |  LAB_1BD0 :                    11FA C |
 LAB_1BE7 :                    1214 C |  LAB_1BF3 :                    1196 C |
 LAB_1BF7 :                    119C C |  LAB_1BFB :                    11A0 C |
 LAB_1C01 :                    11A8 C |  LAB_1C11 :                    11D2 C |
 LAB_1C13 :                    11D8 C |  LAB_1C18 :                    11E0 C |
 LAB_1C19 :                    11E4 C |  LAB_1C1A :                    11F4 C |
 LAB_1C2A :                    1252 C |  LAB_1CAE :                    12FA C |
 LAB_1CB5 :                    1318 C |  LAB_1CD4 :                    1322 C |
 LAB_1CD5 :                    1328 C |  LAB_1CD6 :                    132A C |
 LAB_1CDB :                    133A C |  LAB_1CE6 :                    132C C |
 LAB_1CF2 :                    133C C |  LAB_1CFE :                    1352 C |
 LAB_1D10 :                    13CA C |  LAB_1D12 :                    13CE C |
 LAB_1D2D :                    13E0 C |  LAB_1D2E :                    13EC C |
 LAB_1D44 :                    1408 C |  LAB_1D45 :                    1418 C |
 LAB_1D48 :                    142C C |  LAB_1D49 :                    1434 C |
 LAB_1D4A :                    1438 C |  LAB_1D4B :                    1448 C |
 LAB_1D5D :                    1450 C |  LAB_1D5E :                    1456 C |
 LAB_1D83 :                    13BA C |  LAB_1D8A :                    13B4 C |
 LAB_1D94 :                    146A C | *LAB_1D96 :                    31B8 C |
*LAB_1D98 :                    1474 C |  LAB_1DAC :                    148E C |
 LAB_1DAE :                    1490 C |  LAB_1DAF :                    149C C |
 LAB_1DB0 :                    14AA C |  LAB_1DB1 :                    14AE C |
 LAB_1DB2 :                    14B2 C |  LAB_1DD7 :                    14CA C |
 LAB_1DE6 :                    14E4 C |  LAB_1E17 :                    1526 C |
 LAB_1E1F :                    152C C |  LAB_1E5C :                    1566 C |
 LAB_1E8D :                    1582 C |  LAB_1EA1 :                    159E C |
 LAB_1EC0 :                    15C6 C |  LAB_1ED6 :                    15F2 C |
 LAB_1ED8 :                    1600 C |  LAB_1EDF :                    15BA C |
 LAB_1F07 :                    1612 C |  LAB_1F28 :                    162C C |
 LAB_1F2C :                    1632 C |  LAB_1F5A :                    1640 C |
 LAB_1F6A :                    1668 C |  LAB_1F6B :                    1674 C |
 LAB_1F7C :                    167A C |  LAB_1FB4 :                    16A8 C |
 LAB_1FD0 :                    16D4 C |  LAB_201E :                    172E C |
 LAB_2043 :                    177C C |  LAB_2044 :                    17AE C |
 LAB_2045 :                    17B8 C |  LAB_204S :                    177E C |
 LAB_204T :                    17AC C |  LAB_20AE :                    17CA C |
 LAB_20B4 :                    17CE C |  LAB_20BE :                    17D4 C |
 LAB_20C9 :                    17F8 C |  LAB_20CB :                    17E4 C |
 LAB_20D0 :                    17EC C |  LAB_20D8 :                    1802 C |
 LAB_20E0 :                    180A C |  LAB_2115 :                    182A C |
 LAB_2117 :                    1842 C |  LAB_2128 :                    185C C |
 LAB_2137 :                    1860 C |  LAB_214B :                    1880 C |
 LAB_2161 :                    1896 C |  LAB_2176 :                    189E C |
 LAB_217E :                    18AC C |  LAB_2183 :                    18C6 C |
 LAB_218B :                    18CE C |  LAB_218F :                    18D0 C |
 LAB_21C2 :                    18DC C |  LAB_21C4 :                    18E2 C |
 LAB_21D1 :                    1916 C |  LAB_2206 :                    191C C |
 LAB_2212 :                    1944 C |  LAB_2216 :                    1906 C |
 LAB_2240 :                    190E C |  LAB_224D :                    194A C |
 LAB_224E :                    1960 C |  LAB_229E :                    19A4 C |
 LAB_22A0 :                    19B0 C |  LAB_22B6 :                    19BE C |
 LAB_22BA :                    19C2 C |  LAB_22BD :                    19CC C |
 LAB_22E6 :                    19E6 C | *LAB_2316 :                    1A26 C |
 LAB_2317 :                    1A28 C |  LAB_231C :                    1A2C C |
 LAB_2358 :                    1A60 C |  LAB_2368 :                    1A80 C |
 LAB_2441 :                    1C74 C |  LAB_2445 :                    1C78 C |
 LAB_2467 :                    1CC8 C |  LAB_2468 :                    1CCC C |
 LAB_249C :                    1CBA C |  LAB_24A8 :                    1CD0 C |
 LAB_24B4 :                    1CFA C |  LAB_24D0 :                    1D06 C |
 LAB_24D5 :                    1D12 C |  LAB_24D6 :                    1D2C C |
 LAB_24D7 :                    1D3A C |  LAB_24D8 :                    1D40 C |
 LAB_24D9 :                    1D20 C |  LAB_24DA :                    1D46 C |
 LAB_24F7 :                    1CEA C |  LAB_24F8 :                    1CF0 C |
 LAB_2778 :                    1FAE C |  LAB_277C :                    1FB0 C |
 LAB_279B :                    1FD4 C |  LAB_27BA :                    1FE2 C |
 LAB_27C3 :                    1FFE C |  LAB_27C4 :                    2008 C |
 LAB_27CA :                    200E C |  LAB_27CE :                    2016 C |
 LAB_27D0 :                    201A C |  LAB_27DB :                    2028 C |
 LAB_27F0 :                    22EC C |  LAB_27F1 :                    2302 C |
 LAB_27F2 :                    2308 C |  LAB_27F3 :                    230A C |
 LAB_27FA :                    2040 C |  LAB_2828 :                    2060 C |
*LAB_282E :                    2066 C |  LAB_282F :                    2068 C |
 LAB_2831 :                    206C C |  LAB_284G :                    2090 C |
 LAB_284H :                    20A2 C |  LAB_284J :                    20A4 C |
 LAB_284L :                    2098 C |  LAB_2887 :                    2CB0 C |
 LAB_289A :                    2CDA C |  LAB_289C :                    2CE0 C |
 LAB_289D :                    2CE6 C |  LAB_28FD :                    2D02 C |
 LAB_28FE :                    2D08 C |  LAB_28FF :                    2D0E C |
 LAB_2900 :                    2D1C C |  LAB_2901 :                    2D22 C |
 LAB_2902 :                    2D74 C |  LAB_2903 :                    2D7C C |
 LAB_2904 :                    2D7E C |  LAB_2953 :                    20C6 C |
 LAB_295E :                    20D2 C |  LAB_2967 :                    20DE C |
 LAB_2968 :                    20E6 C |  LAB_2969 :                    20F8 C |
 LAB_296A :                    2102 C |  LAB_2970 :                    2118 C |
 LAB_2978 :                    2128 C |  LAB_2989 :                    2138 C |
 LAB_299C :                    218C C |  LAB_29A7 :                    21B4 C |
 LAB_29B7 :                    21CC C |  LAB_29B9 :                    2164 C |
 LAB_29C0 :                    21DA C |  LAB_29C3 :                    21F2 C |
 LAB_29D9 :                    220E C |  LAB_29E4 :                    2220 C |
 LAB_29F7 :                    2234 C |  LAB_29FB :                    2238 C |
 LAB_29FD :                    2240 C |  LAB_2A18 :                    2250 C |
 LAB_2A1A :                    2252 C |  LAB_2A21 :                    225A C |
 LAB_2A3B :                    227C C |  LAB_2A4B :                    228A C |
 LAB_2A58 :                    229E C |  LAB_2A68 :                    22B6 C |
 LAB_2A74 :                    22C2 C |  LAB_2A89 :                    22DE C |
 LAB_2A8C :                    22E2 C |  LAB_2A91 :                    22E8 C |
 LAB_2A9A :                    335C C |  LAB_2A9B :                    3378 C |
 LAB_2X01 :                    2D3A C |  LAB_2X02 :                    2D42 C |
 LAB_2X03 :                    2D50 C |  LAB_2X04 :                    2D56 C |
 LAB_2X05 :                    2D6C C |  LAB_2Y01 :                    2D8C C |
 LAB_2Y02 :                    2D94 C |  LAB_2Y03 :                    2DA0 C |
 LAB_2Y04 :                    2DA6 C |  LAB_3216 :                    1F48 C |
 LAB_32_16 :                   1F46 C |  LAB_ABER :                     550 C |
 LAB_ABS :                     2038 C |  LAB_AD :                      36EF C |
 LAB_ADD :                     1C96 C |  LAB_ADER :                     51C C |
 LAB_AND :                     12CE C |  LAB_ASC :                     1B0A C |
 LAB_ATCD :                    268C C |  LAB_ATGO :                    2648 C |
 LAB_ATLE :                    2666 C |  LAB_ATN :                     262A C |
 LAB_ATNP :                    2686 C |  LAB_AYFC :                    16B4 C |
 LAB_BAER :                    3576 C |  LAB_BHCB :                    12B4 C |
 LAB_BHSS :                    128E C |  LAB_BINS :                    2A64 C |
 LAB_BITCLR :                  26EE C |  LAB_BITSET :                  26DE C |
 LAB_BMSG :                    38B9 C |  LAB_BS :                      3618 C |
 LAB_BTST :                    26FE C |  LAB_CALL :                    1C54 C |
 LAB_CASC :                    13A4 C |  LAB_CATN :                    2692 C |
*LAB_CAUC :                    13AA C |  LAB_CBIN :                    2E60 C |
 LAB_CBX1 :                    2E7A C |  LAB_CBXN :                    2E68 C |
 LAB_CCER :                     534 C |  LAB_CHEX :                    2DFE C |
 LAB_CHRS :                    19F0 C |  LAB_CHX1 :                    2E24 C |
 LAB_CHX2 :                    2E48 C |  LAB_CHX3 :                    2E40 C |
 LAB_CHXX :                    2E06 C |  LAB_CKRN :                    16DC C |
 LAB_CKTM :                    103E C |  LAB_CLEAR :                    858 C |
 LAB_CN :                      3685 C |  LAB_COLD :                     464 C |
 LAB_CONT :                     A44 C |  LAB_CORD :                    25BC C |
 LAB_COS :                     254C C |  LAB_CRLF :                     D8A C |
 LAB_CTBL :                    3240 C |  LAB_CTNM :                    103C C |
 LAB_D0 :                      3636 C |  LAB_D002 :                    29C8 C |
 LAB_D00A :                    29D8 C |  LAB_D00E :                    29E8 C |
 LAB_DATA :                     B32 C |  LAB_DD :                      3625 C |
 LAB_DDER :                     54C C |  LAB_DEC :                      C46 C |
 LAB_DECI :                     CA6 C |  LAB_DEEK :                    1BD2 C |
 LAB_DEF :                     16E6 C |  LAB_DIM :                     1356 C |
 LAB_DIV0 :                    1F40 C |  LAB_DIVIDE :                  1EC6 C |
 LAB_DIVX :                    1F16 C |  LAB_DO :                       A76 C |
 LAB_DOKE :                    1BFC C |  LAB_DUPFMT :                  29B0 C |
 LAB_DZER :                     548 C |  LAB_EMSG :                    38C1 C |
 LAB_END :                      9DE C |  LAB_EOR :                     12BE C |
 LAB_EQUAL :                   12E4 C |  LAB_ESML :                    2462 C |
 LAB_EVBY :                    1B22 C |  LAB_EVEX :                    1052 C |
 LAB_EVEZ :                    1054 C |  LAB_EVIN :                    14F0 C |
 LAB_EVIR :                    1500 C |  LAB_EVNM :                    103A C |
 LAB_EVPI :                    14F8 C |  LAB_EX1 :                     239A C |
 LAB_EXAD :                    24EC C |  LAB_EXCC :                    24D2 C |
 LAB_EXCM :                    2404 C |  LAB_EXNN :                    24BE C |
 LAB_EXOF :                    23BE C |  LAB_EXOL :                    23D4 C |
 LAB_EXOU :                    23AA C |  LAB_EXP :                     23DE C |
 LAB_EXPL :                    24B8 C |  LAB_EXPS :                    2416 C |
 LAB_EXRN :                    24C4 C |  LAB_EXXF :                    2E4E C |
 LAB_FB95 :                    2B16 C |  LAB_FBA0 :                    2AFA C |
 LAB_FC :                      35DF C |  LAB_FCER :                     560 C |
 LAB_FO :                      36F7 C |  LAB_FOER :                     518 C |
 LAB_FOR :                      912 C |  LAB_FRE :                     169E C |
 LAB_FTBL :                    32DC C |  LAB_FTPP :                    3290 C |
 LAB_FVAR :                    13C2 C |  LAB_GADB :                    1B76 C |
 LAB_GADW :                    1B8A C |  LAB_GARB :                    1876 C |
 LAB_GBYT :                    11B4 C |  LAB_GEAD :                    1BAA C |
 LAB_GET :                      D04 C |  LAB_GETS :                     D1E C |
 LAB_GFPN :                     C08 C |  LAB_GOSUB :                    A88 C |
 LAB_GOTO :                     A9A C |  LAB_GOTS :                     AAA C |
 LAB_GSCH :                     A2A C |  LAB_GTBY :                    1B1E C |
 LAB_GTHAN :                   238C C |  LAB_GTWO :                    1B34 C |
 LAB_GVAL :                    1160 C |  LAB_GVAR :                    13C4 C |
 LAB_HEXS :                    2AB6 C |  LAB_ID :                      3645 C |
 LAB_IDER :                     544 C |  LAB_IF :                       B5A C |
 LAB_IGBY :                    11B2 C |  LAB_IMSG :                    38D2 C |
 LAB_INC :                      C4C C |  LAB_INCI :                     C9C C |
 LAB_INCT :                     C8E C |  LAB_INLN :                     696 C |
 LAB_INPUT :                    E78 C |  LAB_INT :                     20AA C |
 LAB_IRTS :                    20C4 C |  LAB_ISHN :                    2E20 C |
 LAB_KEYT :                    33E2 C |  LAB_LAAD :                    1DC0 C |
 LAB_LCASE :                   1A88 C |  LAB_LD :                      36A7 C |
 LAB_LDER :                     52C C |  LAB_LEEK :                    1BE8 C |
 LAB_LEFT :                    1A00 C |  LAB_LENS :                    1B02 C |
 LAB_LET :                      CAA C |  LAB_LIST :                     85C C |
 LAB_LMSG :                    38C8 C |  LAB_LOAD :                    1C4C C |
 LAB_LOCC :                    1DC6 C |  LAB_LOCX :                    1DE2 C |
 LAB_LOG :                     1D48 C |  LAB_LOKE :                    1C02 C |
 LAB_LOLP :                    1DD0 C |  LAB_LONE :                    1DFE C |
 LAB_LONN :                    1DE6 C |  LAB_LOOP :                     AC8 C |
 LAB_LOWZ :                    1E38 C |  LAB_LOXO :                    1E04 C |
 LAB_LOXP :                    1DF4 C |  LAB_LRMS :                    126C C |
 LAB_LS :                      3662 C |  LAB_LSHIFT :                  1362 C |
 LAB_LTHAN :                   12EE C |  LAB_LTPF :                    25CC C |
 LAB_LTPT :                    25DC C |  LAB_LT_1 :                    1F54 C |
 LAB_MADD :                    1E66 C |  LAB_MAN1 :                    1F3A C |
 LAB_MAX :                     2B22 C |  LAB_MAXN :                    2B2E C |
 LAB_MIDS :                    1A44 C |  LAB_MIN :                     2B38 C |
 LAB_MINN :                    2B44 C | *LAB_MKCHR :                   19F4 C |
 LAB_MMEC :                    2B4E C |  LAB_MNOC :                    1E60 C |
 LAB_MUEX :                    1EB4 C | *LAB_MUF1 :                    1E90 C |
 LAB_MUF2 :                    1E9A C |  LAB_MUF3 :                    1EB0 C |
 LAB_MULTIPLY :                1E3A C |  LAB_MUUF :                    1EBA C |
 LAB_NB1T :                    1F8C C |  LAB_NEW :                      806 C |
 LAB_NEXT :                     F84 C |  LAB_NF :                      35A6 C |
 LAB_NFER :                     570 C |  LAB_NI :                      36FE C |
 LAB_NOST :                     D30 C |  LAB_NSTT :                    2BB4 C |
 LAB_NULL :                     A3A C |  LAB_OD :                      35D3 C |
 LAB_ODER :                     564 C |  LAB_OFER :                     55C C |
 LAB_OM :                      35F6 C |  LAB_OMER :                     558 C |
 LAB_ON :                       BD4 C |  LAB_OPPT :                    3328 C |
 LAB_OR :                      12C6 C |  LAB_OV :                      35ED C |
 LAB_P004 :                    2A06 C |  LAB_P008 :                    2A1C C |
 LAB_P00C :                    2A24 C |  LAB_P00E :                    2A30 C |
 LAB_P010 :                    2A34 C |  LAB_P018 :                    2A4E C |
 LAB_P01A :                    2A52 C |  LAB_P01E :                    2A5A C |
 LAB_PEEK :                    1BC0 C |  LAB_PFAC :                    1F96 C |
 LAB_PHFA :                    2B5E C |  LAB_PI :                      2C90 C |
 LAB_POKE :                    1BCC C |  LAB_POON :                    230C C |
 LAB_POS :                     16D0 C |  LAB_POWER :                   2328 C |
 LAB_POWP :                    235A C |  LAB_POZE :                    231C C |
 LAB_PPBI :                    1262 C |  LAB_PPFN :                    1254 C |
 LAB_PPFS :                    1246 C |  LAB_PRINT :                    D3E C |
 LAB_PRNA :                     E02 C |  LAB_PROCFO :                  29EE C |
 LAB_P_10 :                    2FD2 C |  LAB_RAM :                     2C86 C |
 LAB_READ :                     E9E C |  LAB_REDO :                    38E2 C |
 LAB_REM :                      BCC C |  LAB_REMM :                    1F6C C |
 LAB_RESS :                     A1E C |  LAB_RESTORE :                  A0C C |
 LAB_RET0 :                    2DEC C |  LAB_RETURN :                   B1E C |
 LAB_RG :                      35BE C |  LAB_RGER :                     568 C |
 LAB_RIGHT :                   1A14 C |  LAB_RMSG :                    38F4 C |
 LAB_RND :                     24F8 C |  LAB_RSED :                    2EEA C |
 LAB_RSHIFT :                  1372 C |  LAB_RTN0 :                    2DEE C |
 LAB_RTST :                    1810 C |  LAB_RUN :                      A62 C |
 LAB_RUNN :                     A70 C |  LAB_SADD :                    1AEA C |
 LAB_SAVE :                    1C50 C |  LAB_SCCA :                    11AA C |
 LAB_SCER :                     538 C |  LAB_SCGB :                    11A4 C |
 LAB_SCL0 :                    25B2 C |  LAB_SCLN :                     7F4 C |
 LAB_SCZE :                    25A4 C |  LAB_SET1 :                    1F1E C |
 LAB_SGBY :                    1B1A C |  LAB_SGN :                     2026 C |
 LAB_SIN :                     2564 C |  LAB_SLER :                     53C C |
 LAB_SMSG :                    38FE C |  LAB_SN :                      35B7 C |
 LAB_SNBS :                     B38 C |  LAB_SNER :                     56C C |
 LAB_SQE1 :                    2C38 C |  LAB_SQE2 :                    2C3E C |
 LAB_SQNA :                    2C66 C |  LAB_SQNS :                    2C50 C |
 LAB_SQR :                     2C14 C |  LAB_SSLN :                     7EC C |
 LAB_ST :                      3672 C |  LAB_STOP :                     9E6 C |
 LAB_STRS :                    17C6 C |  LAB_SUBTRACT :                1C82 C |
 LAB_SVAR :                    13C0 C |  LAB_SVTB :                    2BE6 C |
 LAB_SWAP :                    1C16 C |  LAB_TAN :                     252A C |
 LAB_TBSZ :                    2BC6 C |  LAB_TM :                      3654 C |
 LAB_TMER :                     540 C |  LAB_TWOPI :                   2CA0 C |
 LAB_U002 :                    2756 C |  LAB_U004 :                    27AC C |
 LAB_U005 :                    27BC C |  LAB_U006 :                    27BE C |
 LAB_U008 :                    27D2 C |  LAB_U009 :                    27F4 C |
 LAB_U00A :                    27FC C |  LAB_U00B :                    2806 C |
 LAB_U00C :                    281A C |  LAB_U00D :                    281E C |
 LAB_U00E :                    2830 C |  LAB_U00F :                    283C C |
 LAB_U010 :                    2840 C |  LAB_U014 :                    2846 C |
 LAB_U018 :                    284E C |  LAB_U01C :                    2864 C |
 LAB_U020 :                    2870 C |  LAB_U022 :                    2876 C |
 LAB_U026 :                    2886 C |  LAB_U02A :                    2890 C |
 LAB_U02B :                    28A8 C |  LAB_U02C :                    28AE C |
 LAB_U02E :                    28C0 C |  LAB_U030 :                    28C4 C |
 LAB_U034 :                    28DA C |  LAB_U036 :                    28E0 C |
 LAB_U038 :                    28E8 C |  LAB_U03C :                    28F0 C |
 LAB_U03E :                    28F6 C |  LAB_U040 :                    290E C |
 LAB_U044 :                    291E C |  LAB_U046 :                    2946 C |
 LAB_U048 :                    2948 C |  LAB_U04A :                    2952 C |
 LAB_U04C :                    2984 C |  LAB_UA :                      36CA C |
 LAB_UCASE :                   1AB8 C |  LAB_UDER :                     524 C |
 LAB_UF :                      3694 C |  LAB_UFAC :                    1F7A C |
 LAB_UFER :                     530 C |  LAB_US :                      3604 C |
 LAB_USER :                     554 C |  LAB_USINGS :                  272C C |
 LAB_USR :                     1C44 C |  LAB_UV :                      36B7 C |
 LAB_UVER :                     528 C |  LAB_VAL :                     1B48 C |
 LAB_VALZ :                    1B70 C | *LAB_VARCALL :                 2C78 C |
 LAB_VARPTR :                  2C76 C |  LAB_WAIT :                    1C5E C |
 LAB_WARM :                     400 C |  LAB_WD :                      36DE C |
 LAB_WDER :                     520 C |  LAB_WDLP :                    2BFA C |
 LAB_WDTH :                    2B94 C |  LAB_XDIV :                    1F2E C |
 LAB_XERR :                     572 C |  LAB_XGADW :                   1BA4 C |
 LC_LOOP :                     1A9E C | *LISTON :                         1 - |
 LOOPALWAYS :                   B04 C |  LOOPDONE :                     B18 C |
 LVARPL :                       472 C |  L_DDIV :                      1F74 C |
 L_DIVRND :                    1F22 C | *MACEXP :                         7 - |
 MAINLOOP :                    25F4 C | *MOMCPU :                     68000 - |
*MOMCPUNAME :               "68000" - | *N :                              2 - |
*NESTMAX :                      100 - |  NEXTA :                       2606 C |
 NEXTB1 :                      2A74 C |  NEXTB2 :                      2A9A C |
 NEXTH1 :                      2AC6 C |  NEXTPRN :                     2506 C |
 NINC0 :                       250E C |  NINC1 :                       2514 C |
*NOBRK :                          0 - |  NOLCASE :                     1AE0 C |
 NOSHIFT :                     136E C |  NOSTRING :                    1AE6 C |
 NOT2BIG :                     1386 C |  NOUCASE :                     1AB0 C |
*NOVAR :                          0 - |  NO_KEYIN :                     422 C |
 NULLCT :                       5E4 C |  NUMEXP :                       5AC - |
 OFCHR :                        '#' - |  OQUOTE :                       5DD C |
 OUTLOOP :                     2614 C | *PADDING :                        1 - |
 PIC_REQ :                    80000 - |  PRG_STRT :                     600 - |
 PRNLWORD :                     5A0 C |  PROG_B :                       400 - |
 PRSTK :                        5D8 C |  RAM_BASE :                     400 C |
 RAM_SIZE :                   7C600 - |  RAM_STRT :                    3A00 - |
 RDPTRL :                       466 C | *RELAXED :                        0 - |
 REQ_CONIN :                      1 - |  REQ_CONOUT :                     2 - |
 REQ_CONST :                      3 - |  REQ_E :                        112 C |
*REQ_STROUT :                     4 - |  ROM_E :                       392E C |
 RTS_001 :                     11D0 C |  RTS_005 :                      856 C |
 RTS_006 :                      A38 C |  RTS_007 :                      B36 C |
 RTS_007A :                     B4C C | *RTS_008 :                      D02 C |
 RTS_009 :                      DFE C |  RTS_011 :                     1678 C |
 RTS_012 :                     1948 C |  RTS_013 :                     19BC C |
 RTS_015 :                     1C14 C |  RTS_016 :                     1CEE C |
 RTS_017 :                     200C C |  RTS_020 :                     2398 C |
 RTS_021 :                     26DC C |  RTS_022 :                     2B04 C |
 RTS_023 :                     2C12 C |  RTS_024 :                     2E5E C |
 RTS_025 :                     2EC0 C |  SARRYL :                       43E C |
 SFNCL :                        432 C |  SHAD_0 :                       452 C |
 SHAD_M :                       100 - |  SMEML :                        42E C |
 SSTORL :                       446 C |  SSTRL :                        43A C |
*STR_ADDR :                     102 C |  SUBEXIT :                     261E C |
 SUBLOOP :                     25EC C |  SUFNXF :                       5DF C |
 SUTILL :                       44E C |  SVARL :                        436 C |
 TABSIZ :                       5E2 C |  TAB_ASCA :                    3722 C |
 TAB_ASCB :                    3732 C |  TAB_ASCC :                    374B C |
 TAB_ASCD :                    3762 C |  TAB_ASCE :                    377B C |
 TAB_ASCF :                    378A C |  TAB_ASCG :                    3794 C |
 TAB_ASCH :                    37A1 C |  TAB_ASCI :                    37A7 C |
 TAB_ASCL :                    37B6 C |  TAB_ASCM :                    37E4 C |
 TAB_ASCN :                    37F2 C |  TAB_ASCO :                    3801 C |
 TAB_ASCP :                    3806 C |  TAB_ASCR :                    381B C |
 TAB_ASCS :                    3845 C |  TAB_ASCT :                    3870 C |
 TAB_ASCU :                    3884 C |  TAB_ASCV :                    389C C |
 TAB_ASCW :                    38A8 C |  TAB_ATNC :                    3140 C |
 TAB_CHRT :                    3378 C |  TAB_EQUL :                    371A C |
 TAB_HTHET :                   31C0 C |  TAB_LESS :                    3716 C |
 TAB_MNUS :                    3712 C |  TAB_MORE :                    371C C |
 TAB_PLUS :                    3710 C |  TAB_POWR :                    38B7 C |
 TAB_QEST :                    3720 C |  TAB_SLAS :                    3714 C |
 TAB_SNCO :                    30C0 C |  TAB_STAR :                    370E C |
*TIME :                  "11:45:35" - |  TK_ABS :                        C1 - |
 TK_AND :                        B7 - |  TK_ASC :                        D3 - |
 TK_ATN :                        CC - |  TK_BINS :                       D8 - |
 TK_BITCLR :                     A7 - |  TK_BITSET :                     A6 - |
 TK_BITTST :                     D9 - |  TK_CALL :                       9B - |
 TK_CHRS :                       D6 - |  TK_CLEAR :                      A1 - |
 TK_CONT :                       9F - |  TK_COS :                        C9 - |
 TK_DATA :                       83 - |  TK_DEC :                        88 - |
 TK_DEEK :                       CE - |  TK_DEF :                        97 - |
 TK_DIM :                        85 - |  TK_DIV :                        B5 - |
 TK_DO :                         9C - |  TK_DOKE :                       99 - |
 TK_ELSE :                       A9 - |  TK_END :                        80 - |
 TK_EOR :                        B8 - |  TK_EQUAL :                      BD - |
 TK_EXP :                        C8 - |  TK_FN :                         AB - |
 TK_FOR :                        81 - |  TK_FRE :                        C3 - |
 TK_GET :                        A4 - |  TK_GOSUB :                      8D - |
 TK_GOTO :                       89 - |  TK_GT :                         BC - |
 TK_HEXS :                       D7 - |  TK_IF :                         8B - |
 TK_INC :                        93 - |  TK_INPUT :                      84 - |
 TK_INT :                        C0 - |  TK_LCASES :                     D5 - |
 TK_LEEK :                       CF - |  TK_LEFTS :                      E1 - |
 TK_LEN :                        D0 - |  TK_LET :                        87 - |
 TK_LIST :                       A0 - |  TK_LOAD :                       95 - |
 TK_LOG :                        C7 - |  TK_LOKE :                       9A - |
 TK_LOOP :                       9D - |  TK_LSHIFT :                     BB - |
 TK_LT :                         BE - |  TK_MAX :                        DA - |
 TK_MIDS :                       E3 - |  TK_MIN :                        DB - |
 TK_MINUS :                      B3 - |  TK_MULT :                       B4 - |
 TK_NEW :                        A2 - |  TK_NEXT :                       82 - |
 TK_NOT :                        AE - |  TK_NULL :                       92 - |
 TK_ON :                         91 - |  TK_OR :                         B9 - |
 TK_PEEK :                       CD - |  TK_PI :                         DD - |
 TK_PLUS :                       B2 - |  TK_POKE :                       98 - |
 TK_POS :                        C4 - |  TK_POWER :                      B6 - |
 TK_PRINT :                      9E - |  TK_RAM :                        DC - |
 TK_READ :                       86 - |  TK_REM :                        8F - |
 TK_RESTORE :                    8C - |  TK_RETURN :                     8E - |
 TK_RIGHTS :                     E2 - |  TK_RND :                        C6 - |
 TK_RSHIFT :                     BA - |  TK_RUN :                        8A - |
 TK_SADD :                       E0 - |  TK_SAVE :                       96 - |
 TK_SGN :                        BF - |  TK_SIN :                        CA - |
 TK_SPC :                        AC - |  TK_SQR :                        C5 - |
 TK_STEP :                       AF - |  TK_STOP :                       90 - |
 TK_STRS :                       D1 - |  TK_SWAP :                       A5 - |
 TK_TAB :                        A8 - |  TK_TAN :                        CB - |
 TK_THEN :                       AD - |  TK_TO :                         AA - |
 TK_TWOPI :                      DE - |  TK_UCASES :                     D4 - |
 TK_UNTIL :                      B0 - |  TK_USINGS :                     E4 - |
 TK_USR :                        C2 - |  TK_VAL :                        D2 - |
 TK_VPTR :                       DF - |  TK_WAIT :                       94 - |
 TK_WHILE :                      B1 - |  TK_WIDTH :                      A3 - |
 TOOBIG :                      138C C |  TPOS :                         5E5 C |
 TPOWER :                       5D9 C | *TRUE :                           1 - |
 TWIDTH :                       5E6 C |  UC_LOOP :                     1ACE C |
*UNI_CHR :                      101 C | *UREQ_COM :                     100 C |
 USDSS :                        5CC C |  USRJMP :                       406 C |
*USRJPV :                       408 C | *UT1_PL :                       5A4 C |
 VALUE_OFF :                      0 - |  VARNAME :                      46A C |
 VECT_T :                         0 - |  VEC_CC :                      2AE0 C |
 VEC_IN :                       402 C |  VEC_LD :                       43E C |
 VEC_OUT :                      432 C |  VEC_SV :                       444 C |
*VERSION :                     142F - |  V_CTLC :                       424 C |
*V_CTLCV :                      426 C |  V_INPT :                       40C C |
*V_INPTV :                      40E C |  V_LOAD :                       418 C |
*V_LOADV :                      41A C |  V_OUTP :                       412 C |
*V_OUTPV :                      414 C |  V_SAVE :                       41E C |
*V_SAVEV :                      420 C |  WEXIT :                       2BEA C |
 WORK_B :                      3A00 - |  WORK_E :                       5EB C |
 WORK_END :                     600 - |  WRMJPV :                       402 C |

   1140 symbols
     56 unused symbols

 AS V1.42 Beta [Bld 269] - Source File BASIC68K.ASM - Page 3 - 6/12/2024 11:45:36


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.56 seconds assembly time

   9378 lines source file
      6 passes
      0 errors
      0 warnings
